Title:
```
CAQL: CONTINUOUS ACTION Q-LEARNING
```
Abstract:
```
Value-based reinforcement learning (RL) methods like Q-learning have shown success in a variety of domains. One challenge in applying Q-learning to continuous-action RL problems, however, is the continuous action maximization (max-Q) required for optimal Bellman backup. In this work, we develop CAQL, a (class of) algorithm(s) for continuous-action Q-learning that can use several plug- and-play optimizers for the max-Q problem. Leveraging recent optimization re- sults for deep neural networks, we show that max-Q can be solved optimally us- ing mixed-integer programming (MIP). When the Q-function representation has sufficient power, MIP-based optimization gives rise to better policies and is more robust than approximate methods (e.g., gradient ascent, cross-entropy search). We further develop several techniques to accelerate inference in CAQL, which despite their approximate nature, perform well. We compare CAQL with state-of-the-art RL algorithms on benchmark continuous-control problems that have different de- grees of action constraints and show that CAQL outperforms policy-based meth- ods in heavily constrained environments, often dramatically.
```

Figures/Tables Captions:
```
Figure 1: Mean cumulative reward of the best hyper parameter configuration over 10 random seeds. Data points are average over a sliding window of size 6. The length of an episode is limited to 200 steps. The training curves with standard deviation are given in Figure 4 in Appendix E.
Figure 2: Mean cumulative reward over all 320 configurations (32 hyper parameter combinations × 10 random seeds). Data points are average over a sliding window of size 6. The length of an episode is limited to 200 steps. The training curves with standard deviation are in Figure 5 in Appendix E.
Table 1: The mean ± standard deviation of (95-percentile) final returns with the best hyper- parameter configuration. CAQL significantly outperforms NAF on most benchmarks, as well as DDPG, TD3, and SAC on 11/14 benchmarks.
Table 2: The mean ± standard deviation of (95-percentile) final returns over all 320 configurations (32 hyper parameter combinations × 10 random seeds). CAQL policies are less sensitive to hyper parameters on 11/14 benchmarks.
Table 3: Ablation analysis on CAQL-GA with dual filtering and clustering, where both the mean ± standard deviation of (95-percentile) final returns and the average %-max-Q-reduction (in parenthe- sis) are based on the best configuration. See Figure 7 in Appendix E for training curves.
Table 4: Ablation analysis on CAQL-GA with dynamic tolerance, where both the mean ± standard deviation of (95-percentile) final returns and the average number of GA iterations (in parenthesis) are based on the best configuration. See Figure 9 in Appendix E for training curves. NOTE: In (*) the performance significantly drops after hitting the peak, and learning curve does not converge.
Table 5: Ablation analysis on CAQL-MIP with dynamic tolerance, where both the mean ± standard deviation of (95-percentile) final returns and the (median, standard deviation) of the elapsed time κ (in msec) are based on the best configuration. See Figure 11 in Appendix E for training curves.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Reinforcement learning (RL) has shown success in a variety of domains such as games ( Mnih et al., 2013 ) and recommender systems (RSs) ( Gauci et al., 2018 ). When the action space is finite, value- based algorithms such as Q-learning ( Watkins & Dayan, 1992 ), which implicitly finds a policy by learning the optimal value function, are often very efficient because action optimization can be done by exhaustive enumeration. By contrast, in problems with a continuous action spaces (e.g., robotics ( Peters & Schaal, 2006 )), policy-based algorithms, such as policy gradient (PG) ( Sutton et al., 2000 ;  Silver et al., 2014 ) or cross-entropy policy search (CEPS) ( Mannor et al., 2003 ;  Kalashnikov et al., 2018 ), which directly learn a return-maximizing policy, have proven more practical. Recently, meth- ods such as ensemble critic ( Fujimoto et al., 2018 ) and entropy regularization ( Haarnoja et al., 2018 ) have been developed to improve the performance of policy-based RL algorithms. Policy-based approaches require a reasonable choice of policy parameterization. In some continu- ous control problems, Gaussian distributions over actions conditioned on some state representation is used. However, in applications such as RSs, where actions often take the form of high-dimensional item-feature vectors, policies cannot typically be modeled by common action distributions. Further- more, the admissible action set in RL is constrained in practice, for example, when actions must lie within a specific range for safety ( Chow et al., 2018 ). In RSs, the admissible actions are often random functions of the state ( Boutilier et al., 2018 ). In such cases, it is non-trivial to define policy parameterizations that handle such factors. On the other hand, value-based algorithms are well- suited to these settings, providing potential advantage over policy methods. Moreover, at least with linear function approximation ( Melo & Ribeiro, 2007 ), under reasonable assumptions, Q-learning converges to optimality, while such optimality guarantees for non-convex policy-based methods are generally limited ( Fazel et al., 2018 ). Empirical results also suggest that value-based methods are more data-efficient and less sensitive to hyper-parameters ( Quillen et al., 2018 ). Of course, with large action spaces, exhaustive action enumeration in value-based algorithms can be expensive-- one solution is to represent actions with continuous features ( Dulac-Arnold et al., 2015 ). The main challenge in applying value-based algorithms to continuous-action domains is selecting optimal actions (both at training and inference time). Previous work in this direction falls into three broad categories. The first solves the inner maximization of the (optimal) Bellman residual loss using global nonlinear optimizers, such as the cross-entropy method (CEM) for QT-Opt ( Kalash- nikov et al., 2018 ), gradient ascent (GA) for actor-expert ( Lim et al., 2018 ), and action discretization ( Uther & Veloso, 1998 ;  Smart & Kaelbling, 2000 ;  Lazaric et al., 2008 ). However, these approaches do not guarantee optimality. The second approach restricts the Q-function parameterization so that the optimization problem is tractable. For instance, one can discretize the state and action spaces and use a tabular Q-function representation. However, due to the curse of dimensionality, discretizations must generally be coarse, often resulting in unstable control.  Millán et al. (2002)  circumvents this issue by averaging discrete actions weighted by their Q-values. Wire-fitting ( Gaskett et al., 1999 ;  III & Klopf, 1993 ) approximates Q-values piecewise-linearly over a discrete set of points, chosen to ensure the maximum action is one of the extreme points. The normalized advantage function (NAF) ( Gu et al., 2016 ) constructs the state-action advantage function to be quadratic, hence analytically solvable. Parameterizing the Q-function with an input-convex neural network ( Amos et al., 2017 ) ensures it is concave. These restricted functional forms, however, may degrade performance if the domain does not conform to the imposed structure. The third category replaces optimal Q-values with a "soft" counterpart ( Haarnoja et al., 2018 ): an entropy regularizer ensures that both the opti- mal Q-function and policy have closed-form solutions. However, the sub-optimality gap of this soft policy scales with the interval and dimensionality of the action space ( Neu et al., 2017 ). Motivated by the shortcomings of prior approaches, we propose Continuous Action Q-learning (CAQL), a Q-learning framework for continuous actions in which the Q-function is modeled by a generic feed-forward neural network. 1 Our contribution is three-fold. First, we develop the CAQL framework, which minimizes the Bellman residual in Q-learning using one of several "plug-and- play" action optimizers. We show that "max-Q" optimization, when the Q-function is approximated by a deep ReLU network, can be formulated as a mixed-integer program (MIP) that solves max-Q optimally. When the Q-function has sufficient representation power, MIP-based optimization in- duces better policies and is more robust than methods (e.g., CEM, GA) that approximate the max-Q solution. Second, to improve CAQL's practicality for larger-scale applications, we develop three speed-up techniques for computing max-Q values: (i) dynamic tolerance; (ii) dual filtering; and (iii) clustering. Third, we compare CAQL with several state-of-the-art RL algorithms on several benchmark problems with varying degrees of action constraints. Value-based CAQL is generally competitive, and outperforms policy-based methods in heavily constrained environments, some- times significantly. We also study the effects of our speed-ups through ablation analysis.

Section Title: PRELIMINARIES
  PRELIMINARIES We consider an infinite-horizon, discounted Markov decision process ( Puterman, 2014 ) with states X, (continuous) action space A, reward function R, transition kernel P , initial state distribu- tion β and discount factor γ ∈ [0, 1), all having the usual meaning. A (stationary, Marko- vian) policy π specifies a distribution π(·|x) over actions to be taken at state x. Let ∆ be the set of such policies. The expected cumulative return of π ∈ ∆ is J(π) := E[ ∞ t=0 γ t r t | P, R, x 0 ∼ β, π]. An optimal policy π * satisfies π * ∈ arg max π∈∆ J(π). The Bellman op- erator F [Q](x, a) = R(x, a) + γ x ∈X P (x |x, a) max a ∈A Q(x , a ) over state-action value function Q has unique fixed point Q * (x, a) ( Puterman, 2014 ), which is the optimal Q-function For large or continuous state/action spaces, the optimal Q-function can be approximated, e.g., using a deep neural network (DNN) as in DQN ( Mnih et al., 2013 ). In DQN, the value function Q θ is updated using the value label r + γ max a Q θ target (x , a ), where Q θ target is a target Q-function. Instead of training these weights jointly, θ target is updated in a separate iterative fashion using the previous θ for a fixed number of training steps, or by averaging θ target ← τ θ + (1 − τ )θ target for some small momentum weight τ ∈ [0, 1] ( Mnih et al., 2016 ). DQN is off-policy-the target is valid no matter how the experience was generated (as long as it is sufficiently exploratory). Typically, the loss is minimized over mini-batches B of past data (x, a, r, x ) sampled from a large experience replay buffer R ( Lin & Mitchell, 1992 ). One common loss function for training Q θ * is mean squared Bellman error: min θ |B| i=1 (Q θ (x i , a i ) − r i − γ max a Q θ target (x i , a )) 2 . Under this loss, RL can be viewed as 2 -regression of Q θ (·, ·) w.r.t. target labels r + γ max a Q θ target (x , a ). We augment DQN, using double Q-learning for more stable training ( Hasselt et al., 2016 ), whose loss is: A hinge loss can also be used in Q-learning, and has connections to the linear programming (LP) formulation of the MDP ( Puterman (2014) ). The optimal Q-network weights can be specified as: min θ 1 |B| |B| i=1 Q θ (x i , a i ) + λ (r i + γ max a ∈A Q θ (x i , a ) − Q θ (x i , a i )) + , where λ > 0 is a tun- able penalty w.r.t. constraint: r + γ max a ∈A Q θ (x , a ) ≤ Q θ (x, a), ∀(x, a, r, x ) ∈ B. To stabilize training, we replace the Q-network of the inner maximization with the target Q-network and the optimal Q-value with the double-Q label, giving (see Appendix A for details): In this work, we assume the Q-function approximation Q θ to be a feed-forward network. Specif- ically, let Q θ be a K-layer feed-forward NN with state-action input (x, a) (where a lies in a d- dimensional real vector space) and hidden layers arranged according to the equations: z 1 = (x, a),ẑ j = W j−1 z j−1 + b j−1 , z j = h(ẑ j ), j = 2, . . . , K, Q θ (x, a) := c ẑ K , 2 (3) where (W j , b j ) are the multiplicative and bias weights, c is the output weight of the Q-network, θ = c, {(W j , b j )} K−1 j=1 are the weights of the Q-network,ẑ j denotes pre-activation values at layer j, and h(·) is the (component-wise) activation function. For simplicity, in the following analysis, we restrict our attention to the case when the activation functions are ReLU's. We also assume that the action space A is a d-dimensional ∞ -ball B ∞ (a, ∆) with some radius ∆ > 0 and center a. Therefore, at any arbitrary state x ∈ X the max-Q problem can be re-written as While the above formulation is intuitive, the nonlinear equality constraints in the neural network formulation (3) makes this problem non-convex and NP-hard ( Katz et al., 2017 ).

Section Title: CONTINUOUS ACTION Q-LEARNING ALGORITHM
  CONTINUOUS ACTION Q-LEARNING ALGORITHM Policy-based methods ( Silver et al., 2014 ;  Fujimoto et al., 2018 ;  Haarnoja et al., 2018 ) have been widely-used to handle continuous actions in RL. However, they suffer from several well-known difficulties, e.g., (i) modeling high-dimensional action distributions, (ii) handling action constraints, and (iii) data-inefficiency. Motivated by earlier work on value-based RL methods, such as QT- Opt ( Kalashnikov et al., 2018 ) and actor-expert ( Lim et al., 2018 ), we propose Continuous Action Q-learning (CAQL), a general framework for continuous-action value-based RL, in which the Q- function is parameterized by a NN (Eq. 3). One novelty of CAQL is the formulation of the "max-Q" problem, i.e., the inner maximization in (1) and (2), as a mixed-integer programming (MIP). The benefit of the MIP formulation is that it guarantees that we find the optimal action (and its true bootstrapped Q-value) when computing target labels (and at inference time). We show empirically that this can induce better performance, especially when the Q-network has sufficient representa- tion power. Moreover, since MIP can readily model linear and combinatorial constraints, it offers considerable flexibility when incorporating complex action constraints in RL. That said, finding the optimal Q-label (e.g., with MIP) is computationally intensive. To alleviate this, we develop several approximation methods to systematically reduce the computational demands of the inner maximiza- tion. In Sec. 3.2, we introduce the action function to approximate the arg max-policy at inference time, and in Sec. 4 we propose three techniques, dynamic tolerance, dual filtering, and clustering, to speed up max-Q computation during training.

Section Title: PLUG-N-PLAY MAX-Q OPTIMIZERS
  PLUG-N-PLAY MAX-Q OPTIMIZERS In this section, we illustrate how the max-Q problem, with the Q-function represented by a ReLU network, can be formulated as a MIP, which can be solved using off-the-shelf optimization packages (e.g., SCIP ( Gleixner et al., 2018 ), CPLEX ( CPLEX, 2019 ), Gurobi ( Gurobi, 2019 )). In addition, we detail how approximate optimizers, specifically, gradient ascent (GA) and the cross-entropy method (CEM), can trade optimality for speed in max-Q computation within CAQL. For ease of exposition, we focus on Q-functions parameterized by a feedforward ReLU network. Extending our methodology (including the MIP formulation) to convolutional networks (with ReLU activation and max pooling) is straightforward (see  Anderson et al. (2019) ). While GA and CEM can handle generic activation functions beyond ReLU, our MIP requires additional approximations for those that are not piecewise linear.

Section Title: Mixed-Integer Programming (MIP)
  Mixed-Integer Programming (MIP) A trained feed-forward ReLU network can be modeled as a MIP by formulating the nonlinear activation function at each neuron with binary constraints. Specif- ically, for a ReLU with pre-activation function of form z = max{0, w x + b}, where x ∈ [ , u] is a d-dimensional bounded input, w ∈ R d , b ∈ R, and , u ∈ R d are the weights, bias and lower-upper bounds respectively, consider the following set with a binary variable ζ indicating whether the ReLU is active or not: In this formulation, both M + = max x∈[ ,u] w x + b and M − = min x∈[ ,u] w x + b can be computed in linear time in d. We assume M + > 0 and M − < 0, otherwise the function can be replaced by z = 0 or z = w x + b. These constraints ensure that z is the output of the ReLU: If ζ = 0, then they are reduced to z = 0 ≥ w x+b, and if ζ = 1, then they become z = w x+b ≥ 0. This can be extended to the ReLU network in (3) by chaining copies of intermediate ReLU formu- lations. More precisely, if the ReLU Q-network has m j neurons in layer j ∈ {2, . . . , K}, for any given state x ∈ X, the max-Q problem can be reformulated as the following MIP: where 1 = a − ∆, u 1 = a + ∆ are the (action) input-bound vectors. Since the output layer of the ReLU NN is linear, the MIP objective is linear as well. Here, W j,i ∈ R mj and b j,i ∈ R are the weights and bias of neuron i in layer j. Furthermore, j , u j are interval bounds for the outputs of the neurons in layer j for j ≥ 2, and computing them can be done via interval arithmetic or other propagation methods ( Weng et al., 2018 ) from the initial action space bounds (see Appendix C for details). As detailed by  Anderson et al. (2019) , this can be further tightened with additional constraints, and its implementation can be found in the tf.opt package described therein. As long as these bounds are redundant, having these additional box constraints will not affect optimality. We emphasize that the MIP returns provably global optima, unlike GA and CEM. Even when interrupted with stopping conditions such as a time limit, MIP often produces high-quality solutions in practice. In theory, this MIP formulation can be solved in time exponential on the number of ReLUs and polynomial on the input size (e.g., by naively solving an LP for each binary variable assignment). In practice however, a modern MIP solver combines many different techniques to significantly speed up this process, such as branch-and-bound, cutting planes, preprocessing techniques, and primal heuristics ( Linderoth & Savelsbergh, 1999 ). Versions of this MIP model have been used in neural network verification ( Cheng et al., 2017 ;  Lomuscio & Maganti, 2017 ;  Bunel et al., 2018 ;  Dutta et al., 2018 ;  Fischetti & Jo, 2018 ;  Anderson et al., 2019 ;  Tjeng et al., 2019 ) and analysis ( Serra et al., 2018 ;  Kumar et al., 2019 ), but its application to RL is novel. While  Say et al. (2017)  also proposed a MIP formulation to solve the planning problem with non-linear state transition dynamics model learned with a NN, it is different than ours, which solves the max-Q problem. Gradient Ascent GA ( Nocedal & Wright, 2006 ) is a simple first-order optimization method for finding the (local) optimum of a differentiable objective function, such as a neural network Q- function. At any state x ∈ X, given a "seed" action a 0 , the optimal action arg max a Q θ (x, a) is computed iteratively by a t+1 ← a t + η∇ a Q θ (x, a), where η > 0 is a step size (either a tun- able parameter or computed using back-tracking line search ( Nocedal & Yuan, 1998 )). This process repeats until convergence, |Q θ (x, a t+1 ) − Q θ (x, a t )| < , or a maximum iteration count is reached. Cross-Entropy Method CEM ( Rubinstein, 1999 ) is a derivative-free optimization algorithm. At any given state x ∈ X, it samples a batch of N actions {a i } N i=1 from A using a fixed distribution (e.g., a Gaussian) and ranks the corresponding Q-values {Q θ (x, a i )} N i=1 . Using the top K < N actions, it then updates the sampling distribution, e.g., using the sample mean and covariance to update the Gaussian. This is repeated until convergence or a maximum iteration count is reached.

Section Title: ACTION FUNCTION
  ACTION FUNCTION In traditional Q-learning, the policy π * is "implemented" by acting greedily w.r.t. the learned Q- function: π * (x) = arg max a Q θ (x, a). 3 However, computing the optimal action can be expensive in the continuous case, which may be especially problematic at inference time (e.g., when compu- tational power is limited in, say embedded systems, or real-time response is critical). To mitigate the problem, we can use an action function π w : X → A-effectively a trainable actor network-to approximate the greedy-action mapping π * . We train π w using training data B = {(x i , q * i )} |B| i=1 , where q * i is the max-Q label at state x i . Action function learning is then simply a supervised re- gression problem: w * ∈ arg min w |B| i=1 (q * i − Q θ (x i , π w (x i ))) 2 . This is similar to the notion of "distilling" an optimal policy from max-Q labels, as in actor-expert ( Lim et al., 2018 ). Unlike actor- expert-a separate stochastic policy network is jointly learned with the Q-function to maximize the likelihood with the underlying optimal policy-our method learns a state-action mapping to approx- imate arg max a Q θ (x, a)-this does not require distribution matching and is generally more stable. The use of action function in CAQL is simply optional to accelerate data collection and inference.

Section Title: ACCELERATING MAX-Q COMPUTATION
  ACCELERATING MAX-Q COMPUTATION In this section, we propose three methods to speed up the computationally-expensive max-Q solution during training: (i) dynamic tolerance, (ii) dual filtering, and (iii) clustering.

Section Title: Dynamic Tolerance
  Dynamic Tolerance Tolerance plays a critical role in the stopping condition of nonlinear optimiz- ers. Intuitively, in the early phase of CAQL, when the Q-function estimate has high Bellman error, it may be wasteful to compute a highly accurate max-Q label when a crude estimate can already guide the gradient of CAQL to minimize the Bellman residual. We can speed up the max-Q solver by dynamically adjusting its tolerance τ > 0 based on (a) the TD-error, which measures the estimation error of the optimal Q-function, and (b) the training step t > 0, which ensures the bias of the gradient (induced by the sub-optimality of max-Q solver) vanishes asymptotically so that CAQL converges to a stationary point. While relating tolerance with the Bellman residual is intuitive, it is impossible to calculate that without knowing the max-Q label. To resolve this circular dependency, notice that the action function π w approximates the optimal policy, i.e., π w (·|x) ≈ arg max a Q θ (x, ·). We therefore replace the optimal policy with the action function in Bellman residual and propose the dynamic tolerance: τ t := 1 |B| |B| i=1 |r i + γQ θ target t (x i , π wt (x i )) − Q θt (x i , a i )| · k 1 · k t 2 , where k 1 > 0 and k 2 ∈ [0, 1) are tunable parameters. Under standard assumptions, CAQL with dynamic tolerance {τ t } converges a.s. to a stationary point (Thm. 1, ( Carden, 2014 )).

Section Title: Dual Filtering
  Dual Filtering The main motivation of dual filtering is to reduce the number of max-Q problems at each CAQL training step. For illustration, consider the formulation of hinge Q-learning in (2). Denote by q * x ,θ target the max-Q label w.r.t. the target Q-network and next state x . The structure of the hinge penalty means the TD-error corresponding to sample (x, a, x , r) is inactive whenever q * x ,θ target ≤ (Q θ (x, a) − r)/γ-this data can be discarded. In dual filtering, we efficiently estimate an upper bound on q * x ,θ target using some convex relaxation to determine which data can be discarded before max-Q optimization. Specifically, recall that the main source of non-convexity in (3) comes from the equality constraint of the ReLU activation function at each NN layer. Similar to MIP for- mulation, assume we have component-wise bounds (l j , u j ), j = 2, . . . , K − 1 on the neurons, such that l j ≤ẑ j ≤ u j . The ReLU equality constraint H(l, u) := {(h, k) ∈ R 2 : h ∈ [l, u], k = [h] + } can be relaxed using a convex outer-approximation ( Wong & Kolter, 2017 ):H(l, u) := {(h, k) ∈ R 2 : k ≥ h, k ≥ 0, −uh + (u − l)k ≤ −ul}. We use this approximation to define the re- laxed NN equations, which replace the nonlinear equality constraints in (3) with the convex set H(l, u). We denote the optimal Q-value w.r.t. the relaxed NN asq * x , which is by definition an up- per bound on q * x i . Hence, the condition:q * x ,θ target ≤ (Q θ (x, a) − r)/γ is a conservative certificate for checking whether the data (x, a, x , r) is inactive. For further speed up, we estimateq * x with its dual upper bound (see Appendix C for derivations)q x := −(ν 1 ) a − m · ν 1 q − (ν 1 ) x + K−1 j=2 s∈Ij l j (s)[ν j (s)] + − K−1 j=1 ν j+1 b i , where ν is defined by the following recursion "dual" network: ν K := −c,ν j := W j ν j+1 , j = 1, . . . , K − 1, ν j := D jνj , j = 2, . . . , K − 1, and D s is a diagonal matrix with [D j ](s, s) = 1{s ∈ I + j } + u j (s)/(u j (s) − l j (s)) · 1{s ∈ I j }, and replace the above certificate with an even more conservative one: q x ,θ target ≤ (Q θ (x, a) − r)/γ. Although dual filtering is derived for hinge Q-learning, it also applies to the 2 -loss counterpart by replacing the optimal value q * x ,θ target with its dual upper-bound estimate q x ,θ target whenever the verification condition holds (i.e., the TD error is negative). Since the dual estimate is greater than the primal, the modified loss function will be a lower bound of the original in (1), i.e., (r+γq x ,θ target − Q θ (x, a)) 2 ≤ (r+γq * x ,θ target −Q θ (x, a)) 2 whenever r+γq x ,θ target −Q θ (x, a) ≤ 0, which can stabilize training by reducing over-estimation error. One can utilize the inactive samples in the action function (π w ) learning problem by replacing the max-Q label q * x ,θ with its dual approximation q x ,θ . Since q x ,θ ≥ q * x ,θ , this replacement will not affect optimality.

Section Title: Clustering
  Clustering To reduce the number of max-Q solves further still, we apply online state aggre- gation ( Meyerson, 2001 ), which picks a number of centroids from the batch of next states B as the centers of p-metric balls with radius b > 0, such that the union of these balls form a minimum covering of B . Specifically, at training step t ∈ {0, 1, . . .}, denote by C t (b) ⊆ B the set of next-state centroids. For each next state c ∈ C t (b), we compute the max-Q value q * c ,θ target = max a Q θ target (c , a ), where a * c is the corresponding optimal action. For all remaining next states x ∈ B \ C t (b), we approximate their max-Q values via first-order Taylor series ex- pansionq x ,θ target := q * c ,θ target + ∇ x Q θ target (x , a )| x =c ,a =a * c , (x − c ) in which c is the closest centroid to x , i.e., c ∈ arg min c ∈Ct(b) x −c p . By the envelope theorem for arbitrary choice sets ( Milgrom & Segal, 2002 ), the gradient ∇ x max a Q θ target (x , a ) is equal to ∇ x Q θ target (x , a )| a =a * x . In this approach the cluster radius r > 0 controls the number of max-Q computations, which trades complexity for accuracy in Bellman residual estimation. This parameter can either be a tuned or adjusted dynamically (similar to dynamic tolerance), e.g., r t = k 3 · k t 4 with hyperparameters k 3 > 0 and k 4 ∈ [0, 1). Analogously, with this exponentially-decaying cluster radius schedule we can ar- gue that the bias of CAQL gradient (induced by max-Q estimation error due to clustering) vanishes asymptotically, and the corresponding Q-function converges to a stationary point. To combine clus- tering with dual filtering, we define B df as the batch of next states that are inconclusive after dual filtering, i.e., B df = {x ∈ B : q x ,θ target > (Q θ (x, a) − r)/γ}. Then instead of applying clustering to B we apply this method onto the refined batch B df . Dynamic tolerance not only speeds up training, but also improves CAQL's performance (see Ta- bles 4 and 5); thus, we recommend using it by default. Dual filtering and clustering both trade off training speed with performance. These are practical options-with tunable parameters-that allow practitioners to explore their utility in specific domains.

Section Title: EXPERIMENTS ON MUJOCO BENCHMARKS
  EXPERIMENTS ON MUJOCO BENCHMARKS To illustrate the effectiveness of CAQL, we (i) compare several CAQL variants with several state-of- the-art RL methods on multiple domains, and (ii) assess the trade-off between max-Q computation speed and policy quality via ablation analysis.

Section Title: Comparison with Baseline RL Algorithms
  Comparison with Baseline RL Algorithms We compare CAQL with four baseline methods, DDPG ( Silver et al., 2014 ), TD3 ( Fujimoto et al., 2018 ), and SAC ( Haarnoja et al., 2018 )-three popular policy-based deep RL algorithms-and NAF ( Gu et al., 2016 ), a value-based method using an action-quadratic Q-function. We train CAQL using three different max-Q optimizers, MIP, GA, and CEM. Note that CAQL-CEM counterpart is similar to QT-Opt ( Kalashnikov et al., 2018 ) and CAQL-GA reflects some aspects actor-expert ( Lim et al., 2018 ). These CAQL variants allow assess- ment of the degree to which policy quality is impacted by Q-learning with optimal Bellman residual (using MIP) rather than an approximation (using GA or CEM), at the cost of steeper computation. To match the implementations of the baselines, we use 2 loss when training CAQL. Further ablation analysis on CAQL with 2 loss vs. hinge loss is provided in Appendix E. We evaluate CAQL on one classical control benchmark (Pendulum) and five MuJoCo benchmarks (Hopper, Walker2D, HalfCheetah, Ant, Humanoid). 5 Different than most previous work, we eval- uate the RL algorithms on domains not just with default action ranges, but also using smaller, con- strained action ranges (see Table 6 in Appendix D for action ranges used in our experiments). 6 The motivation for this is two-fold: (i) To simulate real-world problems ( Dulac-Arnold et al., 2019 ), where the restricted ranges represent the safe/constrained action sets; (ii) To validate the hypothe- sis that action-distribution learning in policy-based methods cannot easily handle such constraints, while CAQL does so, illustrating its flexibility. For problems with longer horizons, a larger neural network is often required to learn a good policy, which in turn significantly increases the complexity of the MIP. To reduce this computational cost, we reduce episode length in each experiment from 1000 to 200 steps, and parameterize the Q-function with a relatively simple 32 × 16 feedforward ReLU network. With shorter episodes and smaller networks, the returns of our experiments are lower than those reported in state-of-the-art RL benchmarks ( Duan et al., 2016 ). Details on network architectures and hyperparameters are described in Appendix D. For the more difficult MuJoCo environments (i.e., Ant, HalfCheetah, Humanoid), the number of training steps is set to 500, 000, while for simpler ones (i.e., Pendulum, Hopper, Walker2D), it is set to 200, 000. Policy performance is evaluated every 1000 training iterations, using a policy with no exploration. Each measurement is an average return over 10 episodes, each generated using a separate random seed. To smooth learning curves, data points are averaged over a sliding window of size 6. Similar to the setting of  Lim et al. (2018) , CAQL measurements are based on trajectories that are generated by the learned action function instead of the optimal action w.r.t. the Q-function.  Table 1  and  Figure 1  show the average return of CAQL and the baselines under the best hyperparam- eter configurations. CAQL significantly outperforms NAF on most benchmarks, as well as DDPG, TD3, and SAC on 11 of 14 benchmarks. Of all the CAQL policies, those trained using MIP are among the best performers in low-dimensional benchmarks (e.g., Pendulum and Hopper). This ver- ifies our conjecture about CAQL: Q-learning with optimal Bellman residual (using MIP) performs better than using approximation (using GA, CEM) when the Q-function has sufficient representa- tion power (which is more likely in low-dimensional tasks). Moreover, CAQL-MIP policies have slightly lower variance than those trained with GA and CEM on most benchmarks.  Table 2  and  Fig- ure 2  show summary statistics of the returns of CAQL and the baselines on all 320 configurations (32 hyperparameter combinations × 10 random seeds) and illustrates the sensitivity to hyperparam- eters of each method. CAQL is least sensitive in 11 of 14 tasks, and policies trained using MIP optimization, specifically, are best in 6 of 14 tasks. This corroborates the hypothesis that value- based methods are generally more robust to hyperparameters than their policy-based counterparts. Table 9 in Appendix E.1 compares the speed (in terms of average elapsed time) of various max-Q solvers (MIP, GA, and CEM), with MIP clearly the most computationally intensive. We note that CAQL-MIP suffers from performance degradation in several high-dimensional envi- ronments with large action ranges (e.g., Ant [-0.25, 0.25] and Humanoid [-0.25, 0.25]). In these experiments, its performance is even worse than that of CAQL-GA or CAQL-CEM. We speculate that this is due to the fact that the small ReLU NN (32 × 16) doesn't have enough representation power to accurately model the Q-functions in more complex tasks, and therefore optimizing for the true max-Q value using an inaccurate function approximation impedes learning. We also test CAQL using the standard MuJoCo 1000-step episode length, using gradient ascent as the optimizer, and a Q-function is parameterized with a 200 × 100 feedforward ReLU network for Hopper and with 400 × 300 for the rest benchmarks. CAQL-GA is trained using dynamic tolerance and an action function but without dual filtering or clustering. Figure 6 in Appendix E shows that CAQL-GA performs better than, or similar to, the best of the baseline methods, except on Hopper [-0.25, 0.25]-SAC performed best in that setting, however, it suffers from very high performance variance.

Section Title: Ablation Analysis
  Ablation Analysis We now study the effects of using dynamic tolerance, dual filtering, and clus- tering on CAQL via two ablation analyses. For simplicity, we experiment on standard benchmarks (with full action ranges), and primarily test CAQL-GA using an 2 loss. Default values on tolerance and maximum iteration are 1e-6 and 200, respectively.  Table 3  shows how reducing the number of max-Q problems using dual filtering and clustering af- fects performance of CAQL. Dual filtering (DF) manages to reduce the number of max-Q problems (from 3.2% to 26.5% across different benchmarks), while maintaining similar performance with the unfiltered CAQL-GA. On top of dual filtering we apply clustering (C) to the set of inconclusive next states B df , in which the degree of approximation is controlled by the cluster radius. With a small cluster radius (e.g., b = 0.1), clustering further reduces max-Q solves without significantly impacting training performance (and in some cases it actually improves performance), though fur- ther increasing the radius would significant degrade performance. To illustrate the full trade-off of max-Q reduction versus policy quality, we also include the Dual method, which eliminates all max- Q computation with the dual approximation.  Table 4  shows how dynamic tolerance influences the quality of CAQL policies. Compared with the standard algorithm, with a large tolerance (τ = 100) GA achieves a notable speed up (with only 1 step per max-Q optimization) in training but incurs a loss in performance. GA with dynamic tolerance atttains the best of both worlds-it significantly reduces inner-maximization steps (from 29.5% to 77.3% across different problems and initial τ settings), while achieving good performance. Additionally,  Table 5  shows the results of CAQL-MIP with dynamic tolerance (i.e., optimality gap). This method significantly reduces both median and variance of the MIP elapsed time, while having better performance. Dynamic tolerance eliminates the high latency in MIP observed in the early phase of training (see Figure 3).

Section Title: CONCLUSIONS AND FUTURE WORK
  CONCLUSIONS AND FUTURE WORK We proposed Continuous Action Q-learning (CAQL), a general framework for handling continuous actions in value-based RL, in which the Q-function is parameterized by a neural network. While generic nonlinear optimizers can be naturally integrated with CAQL, we illustrated how the in- ner maximization of Q-learning can be formulated as mixed-integer programming when the Q- function is parameterized with a ReLU network. CAQL (with action function learning) is a general Q-learning framework that includes many existing value-based methods such as QT-Opt and actor- expert. Using several benchmarks with varying degrees of action constraint, we showed that the policy learned by CAQL-MIP generally outperforms those learned by CAQL-GA and CAQL-CEM; and CAQL is competitive with several state-of-the-art policy-based RL algorithms, and often out- performs them (and is more robust) in heavily-constrained environments. Future work includes: extending CAQL to the full batch learning setting, in which the optimal Q-function is trained using only offline data; speeding up the MIP computation of the max-Q problem to make CAQL more scalable; and applying CAQL to real-world RL problems.
  Section 3.2. Empiri- cally, this approach often leads to better policy performance. Smaller action ranges often induce easier MIP problems in max-Q computation. However, given the com- plexity of MIP in more complex environments such as Walker2D, HalfCheetah, Ant, and Humanoid, we run experiments only with action ranges smaller than the defaults.

```
