Title:
```
Published as a conference paper at ICLR 2020 META REINFORCEMENT LEARNING WITH AUTONOMOUS INFERENCE OF SUBTASK DEPENDENCIES
```
Abstract:
```
We propose and address a novel few-shot RL problem, where a task is characterized by a subtask graph which describes a set of subtasks and their dependencies that are unknown to the agent. The agent needs to quickly adapt to the task over few episodes during adaptation phase to maximize the return in the test phase. Instead of directly learning a meta-policy, we develop a Meta-learner with Subtask Graph Inference (MSGI), which infers the latent parameter of the task by interacting with the environment and maximizes the return given the latent parameter. To facilitate learning, we adopt an intrinsic reward inspired by upper confidence bound (UCB) that encourages efficient exploration. Our experiment results on two grid-world domains and StarCraft II environments show that the proposed method is able to accurately infer the latent task parameter, and to adapt more efficiently than existing meta RL and hierarchical RL methods 1 .
```

Figures/Tables Captions:
```
Figure 1: Overview of our method in the context of prepare breakfast task. This task can be broken down into subtasks (e.g., pickup mug) that composes the underlying subtask graph G. (Left) To learn about the unknown task, the agent collects trajectories over K episodes through a parameterized adaptation policy π adapt θ that learns to explore the environment. (Center) With each new trajectory, the agent attempts to infer the task's underlying ground-truth subtask graph G with G. (Right) A separate test policy π test G uses the inferred subtask graph G to produce a trajectory that attempts to maximize the agent's reward rt (e.g., the green trajectory that achieves the boil egg subtask). The more precise G, the more reward the agent would receive, which implicitly improves the adaptation policy π adapt θ to better explore the environment and therefore better infer G in return.
Figure 2: Our inductive logic programming module infers the precondition Gc from adaptation trajectory. For example, the decision tree of subtask E (bottom row) estimates the latent precondition function f G E c : x → e E by fitting its input-output data (i.e., agent's trajectory {xt, e E t } H t=1 ). The decision tree is constructed by choosing a variable (i.e., a component of x) at each node that best splits the data. The learned decision trees of all the subtasks are represented as logic expressions, and then transformed and merged to form a subtask graph.
Figure 3: Left: A visual illustration of Playground domain and an example of underlying subtask graph. The goal is to execute subtasks in the optimal order to maximize the reward within time budget. The subtask graph describes subtasks with the corresponding rewards (e.g., transforming a chest gives 0.1 reward) and dependencies between subtasks through AND and OR nodes. For instance, the agent must first transform chest AND transform diamond before executing pick up duck. Right: A warfare scenario in SC2LE domain (Vinyals et al., 2017). The agent must prepare for the upcoming warfare by training appropriate units, through an appropriate order of subtasks (see Appendix for more details).
Figure 4: Learning curves on the Playground domain. We mea- sure the normalized reward (y- axis) in a test phase, after a certain number of training trials (x-axis).
Figure 5: Generalization performance on unseen tasks (D1-Eval, D2, D3, D4, and Mining-Eval) with varying adaptation horizon. We trained agent with the fixed adaptation budget (K = 10 for Playground and K = 25 for Mining) denoted by the vertical dashed line, and tested with varying unseen adaptation budgets. We report the average normalized return during test phase, where GRProp+Oracle is the upper bound (i.e., R = 1) and Random is the lower bound (i.e., R = 0). The shaded area in the plot indicates the range between R + σ and R − σ where σ is the standard error of normalized return.
Figure 6: Adaptation performance with different adaptation horizon on SC2LE domain.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Recently, reinforcement learning (RL) systems have achieved super-human performance on many complex tasks ( Mnih et al., 2015 ;  Silver et al., 2016 ;  Van Seijen et al., 2017 ). However, these works mostly have been focused on a single known task where the agent can be trained for a long time (e.g.,  Silver et al. (2016) ). We argue that agent should be able to solve multiple tasks with varying sources of reward. Recent work in multi-task RL has attempted to address this; however, they focused on the setting where the structure of task are explicitly described with natural language instructions ( Oh et al., 2017 ;  Andreas et al., 2017 ;  Yu et al., 2017 ;  Chaplot et al., 2018 ), programs ( Denil et al., 2017 ), or graph structures ( Sohn et al., 2018 ). However, such task descriptions may not readily be available. A more flexible solution is to have the agents infer the task by interacting with the environment. Recent work in Meta RL ( Hochreiter et al., 2001 ; Duan et al., 2016;  Wang et al., 2016 ;  Finn et al., 2017 ) (especially in few-shot learning settings) has attempted to have the agents implicitly infer tasks and quickly adapt to them. However, they have focused on relatively simple tasks with a single goal (e.g., multi-armed bandit, locomotion, navigation, etc.). We argue that real-world tasks often have a hierarchical structure and multiple goals, which require long horizon planning or reasoning ability ( Erol, 1996 ;  Xu et al., 2017 ;  Ghazanfari & Taylor, 2017 ;  Sohn et al., 2018 ). Take, for example, the task of making a breakfast in  Figure 1 . A meal can be served with different dishes and drinks (e.g., boiled egg and coffee), where each could be considered as a subtask. These can then be further decomposed into smaller substask until some base subtask (e.g., pickup egg) is reached. Each subtask can provide the agent with reward; if only few subtasks provide reward, this is considered a sparse reward problem. When the subtask dependencies are complex and reward is sparse, learning an optimal policy can require a large number of interactions with the environment. This is the problem scope we focus on in this work: learning to quickly infer and adapt to varying hierarchical tasks with multiple goals and complex subtask dependencies. To this end, we formulate and tackle a new few-shot RL problem called subtask graph inference problem, where the task is defined as a factored MDP ( Boutilier et al., 1995 ;  Jonsson & Barto, 2006 ) with hierarchical structure represented by subtask graph ( Sohn et al., 2018 ) where the task is not known a priori. The task consists of multiple subtasks, where each subtask gives reward when completed (see  Figure 1 ). The complex dependencies between subtasks (i.e., preconditions) enforce agent to execute all the required subtasks before it can execute a certain subtask. Intuitively, the agent can efficiently solve the task by leveraging the inductive bias of underlying task structure (Section 2.2). Inspired by the recent works on multi-task and few-shot RL, we propose a meta reinforcement learning approach that explicitly infers the latent structure of the task (e.g., subtask graph). The agent learns its adaptation policy to collect as much information about the environment as possible in order to rapidly and accurately infer the unknown task structure. After that, the agent's test policy is a contextual policy that takes the inferred subtask graph as an input and maximizes the expected return (See  Figure 1 ). We leverage inductive logic programming (ILP) technique to derive an efficient task inference method based on the principle of maximum likelihood. To facilitate learning, we adopt an intrinsic reward inspired by upper confidence bound (UCB) that encourages efficient exploration. We evaluate our approach on various environments ranging from simple grid-world ( Sohn et al., 2018 ) to StarCraft II ( Vinyals et al., 2017 ). In all cases, our method can accurately infer the latent subtask graph structure, and adapt more efficiently to unseen tasks than the baselines. The contribution of this work can be summarized as follows: • We propose a new meta-RL problem with more general and richer form of tasks compared to the recent meta-RL approaches. • We propose an efficient task inference algorithm that leverages inductive logic programming, which accurately infers the latent subtask graph from the agent's experience data. • We implement a deep meta-RL agent that efficiently infers the subtask graph for faster adaptation. • We compare our method with other meta-RL agents on various domains, and show that our method adapts more efficiently to unseen tasks with complex subtask dependencies.

Section Title: PROBLEM DEFINITION
  PROBLEM DEFINITION

Section Title: BACKGROUND: FEW-SHOT REINFORCEMENT LEARNING
  BACKGROUND: FEW-SHOT REINFORCEMENT LEARNING A task is defined by an MDP M G = (S, A, P G , R G ) parameterized by a task parameter G with a set of states S, a set of actions A, transition dynamics P G , reward function R G . In the K-shot RL formulation (Duan et al., 2016;  Finn et al., 2017 ), each trial under a fixed task M G consists of an adaptation phase where the agent learns a task-specific behavior and a test phase where the adapted behavior is evaluated. For example, RNN-based meta-learners (Duan et al., 2016;  Wang et al., 2016 ) adapt to a task M G by updating its RNN states (or fast-parameters) φ t , where the initialization and update rule of φ t is parameterized by a slow-parameter θ: φ 0 = g(θ), φ t+1 = f (φ t ; θ). Gradient- based meta-learners ( Finn et al., 2017 ;  Nichol et al., 2018 ) instead aim to learn a good initialization of the model so that it can adapt to a new task with few gradient update steps. In the test phase, the agent's performance on the task M G is measured in terms of the return: where π φ H is the policy after K episodes (or H update steps) of adaptation, H is the horizon of test phase, and r t is the reward at time t in the test phase. The goal is to find an optimal parameter θ that maximizes the expected return E G [R M G (π φ H )] over a given distribution of tasks p(G).

Section Title: THE SUBTASK GRAPH INFERENCE PROBLEM
  THE SUBTASK GRAPH INFERENCE PROBLEM We formulate the subtask graph inference problem, an instance of few-shot RL problem where a task is parameterized by subtask graph ( Sohn et al., 2018 ). The details of how a subtask graph parameterizes the MDP is described in Appendix B. Our problem extends the subtask graph execution problem in ( Sohn et al., 2018 ) by removing the assumption that a subtask graph is given to the agent; thus, the agent must infer the subtask graph in order to perform the complex task. Following few-shot RL settings, the agent's goal is to quickly adapt to the given task (i.e., MDP) in the adaptation phase to maximize the return in the test phase (see  Figure 1 ). A task consists of N subtasks and the subtask graph models a hierarchical dependency between subtasks. Subtask: A subtask Φ i can be defined by a tuple (completion set S i comp ⊂ S, precondition G i c : S → {0, 1}, subtask reward function G i r : S → R). A subtask Φ i is complete if the current state is contained in its completion set (i.e., s t ∈ S i comp ), and the agent receives a reward r t ∼ G i r upon the completion of subtask Φ i . A subtask Φ i is eligible (i.e., subtask can be executed) if its precondition G i c is satisfied (see  Figure 1  for examples). A subtask graph is a tuple of precondition and subtask reward of all the subtasks: G = (G c , G r ). Then, the task defined by the subtask graph is a factored MDP ( Boutilier et al., 1995 ;  Schuurmans & Patrascu, 2002 ); i.e., the transition model is factored as p(s |s, a) = i p G i c (s i |s, a) and the reward function is factored as R(s, a) = i R Gr i (s, a) (see Appendix for the detail). The main benefit of factored MDP is that it allows us to model many hierarchical tasks in a principled way with a compact representation such as dynamic Bayesian network ( Dean & Kanazawa, 1989 ;  Boutilier et al., 1995 ). For each subtask Φ i , the agent can learn an option O i ( Sutton et al., 1999b ) that executes the subtask 2 . Environment: The state input to the agent at time step t consists of s t = {x t , e t , step t , epi t , obs t }. • Completion: x t ∈ {0, 1} N indicates whether each subtask is complete. • Eligibility: e t ∈ {0, 1} N indicates whether each subtask is eligible (i.e., precondition is satisfied). • Time budget: step t ∈ R is the remaining time steps until episode termination. • Episode budget: epi t ∈ R is the remaining number of episodes in adaptation phase. • Observation: obs t ∈ R H×W×C is a (visual) observation at time t. At time step t, we denote the option taken by the agent as o t and the binary variable that indicates whether episode is terminated as d t .

Section Title: METHOD
  METHOD We propose a Meta-learner with Subtask Graph Inference (MSGI) which infers the latent subtask graph G.  Figure 1  overviews our approach. Our main idea is to employ two policies: adaptation policy and test policy. During the adaptation phase, an adaptation policy π adapt θ rolls out K episodes 2 As in  Andreas et al. (2017) ;  Oh et al. (2017) ;  Sohn et al. (2018) , such options are pre-learned with curriculum learning; the policy is learned by maximizing the subtask reward, and the initiation set and termination condition are given as I i = {s|G i c (s) = 1} and β i = I(x i = 1) Published as a conference paper at ICLR 2020 Logic expression Logic expression CART train 0 00000 11100 1 10000 11100 2 11000 11101 ⋮ ⋮ ⋮ 11110 11111 Agent trajectory Precondition of CART train Subtask ⋮ Input out 00000 1 10000 1 11000 1 ⋮ ⋮ 11110 1 Subtask ҧ + + Simplify F T >0 =0 >0 F T >0 =1 F T =0 =1 =1 Decision tree of Decision tree of Precondition of True Input out 00000 0 10000 0 11000 1 ⋮ ⋮ 11110 1 Inferred subtask graph ⋮ A B C D E A B C A E Build graph Build graph of adaptation trajectories. From the collected adaptation trajectories, the agent infers the subtask graph G using inductive logic programming (ILP) technique. A test policy π test G , conditioned on the inferred subtask graph G, rolls out episodes and maximizes the return in the test phase. Note that the performance depends on the quality of the inferred subtask graph. The adaptation policy indirectly contributes to the performance by improving the quality of inference. Intuitively, if the adaptation policy completes more diverse subtasks during adaptation, the more "training data" is given to the ILP module, which results in more accurate inferred subtask graph. Algorithm 1 summarizes our meta-training procedure. For meta-testing, see Algorithm 2 in Appendix D.

Section Title: SUBTASK GRAPH INFERENCE
  SUBTASK GRAPH INFERENCE Let τ H = {s 1 , o 1 , r 1 , d 1 , . . . , s H } be an adaptation trajectory of the adaptation policy π adapt θ for K episodes (or H steps in total) in adaptation phase. The goal is to infer the subtask graph G for this task, specified by preconditions G c and subtask rewards G r . We find the maximum-likelihood estimate (MLE) of G = (G c , G r ) that maximizes the likelihood of the adaptation trajectory τ H : The likelihood term can be expanded as where we dropped the terms that are independent of G. From the definitions in Section 2.2, precondi- tion G c defines the mapping x → e, and the subtask reward G r determines the reward as r t ∼ G r i if subtask i is eligible (i.e., e i t = 1) and option O i is executed at time t. Therefore, we have We note that no supervision from the ground-truth subtask graph G is used. Below we explain how to compute the estimate of preconditions G MLE c and subtask rewards G MLE r . Precondition inference via logic induction Since the precondition function f Gc : x → e (see Section 2.2 for definition) is a deterministic mapping, the probability term p(e t |x t , G c ) in Eq.(4) is 1 if e t = f Gc (x t ) and 0 otherwise. Therefore, we can rewrite G MLE c in Eq.(4) as: G MLE c = arg max Gc H t=1 I(e t = f Gc (x t )), (5) where I(·) is the indicator function. Since the eligibility e is factored, the precondition function f Gc i for each subtask is inferred independently. We formulate the problem of finding a boolean function Published as a conference paper at ICLR 2020 that satisfies all the indicator functions in Eq.(5) (i.e., H t=1 I(e t = f Gc (x t )) = 1) as an inductive logic programming (ILP) problem ( Muggleton, 1991 ). Specifically, {x t } H t=1 forms binary vector inputs to programs, and {e i t } H t=1 forms Boolean-valued outputs of the i-th program that denotes the eligibility of the i-th subtask. We use the classification and regression tree (CART) to infer the precondition function f Gc for each subtask based on Gini impurity (Breiman, 1984). Intuitively, the constructed decision tree is the simplest boolean function approximation for the given input-output pairs {x t , e t }. Then, we convert it to a logic expression (i.e., precondition) in sum-of-product (SOP) form to build the subtask graph.  Figure 2  summarizes the overall logic induction process.

Section Title: Subtask reward inference
  Subtask reward inference To infer the subtask reward function G MLE r in Eq.(4), we model each component of subtask reward as a Gaussian distribution G i r ∼ N ( µ i , σ i ). Then, µ i MLE becomes the empirical mean of the rewards received after taking the eligible option O i in the trajectory τ H :

Section Title: TEST PHASE: SUBTASK GRAPH EXECUTION POLICY
  TEST PHASE: SUBTASK GRAPH EXECUTION POLICY Once a subtask graph G has been inferred, we can derive a subtask graph execution (SGE) policy π exe G (o|x) that aims to maximize the cumulative reward in the test phase. Note that this is precisely the problem setting used in  Sohn et al. (2018) . Therefore, we employ a graph reward propagation (GRProp) policy ( Sohn et al., 2018 ) as our SGE policy. Intuitively, the GRProp policy approximates a subtask graph to a differentiable form such that we can compute the gradient of modified return with respect to the completion vector to measure how much each subtask is likely to increase the modified return. Due to space limitation, we give a detail of the GRProp policy in Appendix I.

Section Title: LEARNING: OPTIMIZATION OF THE ADAPTATION POLICY
  LEARNING: OPTIMIZATION OF THE ADAPTATION POLICY We now describe how to learn the adaptation policy π adapt θ , or its parameters θ. We can directly optimize the objective R M G (π) using policy gradient methods ( Williams, 1992 ;  Sutton et al., 1999a ), such as actor-critic method with generalized advantage estimation (GAE) (Schulman et al., 2016). However, we find it challenging to train our model for two reasons: 1) delayed and sparse reward (i.e., the return in the test phase is treated as if it were given as a one-time reward at the last step of adaptation phase), and 2) large task variance due to highly expressive power of subtask graph. To facilitate learning, we propose to give an intrinsic reward r UCB t to agent in addition to the extrinsic environment reward, where r UCB t is the upper confidence bound (UCB) ( Auer et al., 2002 )-inspired exploration bonus term as follows: r UCB t = w UCB · I(x t is novel), w UCB = N i=1 log(n i (0) + n i (1)) n i (e i t ) , (7) where N is the number of subtasks, e i t is the eligibility of subtask i at time t, and n i (e) is the visitation count of e i (i.e., the eligibility of subtask i) during the adaptation phase until time t. The weight w UCB is designed to encourage the agent to make eligible and execute those subtasks that have infrequently been eligible, since such rare data points in general largely improve the inference by balancing the dataset that CART (i.e., our logic induction module) learns from. The conditioning term I(x t is novel) encourages the adaptation policy to visit novel states with a previously unseen completion vector x t (i.e., different combination of completed subtasks), since the data points with same x t input will be ignored in the ILP module as a duplication. We implement I(x t is novel) using a hash table for computational efficiency. Then, the intrinsic objective is given as follows: R UCB M G π adapt θ = E π adapt θ ,M G H t=1 r UCB t , (8) where H is the horizon of adaptation phase. Finally, we train the adaptation policy π adapt θ using an actor-critic method with GAE (Schulman et al., 2016) to maximize the following objective: R PG+UCB M G π adapt θ = R M G π GRProp G + β UCB R UCB M G π adapt θ , (9) where R M G (·) is the meta-learning objective in Eq.(1), β UCB is the mixing hyper-parameter, and G is the inferred subtask graph that depends on the adaptation policy π adapt θ . The complete procedure for training our MSGI agent with UCB reward is summarized in Algorithm 1.

Section Title: RELATED WORK
  RELATED WORK

Section Title: Meta Reinforcement Learning
  Meta Reinforcement Learning There are roughly two broad categories of meta-RL approaches: gradient-based meta-learners ( Finn et al., 2017 ;  Nichol et al., 2018 ;  Gupta et al., 2018 ;  Finn et al., 2018 ;  Kim et al., 2018 ) and RNN-based meta-learners (Duan et al., 2016;  Wang et al., 2016 ). Gradient- based meta RL algorithms, such as MAML ( Finn et al., 2017 ) and Reptile ( Nichol et al., 2018 ), learn the agent's policy by taking policy gradient steps during an adaptation phase, where the meta-learner aims to learn a good initialization that enables rapid adaptation to an unseen task. RNN-based meta-RL methods (Duan et al., 2016;  Wang et al., 2016 ) updates the hidden states of a RNN as a process of adaptation, where both of hidden state initialization and update rule are meta-learned. Other variants of adaptation models instead of RNNs such as temporal convolutions (SNAIL) ( Mishra et al., 2018 ) also have been explored. Our approach is closer to the second category, but different from existing works as we directly and explicitly infer the task parameter.

Section Title: Logic induction
  Logic induction Inductive logic programming systems ( Muggleton, 1991 ) learn a set of rules from examples. ( Xu et al., 2017 ) These works differ from ours as they are open-loop LPI; the input data to LPI module is generated by other policy that does not care about ILP process. However, our agent learns a policy to collect data more efficiently (i.e., closed-loop ILP). There also have been efforts to combine neural networks and logic rules to deal with noisy and erroneous data and seek data efficiency, such as ( Hu et al., 2016 ;  Evans & Grefenstette, 2017 ;  Dong et al., 2019 ).

Section Title: Autonomous Construction of Task Structure
  Autonomous Construction of Task Structure Task planning approaches represented the task structure using Hierarchical Task Networks (HTNs) ( Tate, 1977 ). HTN identifies subtasks for a given task and represent symbolic representations of their preconditions and effects, to reduce the search space of planning ( Hayes & Scassellati, 2016 ). They aim to execute a single goal task, often with assumptions of simpler subtask dependency structures (e.g., without NOT dependency ( Ghazanfari & Taylor, 2017 ;  Liu et al., 2016 )) such that the task structure can be constructed from the successful trajectories. In contrast, we tackle a more general and challenging setting, where each subtask gives a reward (i.e., multi-goal setting) and the goal is to maximize the cumulative sum of reward within an episode. More recently, these task planning approaches were successfully applied to the few-shot visual imitation learning tasks by constructing recursive programs ( Xu et al., 2017 ) or graph ( Huang et al., 2018 ). Contrary to them, we employ an active policy that seeks for experience useful in discovering the task structure in unknown and stochastic environments.

Section Title: EXPERIMENTS
  EXPERIMENTS In the experiment, we investigate the following research questions: (1) Does MSGI correctly infer task parameters G? (2) Does adaptation policy π adapt θ improve the efficiency of few-shot RL? (3) Does the use of UCB bonus facilitate training? (See Appendix H.1) (4) How well does MSGI perform compared with other meta-RL algorithms? (5) Can MSGI generalize to longer adaptation horizon, and unseen and more complex tasks? We evaluate our approach in comparison with the following baselines: • Random is a policy that executes a random eligible subtask that has not been completed. • RL 2 is the meta-RL agent in Duan et al. (2016), trained to maximize the return over K episodes. • HRL is the hierarchical RL agent in  Sohn et al. (2018)  trained with the same actor-critic method as our approach during adaptation phase. The network parameter is reset when the task changes. • GRProp+Oracle is the GRProp policy ( Sohn et al., 2018 ) provided with the ground-truth subtask graph as input. This is roughly an upper bound of the performance of MSGI-based approaches. • MSGI-Rand (Ours) uses a random policy as an adaptation policy, with the task inference module. • MSGI-Meta (Ours) uses a meta-learned policy (i.e., π adapt θ ) as an adaptation policy, with the task inference module. For RL 2 and HRL, we use the same network architecture as our MSGI adaptation policy. More details of training and network architecture can be found in Appendix J. The domains on which we evaluate these approaches include two simple grid-world environments (Mining and Playground) ( Sohn et al., 2018 ) and a more challenging domain SC2LE ( Vinyals et al., 2017 ) (StarCraft II).

Section Title: EXPERIMENTS ON MINING AND PLAYGROUND DOMAINS
  EXPERIMENTS ON MINING AND PLAYGROUND DOMAINS Mining ( Sohn et al., 2018 ) is inspired by Minecraft (see  Figure 3 ) where the agent receives reward by picking up raw materials in the world or crafting items with raw materials. Playground ( Sohn et al.,  2018) is a more flexible and challenging domain, where the environment is stochastic and subtask graphs are randomly generated (i.e., precondition is an arbitrary logic expression). We follow the setting in  Sohn et al. (2018)  for choosing train/evaluation sets. We measure the performance in terms of normalized reward R = (R −R min )/(R max −R min ) averaged over 4 random seeds, where R min and R max correspond to the average reward of the Random and the GRProp+Oracle agent, respectively.

Section Title: TRAINING PERFORMANCE
  TRAINING PERFORMANCE   Figure 4  shows the learning curves of MSGI-Meta and RL 2 , trained on the D1-Train set of Playground domain. We set the adaptation budget in each trial to K = 10 episodes. For MSGI-Rand and HRL (which are not meta-learners), we show the average performance after 10 episodes of adaptation. As training goes on, the performance of MSGI-Meta significantly improves over MSGI-Rand with a large margin. It demonstrates that our meta adaptation policy learns to explore the environment more efficiently, inferring subtask graphs more accurately. We also observe that the performance of RL 2 agent improves over time, eventually outperforming the HRL agent. This indicates that RL 2 learns 1) a good initial policy parameter that captures the common knowledge generally applied to all the tasks and 2) an efficient adaptation scheme such that it can adapt to the given task more quickly than standard policy gradient update in HRL.

Section Title: ADAPTATION AND GENERALIZATION PERFORMANCE
  ADAPTATION AND GENERALIZATION PERFORMANCE

Section Title: Adaptation efficiency
  Adaptation efficiency In  Figure 5 , we measure the test performance (in terms of the normalized reward R) by varying episode budget K (i.e., how many episodes are used in adaptation phase), after 8000 trials of meta-training ( Figure 4 ). Intuitively, it shows how quickly the agent can adapt to the given task. Our full algorithm MSGI-Meta consistently outperforms MSGI-Rand across all the tasks, showing that our meta adaptation policy can efficiently explore informative states that are likely to result in more accurate subtask graph inference. Also, both of our MSGI-based models perform better than HRL and RL 2 baselines in all the tasks, showing that explicitly inferring underlying task structure and executing the predicted subtask graph is more effective than learning slow-parameters and fast-parameters (e.g., RNN states) on those tasks involving complex subtask dependencies.

Section Title: Generalization performance
  Generalization performance We test whether the agents can generalize over unseen task and longer adaptation horizon, as shown in  Figure 5 . For Playground, we follow the setup of ( Sohn et al., 2018 ): we train the agent on D1-Train with the adaptation budget of 10 episodes, and test on unseen graph distributions D1-Eval and larger graphs D2-D4 (See Appendix C for more details about the tasks in Playground and Mining). We report the agent's performance as the normalized reward with up to 20 episodes of adaptation budget. For Mining, the agent is trained on randomly generated graphs with 25 episodes budget and tested on 440 hand-designed graphs used in ( Sohn et al., 2018 ), with up to Published as a conference paper at ICLR 2020 50 episodes of adaptation budget. Both of our MSGI-based models generalize well to unseen tasks and over different adaptation horizon lengths, continuingly improving the agent's performance. It demonstrates that the efficient exploration scheme that our meta adaptation policy can generalize to unseen tasks and longer adaptation horizon, and that our task execution policy, GRProp, generalizes well to unseen tasks as already shown in ( Sohn et al., 2018 ). However, RL 2 fails to generalize to unseen task and longer adaptation horizon: on D2-D4 with adaptation horizons longer than the length the meta-learner was trained for, the performance of the RL 2 agent is almost stationary or even decreases for very long-horizon case (D2, D3, and Mining), eventually being surpassed by the HRL agent. This indicates (1) the adaptation scheme that RL 2 learned does not generalize well to longer adaptation horizons, and (2) a common knowledge learned from the training tasks does not generalize well to unseen test tasks.

Section Title: EXPERIMENTS ON STARCRAFT II DOMAIN
  EXPERIMENTS ON STARCRAFT II DOMAIN SC2LE ( Vinyals et al., 2017 ) is a challenging RL domain built upon the real-time strategy game StarCraft II. We focus on two particular types of scenarios: Defeat Enemy and Build Unit. Each type of the scenarios models the different aspect of challenges in the full game. The goal of Defeat Enemy is to eliminate various enemy armies invading within 2,400 steps. We consider three different combinations of units with varying difficulty: Defeat Zerglings, Defeat Hydralisks, Defeat Hydralisks & Ultralisks (see Figure 9 and demo videos at https://bit.ly/msgi-videos). The goal of Build Unit scenario is to build a specific unit within 2,400 steps. To showcase the advantage of MSGI infering the underlying subtask graph, we set the target unit as Battlecruiser, which is at the highest rank in the technology tree of Terran race. In both scenarios, the agent needs to train the workers, collect resources, and construct buildings and produce units in correct sequential order to win the game. Each building or unit has a precondition as per the technology tree of the player's race (see Figure 11 and Appendix E for more details).

Section Title: Agents
  Agents Note that the precondition of each subtask is determined by the domain and remains fixed across the tasks. If we train the meta agents (MSGI-Meta and RL 2 ), the agents memorize the subtask dependencies (i.e., over-fitting) and does not learn any useful policy for efficient adaptation. Thus, we only evaluate Random and HRL as our baseline agents. Instead of MSGI-Meta, we used MSGI- GRProp. MSGI-GRProp uses the GRProp policy as an adaptation policy since GRProp is a good approximation algorithm that works well without meta-training as shown in ( Sohn et al., 2018 ). Since the environment does not provide any subtask-specific reward, we set the subtask reward using the UCB bonus term in Eq. (7) to encourage efficient exploration (See Appendix for detail).

Section Title: Subtask graph inference
  Subtask graph inference We quantitatively evaluate the inferred subtask graph in terms of the precision and recall of the inferred precondition function f c : x → e. Specifically, we compare the inference output e with the GT label e generated by the GT precondition function f c : x → e for all possible binary assignments of input (i.e., completion vector x). For all the tasks, our MSGI-GRProp agent almost perfectly infers the preconditions with more than 94% precision and 96% recall of all possible binary assignments, when averaged over all 163 preconditions in the game, with only 20 episodes of adaptation budget. We provide the detailed quantitative and qualitative results on the inferred subtask graph in supplemental material. Adaptation efficiency.  Figure 6  shows the adaptation efficiency of MSGI-GRProp, HRL agents, and Random policy on the four scenarios. We report the average victory or success rate over 8 episodes. MSGI-GRProp consistently outperforms HRL agents with a high victory rate, by (1) quickly figuring out the useful units and their prerequisite buildings and (2) focusing on executing these subtasks in a correct order. For example, our MSGI-GRProp learns from the inferred subtask graph that some buildings such as sensor tower or engineering bay are unnecessary for training units and avoids constructing them (see Appendix F for the inferred subtask graph).

Section Title: CONCLUSION
  CONCLUSION We introduced and addressed a few-shot RL problem with a complex subtask dependencies. We proposed to learn the adaptation policy that efficiently collects experiences in the environment, infer the underlying hierarchical task structure, and maximize the expected reward using the execution policy given the inferred subtask graph. The empirical results confirm that our agent can efficiently explore the environment during the adaptation phase that leads to better task inference and leverage the inferred task structure during the test phase. In this work, we assumed that the option is pre- learned and the environment provides the status of each subtask. In the future work, our approach may be extended to more challenging settings where the relevant subtask structure is fully learned from pure observations, and options to execute these subtasks are also automatically discovered.
  The demo videos are available at https://bit.ly/msgi-videos.

```
