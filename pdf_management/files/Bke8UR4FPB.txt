Title:
```
Published as a conference paper at ICLR 2020 OBLIQUE DECISION TREES FROM DERIVATIVES OF RELU NETWORKS
```
Abstract:
```
We show how neural models can be used to realize piece-wise constant functions such as decision trees. The proposed architecture, which we call locally con- stant networks, builds on ReLU networks that are piece-wise linear and hence their associated gradients with respect to the inputs are locally constant. We for- mally establish the equivalence between the classes of locally constant networks and decision trees. Moreover, we highlight several advantageous properties of lo- cally constant networks, including how they realize decision trees with parameter sharing across branching / leaves. Indeed, only M neurons suffice to implicitly model an oblique decision tree with 2 M leaf nodes. The neural representation also enables us to adopt many tools developed for deep networks (e.g., DropCon- nect (Wan et al., 2013)) while implicitly training decision trees. We demonstrate that our method outperforms alternative techniques for training oblique decision trees in the context of molecular property classification and regression tasks. 1
```

Figures/Tables Captions:
```
Figure 1: Toy examples for the equivalent representations of the same mappings for different M . Here the locally constant networks have 1 neuron per layer. We show the locally constant networks on the LHS, the raw mappings in the middle, and the equivalent oblique decision trees on the RHS.
Figure 2: Empirical analysis for oblique decision trees on the HIV dataset. Fig. 2a is an ablation study for LCN and Fig. 2b-2c compare different training methods.
Table 1: Dataset statistics
Table 2: Main results. The 1 st section refers to (oblique) decision tree methods, the 2 nd section refers to single model extensions of LCN, the 3 rd section refers to ensemble methods, and the last section is GCN. The results of GCN are copied from (Wu et al., 2018), where the results in SIDER and Tox21 are not directly comparable due to lack of standard splittings. The best result in each section is in bold letters.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Decision trees (Breiman et al., 1984) employ a series of simple decision nodes, arranged in a tree, to transparently capture how the predicted outcome is reached. Functionally, such tree-based models, including random forest (Breiman, 2001), realize piece-wise constant functions. Beyond their status as de facto interpretable models, they have also persisted as the state of the art models in some tab- ular (Sandulescu & Chiru, 2016) and chemical datasets (Wu et al., 2018). Deep neural models, in contrast, are highly flexible and continuous, demonstrably effective in practice, though lack trans- parency. We merge these two contrasting views by introducing a new family of neural models that implicitly learn and represent oblique decision trees. Prior work has attempted to generalize classic decision trees by extending coordinate-wise cuts to be weighted, linear classifications. The resulting family of models is known as oblique decision trees (Murthy et al., 1993). However, the generalization accompanies a challenging combinatorial, non-differentiable optimization problem over the linear parameters at each decision point. Simple sorting procedures used for successively finding branch-wise optimal coordinate cuts are no longer available, making these models considerably harder to train. While finding the optimal oblique decision tree can be cast as a mixed integer linear program ( Bertsimas & Dunn, 2017 ), scaling remains a challenge. In this work, we provide an effective, implicit representation of piece-wise constant mappings, termed locally constant networks. Our approach exploits piece-wise linear models such as ReLU networks as basic building blocks. Linearity of the mapping in each region in such models means that the gradient with respect to the input coordinates is locally constant. We therefore implicitly represent piece-wise constant networks through gradients evaluated from ReLU networks. We prove the equivalence between the class of oblique decision trees and these proposed locally constant neu- ral models. However, the sizes required for equivalent representations can be substantially different. For example, a locally constant network with M neurons can implicitly realize an oblique decision tree whose explicit form requires 2 M −1 oblique decision nodes. The exponential complexity reduc- Published as a conference paper at ICLR 2020 tion in the corresponding neural representation illustrates the degree to which parameters are shared across the locally constant regions. Our locally constant networks can be learned via gradient descent, and they can be explicitly con- verted back to oblique decision trees for interpretability. For learning via gradient descent, however, it is necessary to employ some smooth annealing of piece-wise linear activation functions so as to keep the gradients themselves continuous. Moreover, we need to evaluate the gradients of all the neurons with respect to the inputs. To address this bottleneck, we devise a dynamic programming algorithm which computes all the necessary gradient information in a single forward pass. A number of extensions are possible. For instance, we can construct approximately locally constant networks by switching activation functions, or apply helpful techniques used with normal deep learning mod- els (e.g., DropConnect (Wan et al., 2013)) while implicitly training tree models. We empirically test our model in the context of molecular property classification and regression tasks (Wu et al., 2018), where tree-based models remain state-of-the-art. We compare our approach against recent methods for training oblique decision trees and classic ensemble methods such as gradient boosting (Friedman, 2001) and random forest. Empirically, a locally constant network always outperforms alternative methods for training oblique decision trees by a large margin, and the ensemble of locally constant networks is competitive with classic ensemble methods.

Section Title: RELATED WORK
  RELATED WORK Locally constant networks are built on a mixed integer linear representation of piece-wise linear networks, defined as any feed-forward network with a piece-wise linear activation function such as ReLU (Nair & Hinton, 2010). One can specify a set of integers encoding the active linear piece of each neuron, which is called an activation pattern ( Raghu et al., 2017 ). The feasible set of an activation pattern forms a convex polyhedron in the input space (Lee et al., 2019), where the net- work degenerates to a linear model. The framework motivates us to leverage the locally invariant derivatives of the networks to construct a locally constant network. The activation pattern is also exploited in literature for other purposes such as deriving robustness certificates (Weng et al., 2018). We refer the readers to the recent work (Lee et al., 2019) and the references therein. Locally constant networks use the gradients of deep networks with respect to inputs as the repre- sentations to build discriminative models. Such gradients have been used in literature for different purposes. They have been widely used for local sensitivity analysis of trained networks (Simonyan et al., 2013;  Smilkov et al., 2017 ). When the deep networks model an energy function (LeCun et al., 2006), the gradients can be used to draw samples from the distribution specified by the normalized energy function (Du & Mordatch, 2019; Song & Ermon, 2019). The gradients can also be used to train generative models (Goodfellow et al., 2014) or perform knowledge distillation (Srinivas & Fleuret, 2018). The class of locally constant networks is equivalent to the class of oblique decision trees. There are some classic methods that also construct neural networks that reproduce decision trees (Sethi, 1990; Brent, 1991; Cios & Liu, 1992), by utilizing step functions and logic gates (e.g., AND/NEGATION) as the activation function. The methods were developed when back-propagation was not yet practically useful, and the motivation is to exploit effective learning procedures of decision trees to train neural networks. Instead, our goal is to leverage the successful deep models to train oblique decision trees. Recently, Yang et al. (2018) proposed a network architecture with arg max activations to represent classic decision trees with coordinate cuts, but their parameterization scales exponentially with input dimension. In stark contrast, our parameterization only scales linearly with input dimension (see our complexity analyses in §3.7). Learning oblique decision trees is challenging, even for a greedy algorithm; for a single oblique split, there can be D k=0 N k different ways to separate N data points in D-dimensional space (Vapnik & Chervonenkis, 1971) (cf. N D possibilities for coordinate-cuts). Existing learning algorithms for oblique decision trees include greedy induction, global optimization, and iterative refinements on an initial tree. We review some representative works, and refer the readers to the references therein. Optimizing each oblique split in greedy induction can be realized by coordinate descent ( Murthy et al., 1994 ) or a coordinate-cut search in some linear projection space (Menze et al., 2011; Wickra- marachchi et al., 2016). However, the greedy constructions tend to get stuck in poor local optimum.

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 There are some works which attempt to find the global optimum given a fixed tree structure by for- mulating a linear program ( Bennett, 1994 ) or a mixed integer linear program ( Bertsimas & Dunn, 2017 ), but the methods are not scalable to ordinary tree sizes (e.g., depth more than 4). The itera- tive refinements are more scalable than global optimization, where CART (Breiman et al., 1984) is the typical initialization. Carreira-Perpinán & Tavallali (2018) develop an alternating optimization method via iteratively training a linear classifier on each decision node, which yield the state-of-the- art empirical performance, but the approach is only applicable to classification problems. Norouzi et al. (2015) proposed to do gradient descent on a sub-differentiable upperbound of tree prediction errors, but the gradients with respect to oblique decision nodes are unavailable whenever the up- perbound is tight. In contrast, our method conducts gradient descent on a differentiable relaxation, which is gradually annealed to a locally constant network. In this section, we introduce the notation and basics in §3.1, construct the locally constant networks in §3.2-3.3, analyze the networks in §3.4-3.5, and develop practical formulations and algorithms in §3.6-3.7. Note that we will propose two (equivalent) architectures of locally constant networks in §3.3 and §3.6, which are useful for theoretical analyses and practical purposes, respectively.

Section Title: NOTATION AND BASICS
  NOTATION AND BASICS The proposed approach is built on feed-forward networks that yield piece-wise linear mappings. Here we first introduce a canonical example of such networks, and elaborate its piece-wise linearity. We consider the densely connected architecture ( Huang et al., 2017 ), where each hidden layer takes as input all the previous layers; it subsumes other existing feed-forward architectures such as residual networks (He et al., 2016). For such a network f θ : R D → R L with the set of parameters θ, we denote the number of hidden layers as M and the number of neurons in the i th layer as N i ; we denote the neurons in the i th layer, before and after activation, as z i ∈ R Ni and a i ∈ R Ni , respectively, where we sometimes interchangeably denote the input instance x as a 0 ∈ R N0 with N 0 D. To simplify exposition, we denote the concatenation of (a 0 , a 1 , . . . , a i ) asã i ∈ RÑ i withÑ i i j=0 N i , ∀i ∈ {0, 1, . . . , M }. The neurons are defined via the weight matrix W i ∈ R Ni×Ñi−1 and the bias vector b i ∈ R Ni in each layer i ∈ [M ] {1, 2, . . . , M }. Concretely, a 0 x, z i W iãi−1 + b i , a i σ(z i ), ∀i ∈ [M ], (1) where σ(·) is a point-wise activation function. Note that both a and z are functions of the specific instance denoted by x, where we drop the functional dependency to simplify notation. We use the set I to denote the set of all the neuron indices in this network {(i, j)|j ∈ [N i ], i ∈ [M ]}. In this work, we will use ReLU (Nair & Hinton, 2010) as a canonical example for the activation function a i j = σ(z i ) j max(0, z i j ), ∀(i, j) ∈ I, (2) but the results naturally generalize to other piece-wise linear activation functions such as leaky ReLU (Maas et al., 2013). The output of the entire network f θ (x) is the affine transformation from all the hidden layersã M with the weight matrix W M +1 ∈ R L×Ñ M and bias vector b M +1 ∈ R L .

Section Title: LOCAL LINEARITY
  LOCAL LINEARITY It is widely known that the class of networks f θ (·) yields a piece-wise linear function. The results are typically proved via associating the end-to-end behavior of the network with its activation pattern - which linear piece in each neuron is activated; once an activation pattern is fixed across the entire network, the network degenerates to a linear model and the feasible set with respect to an activation pattern is a natural characterization of a locally linear region of the network. Formally, we define the activation pattern as the collection of activation indicator functions for each neuron o i j : R D → {0, 1}, ∀(i, j) ∈ I (or, equivalently, the derivatives of ReLU units; see below) 2 : where I[·] is the indicator function. Note that, for mathematical correctness, we define ∂a i j /∂z i j = 1 at z i j = 0; this choice is arbitrary, and one can change it to ∂a i j /∂z i j = 0 at z i j = 0 without affecting most of the derivations. Given a fixed activation patternō i j ∈ {0, 1}, ∀(i, j), we can specify a feasible set in R D that corresponds to this activation pattern {x ∈ R D |o i j =ō i j , ∀(i, j) ∈ I} (note that each o i j is a function of x). Due to the fixed activation pattern, the non-linear ReLU can be re-written as a linear function for all the inputs in the feasible set. For example, for anō i j = 0, we can re-write a i j = 0 × z i j . As a result, the network has a consistent end-to-end linear behavior across the entire feasible set. One can prove that all the feasible sets partition the space R D into disjoint convex polyhedra 3 , which realize a natural representation of the locally linear regions. Since we will only use the result to motivate the construction of locally constant networks, we refer the readers to Lee et al. (2019) for a detailed justification of the piece-wise linearity of such networks.

Section Title: CANONICAL LOCALLY CONSTANT NETWORKS
  CANONICAL LOCALLY CONSTANT NETWORKS Since the ReLU network f θ (x) is piece-wise linear, it immediately implies that its derivatives with respect to the input x is a piece-wise constant function. Here we use J x f θ (x) ∈ R L×D to denote the Jacobian matrix (i.e., [J x f θ (x)] i,j = ∂f θ (x) i /∂x j ), and we assume the Jacobian is consistent with Eq. (3) at the boundary of the locally linear regions. Since any function taking the piece- wise constant Jacobian as input will remain itself piece-wise constant, we can construct a variety of locally constant networks by composition. However, in order to simplify the derivation, we first make a trivial observation that the activation pattern in each locally linear region is also locally invariant. More broadly, any invariant quantity in each locally linear region can be utilized so as to build locally constant networks. We thus define the locally constant networks as any composite function that leverage the local invariance of piece-wise linear networks. For the theoretical analyses, we consider the below architecture.

Section Title: Canonical architecture
  Canonical architecture We denoteõ M ∈ {0, 1}Ñ M as the concatenation of (o 1 , . . . , o M ). We will use the composite function g(õ M ) as the canonical architecture of locally constant networks for theoretical analyses, where g : {0, 1}Ñ M → R L is simply a table. Before elucidating on the representational equivalence to oblique decision trees, we first show some toy examples of the canonical locally constant networks and their equivalent mappings in  Fig. 1 , Published as a conference paper at ICLR 2020 which illustrates their constructions when there is only 1 neuron per layer (i.e., z i = z i 1 , and simi- larly for o i and a i ). When M = 1, o 1 = 1 ⇔ x 1 − x 2 + 1 ≥ 0, thus the locally constant network is equivalent to a linear model shown in the middle, which can also be represented as an oblique decision tree with depth = 1. When M > 1, the activations in the previous layers control different linear behaviors of a neuron with respect to the input, thus realizing a hierarchical structure as an oblique decision tree. For example, for M = 2, o 1 = 0 ⇔ z 1 < 0 ⇒ z 2 = −4x 1 + x 2 + 4 and o 1 = 1 ⇔ z 1 ≥ 0 ⇒ z 2 = −3x 2 + 8; hence, it can also be interpreted as the decision tree on the RHS, where the concrete realization of z 2 depends on the previous decision variable z 1 ≥ 0. Afterwards, we can map either the activation patterns on the LHS or the decision patterns on the RHS to an output value, which leads to the mapping in the middle.

Section Title: REPRESENTATIONAL EQUIVALENCE
  REPRESENTATIONAL EQUIVALENCE In this section, we prove the equivalence between the class of oblique decision trees and the class of locally constant networks. We first make an observation that any unbalanced oblique decision tree can be re-written to be balanced by adding dummy decision nodes 0 x ≥ −1. Hence, we can define the class of oblique decision trees with the balance constraint: Definition 1. The class of oblique decision trees contains any functions that can be procedurally defined (with some depth T ∈ Z >0 ) for x ∈ R D : 1. r 1 I[ω ∅ x + β ∅ ≥ 0], where ω ∅ ∈ R D and β ∅ ∈ R denote the weight and bias of the root decision node. 2. For i ∈ (2, 3, . . . , T ), r i I[ω r1:i−1 x+β r1:i−1 ≥ 0], where ω r1:i−1 ∈ R D and β r1:i−1 ∈ R denote the weight and bias for the decision node after the decision pattern r 1:i−1 . 3. v : {0, 1} T → R L outputs the leaf value v(r 1:T ) associated with the decision pattern r 1:T . The class of locally constant networks is defined by the canonical architecture with finite M and N i , ∀i ∈ [M ]. We first prove that we can represent any oblique decision tree as a locally constant network. Since a typical oblique decision tree can produce an arbitrary weight in each decision node (cf. the structurally dependent weights in the oblique decision trees in  Fig. 1 ), the idea is to utilize a network with only 1 hidden layer such that the neurons do not constrain one another. Concretely, Theorem 2. The class of locally constant networks ⊇ the class of oblique decision trees. Proof. For any oblique decision tree with depth T , it contains 2 T − 1 weights and biases. We thus construct a locally constant network with M = 1 and N 1 = 2 T − 1 such that each pair of (ω, β) in the oblique decision tree is equal to some W 1 k,: and b 1 k in the constructed locally constant network. For each leaf node in the decision tree, it is associated with an output value y ∈ R L and T decisions; the decisions can be written as W 1 idx[j],: x + b 1 idx[j] ≥ 0 for j ∈ {1, 2, . . . , T } and W 1 idx[j],: x + b 1 idx[j] < 0 for j ∈ {T + 1, T + 2, . . . , T } for some index function idx : [T ] → [2 T − 1] and some T ∈ {0, 1, . . . , T }. We can set the table g(·) of the locally constant network as As a result, the constructed locally constant network yields the same output as the given oblique decision tree for all the inputs that are routed to each leaf node, which concludes the proof. Then we prove that the class of locally constant networks is a subset of the class of oblique decision trees, which simply follows the construction of the toy examples in  Fig. 1 . Theorem 3. The class of locally constant networks ⊆ the class of oblique decision trees. Proof. For any locally constant network, it can be re-written to have 1 neuron per layer, by ex- panding any layer with N i > 1 neurons to be N i different layers such that they do not have effective intra-connections. Below the notation refers to the converted locally constant network with 1 neuron per layer. We define the following oblique decision tree with T = M for x ∈ R D : Published as a conference paper at ICLR 2020 Note that, in order to be a valid decision tree, ω 1:ri−1 and β 1:ri−1 have to be unique for all x that yield the same decision pattern r 1:i−1 . To see this, for i ∈ (2, 3, . . . , M ), as r 1:i−1 = (o 1 1 , . . . , o i−1 1 ), we know each z i 1 is a fixed affine function given an activation pattern for the pre- ceding neurons, so ∇ x z i 1 and z i 1 − x ∇ x z i 1 are fixed quantities given a decision pattern r 1:i−1 . Since r 1:M =õ M and v = g, we conclude that they yield the same mapping. Despite the simplicity of the proof, it has some practical implications: Remark 4. The proof of Theorem 3 implies that we can train a locally constant network with M neurons, and convert it to an oblique decision tree with depth M (for interpretability). Remark 5. The proof of Theorem 3 establishes that, given a fixed number of neurons, it suffices (representationally) to only consider the locally constant networks with one neuron per layer. Remark 5 is important for learning small locally constant networks (which can be converted to shallow decision trees for interpretability), since representation capacity is critical for low capacity models. In the remainder of the paper, we will only consider the setting with N i = 1, ∀i ∈ [M ].

Section Title: STRUCTURALLY SHARED PARAMETERIZATION
  STRUCTURALLY SHARED PARAMETERIZATION Although we have established the exact class-level equivalence between locally constant networks and oblique decision trees, once we restrict the depth of the locally constant networks M , it can no longer re-produce all the decision trees with depth M . The result can be intuitively understood by the following reason: we are effectively using M pairs of (weight, bias) in the locally constant network to implicitly realize 2 M − 1 pairs of (weight, bias) in the corresponding oblique decision tree. Such exponential reduction on the effective parameters in the representation of oblique decision trees yields "dimension reduction" of the model capacity. This section aims to reveal the implied shared parameterization embedded in the oblique decision trees derived from locally constant networks. In this section, the oblique decision trees and the associated parameters refer to the decision trees obtained via the proof of Theorem 3. We start the analysis by a decomposition of ω r1:i among the preceding weights ω ∅ , ω r1:1 , . . . , ω r1:r−1 . To simplify notation, we denote ω r1:0 ω ∅ . Since ω r1:i = ∇ x z i+1 1 and z i+1 1 is an affine transformation of the vector (a 0 , a 1 1 , . . . , a i 1 ), where we simply re-write the derivatives in terms of tree parameters. Since W i+1 1,1:D is fixed for all the ω r1:i , the above decomposition implies that, in the induced tree, all the weights ω r1:i in the same depth i are restricted to be a linear combination of the fixed basis W i+1 1,1:D and the corresponding preceding weights ω r1:0 , . . . , ω r1:i−1 . We can extend this analysis to compare weights in same layer, and we begin the analysis by comparing weights whose 0 distance in decision pattern is 1. To help interpret the statement, note that ω r1:j−1 is the weight that leads to the decision r j (or r j ; see below). The proof involves some algebraic manipulation, and is deferred to Appendix A.1. Lemma 6 charac- terizes an interesting structural constraint embedded in the oblique decision trees realized by locally constant networks, where the structural discrepancy r j in decision patterns (r 1:i versus r 1:i ) is re- flected on the discrepancy of the corresponding weights (up to a scaling factor α). The analysis can be generalized for all the weights in the same layer, but the message is similar. Proposition 7. For the oblique decision tree with depth T > 1, ∀i ∈ [T − 1] and any r 1:i , r 1:i such that r k = r k for all k ∈ [i] except for n ∈ [i] coordinates j 1 , . . . , j n ∈ [i], we have The statement can be proved by applying Lemma 6 multiple times.

Section Title: Discussion
  Discussion Here we summarize this section and provide some discussion. Locally constant net- works implicitly represent oblique decision trees with the same depth and structurally shared pa- rameterization. In the implied oblique decision trees, the weight of each decision node is a linear combination of a shared weight across the whole layer and all the preceding weights. The analysis explains how locally constant networks use only M weights to model a decision tree with 2 M − 1 decision nodes; it yields a strong regularization effect to avoid overfitting, and helps computation by exponentially reducing the memory consumption on the weights.

Section Title: STANDARD LOCALLY CONSTANT NETWORKS AND EXTENSIONS
  STANDARD LOCALLY CONSTANT NETWORKS AND EXTENSIONS The simple structure of the canonical locally constant networks is beneficial for theoretical analysis, but the structure is not practical for learning since the discrete activation pattern does not exhibit gra- dients for learning the networks. Indeed, ∇õM g(õ M ) is undefined, which implies that ∇ W i g(õ M ) is also undefined. Here we present another architecture that is equivalent to the canonical architec- ture, but exhibits sub-gradients with respect to model parameters and is flexible for model extension.

Section Title: Standard architecture
  Standard architecture We assume N i = 1, ∀i ∈ [M ]. We denote the Jacobian of all the neurons after activationã M as J xã M ∈ R M ×D , and denote J xã M as the vectorized version. We then define the standard architecture as g φ ( J xã M ), where g φ : R (M ×D) → R L is a fully-connected network. We abbreviate the standard locally constant networks as LCN. Note that each a i 1 is locally linear and thus the Jacobian J xã M is locally constant. We replaceõ M with J xã M as the invariant rep- resentation for each locally linear region 4 , and replace the table g with a differentiable function g φ that takes as input real vectors. The gradients of LCN with respect to parameters is thus established through the derivatives of g φ and the mixed partial derivatives of the neurons (derivatives of J xã M ). Fortunately, all the previous analyses also apply to the standard architecture, due to a fine-grained equivalence between the two architectures. Theorem 8. Given any fixed f θ , any canonical locally constant network g(õ M ) can be equivalently represented by a standard locally constant network g φ ( J xã M ), and vice versa. Since f θ and g control the decision nodes and leaf nodes in the associated oblique decision tree, respectively (see Theorem 3), Theorem 8 essentially states that both architectures are equally com- petent for assigning leaf nodes. Combining Theorem 8 with the analyses in §3.4, we have class-level equivalence among the two architectures of locally constant networks and oblique decision trees. The analyses in §3.5 are also inherited since the analyses only depend on decision nodes (i.e., f θ ). The core ideas for proving Theorem 8 are two-fold: 1) we find a bijection between the activation patternõ M and the Jacobian J xã M , and 2) feed-forward networks g φ can map the (finitely many) Jacobian J xã M as flexibly as a table g. The complete proof is deferred to Appendix A.2.

Section Title: Discussion
  Discussion The standard architecture yields a new property that is only partially exhibited in the canonical architecture. For all the decision and leaf nodes which no training data is routed to, there is no way to obtain learning signals in classic oblique decision trees. However, due to shared pa- rameterization (see §3.5), locally constant networks can "learn" all the decision nodes in the implied oblique decision trees (if there is a way to optimize the networks), and the standard architecture can even "learn" all the leaf nodes due to the parameterized output function g φ .

Section Title: Extensions
  Extensions The construction of (standard) locally constant networks enables several natural exten- sions due to the flexibility of the neural architecture and the interpretation of decision trees. The original locally linear networks (LLN) f θ , which outputs a linear function instead of a constant function for each region, can be regarded as one extension. Here we discuss two examples. • Approximately locally constant networks (ALCN): we can change the activation function while keeping the model architecture of LCN. For example, we can replace ReLU max(0, x) with softplus log(1 + exp(x)), which will lead to an approximately locally constant network, as the softplus function has an approximately locally constant derivative for inputs with large absolute value. Note that the canonical architecture (tabular g) is not compatible with such extension. • Ensemble locally constant networks (ELCN): since each LCN can only output 2 M different val- ues, it is limited for complex tasks like regression (akin to decision trees). We can instead use an additive ensemble of LCN or ALCN to increase the capacity. We use g [e] φ ( J xã M,[e] ) to denote a base model in the ensemble, and denote the ensemble with E models as

Section Title: COMPUTATION AND LEARNING
  COMPUTATION AND LEARNING In this section, we discuss computation and learning algorithms for the proposed models. In the following complexity analyses, we assume g φ to be a linear model.

Section Title: Space complexity
  Space complexity The space complexity of LCN is Θ(M D) for representing decision nodes and Θ(M DL) for representing leaf nodes. In contrast, the space complexity of classic oblique decision trees is Θ((2 M − 1)D) for decision nodes and Θ(2 M L) for leaf nodes. Hence, our representation improves the space complexity over classic oblique decision trees exponentially.

Section Title: Computation and time complexity
  Computation and time complexity LCN and ALCN are built on the gradients of all the neurons J xã M = [∇ x a M 1 , . . . , ∇ x a 1 1 ], which can be computationally challenging to obtain. Existing auto- matic differentiation (e.g., back-propagation) only computes the gradient of a scalar output. Instead, here we propose an efficient dynamic programming procedure which only requires a forward pass: The complexity of the dynamic programming is Θ(M 2 ) due to the inner-summation inside each iteration. Straightforward back-propagation re-computes the partial solutions ∇ x a k 1 for each ∇ x a i 1 , so the complexity is Θ(M 3 ). We can parallelize the inner-summation on a GPU, and the complexity of the dynamic programming and straightforward back-propagation will become Θ(M ) and Θ(M 2 ), respectively. Note that the complexity of a forward pass of a typical network is also Θ(M ) on a GPU. The time complexity of learning LCN by (stochastic) gradient descent is thus Θ(M τ ), where τ denotes the number of iterations. In contrast, the computation of existing oblique decision tree training algorithms is typically data-dependent and thus the complexity is hard to characterize.

Section Title: Training LCN and ALCN
  Training LCN and ALCN where λ t is an iteration-dependent annealing parameter. Both LCN and ALCN can be constructed as a special case of Eq. (5). We train LCN with λ t equal to the ratio between the current epoch and the total epochs, and ALCN with λ t = 0. Both models are optimized via stochastic gradient descent. We also include DropConnect (Wan et al., 2013) to the weight matrices W i ← drop(W i ) during training. Despite the simple structure of DropConnect in the locally constant networks, it entails a structural dropout on the weights in the corresponding oblique decision trees (see §3.5), which is challenging to reproduce in typical oblique decision trees. In addition, it also encourages the exploration of parameter space, which is easy to see for the raw LCN: the randomization enables the exploration that flips o i 1 = 0 to o i 1 = 1 to establish effective learning signal. Note that the standard DropOut (Srivastava et al., 2014) is not ideal for the low capacity models that we consider here.

Section Title: Training ELCN
  Training ELCN Since each ensemble component is sub-differentiable, we can directly learn the whole ensemble through gradient descent. However, the approach is not scalable due to memory constraints in practice. Instead, we propose to train the ensemble in a boosting fashion: 1. We first train an initial locally constant network g [1] φ ( J xã M,[1] ). 2. For each iteration e ∈ {2, 3, . . . , E}, we incrementally optimize Note that, in the second step, only the latest model is optimized, and thus we can simply store the predictions of the preceding models without loading them into the memory. Each partial ensemble can be directly learned through gradient descent, without resorting to complex meta-algorithms such as adaptive boosting (Freund & Schapire, 1997) or gradient boosting (Friedman, 2001).

Section Title: EXPERIMENT
  EXPERIMENT Here we evaluate the efficacy of our models (LCN, ALCN, and ELCN) using the chemical prop- erty prediction datasets from MoleculeNet (Wu et al., 2018), where random forest performs com- petitively. We include 4 (multi-label) binary classification datasets and 1 regression dataset. The statistics are available in  Table 1 . We follow the literature to construct the feature (Wu et al., 2018). Specifically, we use the standard Morgan fingerprint (Rogers & Hahn, 2010), 2,048 binary indi- cators of chemical substructures, for the classification datasets, and 'grid features' (fingerprints of pairs between ligand and protein, see Wu et al. (2018)) for the regression dataset. Each dataset is splitted into (train, validation, test) sets under the criterion specified in MoleculeNet. We compare LCN and its extensions (LLN, ALCN, and ELCN) with the following baselines: • (Oblique) decision trees: CART (Breiman et al. (1984)), HHCART (Wickramarachchi et al. (2016); oblique decision trees induced greedily on linear projections), and TAO (Carreira- Perpinán & Tavallali (2018); oblique decision trees trained via alternating optimization). • Tree ensembles: RF (Breiman (2001); random forest) and GBDT (Friedman (2001); gradient boosting decision trees). • Graph networks: GCN (Duvenaud et al. (2015); graph convolutional networks on molecules). For decision trees, LCN, LLN, and ALCN, we tune the tree depth in {2, 3, . . . , 12}. For LCN, LLN, and ALCN, we also tune the DropConnect probability in {0, 0.25, 0.5, 0.75}. Since regression tasks require precise estimations of the prediction values while classification tasks do not, we tune the number of hidden layers of g φ in {0, 1, 2, 3, 4} (each with 256 neurons) for the regression task, and simply use a linear model g φ for the classification tasks. For ELCN, we use ALCN as the base model, tune the ensemble size E ∈ {2 0 , 2 1 , . . . , 2 6 } for the classification tasks, and E ∈ {2 0 , 2 1 , . . . , 2 9 } for the regression task. To train our models, we use the cross entropy loss for the classification tasks, and mean squared error for the regression task. Other minor details are available in Appendix B. We follow the chemistry literature (Wu et al., 2018) to measure the performance by AUC for classi- fication, and root-mean-squared error (RMSE) for regression. For each dataset, we train a model for Published as a conference paper at ICLR 2020 each label, compute the mean and standard deviation of the performance across 10 different random seeds, and report their average across all the labels within the dataset. The results are in  Table 2 . Among the (oblique) decision tree training algorithms, our LCN achieves the state-of-the-art per- formance. The continuous extension (ALCN) always improves the empirical performance of LCN, which is expected since LCN is limited for the number of possible outputs (leaf nodes). Among the ensemble methods, the proposed ELCN always outperforms the classic counterpart, GBDT, and sometimes outperforms RF. Overall, LCN is the state-of-the-art method for learning oblique deci- sion trees, and ELCN performs competitively against other alternatives for training tree ensembles.

Section Title: Empirical analysis
  Empirical analysis Here we analyze the proposed LCN in terms of the optimization and general- ization performance in the large HIV dataset. We conduct an ablation study on the proposed method for training LCN in Figure 2a. Direct training (without annealing) does not suffice to learn LCN, while the proposed annealing succeed in optimization; even better optimization and generalization performance can be achieved by introducing DropConnect, which corroborates our hypothesis on the exploration effect during training in §3.7 and its well-known regularization effect. Compared to other methods (Fig. 2b), only TAO has a comparable training performance. In terms of generaliza- tion (Fig. 2c), all of the competitors do not perform well and overfit fairly quickly. In stark contrast, LCN outperforms the competitors by a large margin and gets even more accurate as the depth in- creases. This is expected due to the strong regularization of LCN that uses a linear number of effective weights to construct an exponential number of decision nodes, as discussed in §3.5. Some additional analysis and the visualization of the tree converted from LCN are included in Appendix C.

Section Title: DISCUSSION AND CONCLUSION
  DISCUSSION AND CONCLUSION We create a novel neural architecture by casting the derivatives of deep networks as the representa- tion, which realizes a new class of neural models that is equivalent to oblique decision trees. The induced oblique decision trees embed rich structures and are compatible with deep learning meth- ods. This work can be used to interpret methods that utilize derivatives of a network, such as training a generator through the gradient of a discriminator (Goodfellow et al., 2014). The work opens up many avenues for future work, from building representations from the derivatives of neural models to the incorporation of more structures, such as the inner randomization of random forest.
  The boundary of the polyhedron depends on the specific definition of the activation pattern, so, under some definition in literature, the resulting convex polyhedra may not be disjoint in the boundary.

```
