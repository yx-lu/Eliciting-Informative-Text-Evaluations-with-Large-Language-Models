Title:
```
Published as a conference paper at ICLR 2020 WATCH THE UNOBSERVED: A SIMPLE APPROACH TO PARALLELIZING MONTE CARLO TREE SEARCH
```
Abstract:
```
Monte Carlo Tree Search (MCTS) algorithms have achieved great success on many challenging benchmarks (e.g., Computer Go). However, they generally re- quire a large number of rollouts, making their applications costly. Furthermore, it is also extremely challenging to parallelize MCTS due to its inherent sequential nature: each rollout heavily relies on the statistics (e.g., node visitation counts) es- timated from previous simulations to achieve an effective exploration-exploitation tradeoff. In spite of these difficulties, we develop an algorithm, WU-UCT 1 , to effectively parallelize MCTS, which achieves linear speedup and exhibits only limited performance loss with an increasing number of workers. The key idea in WU-UCT is a set of statistics that we introduce to track the number of on-going yet incomplete simulation queries (named as unobserved samples). These statistics are used to modify the UCT tree policy in the selection steps in a principled man- ner to retain effective exploration-exploitation tradeoff when we parallelize the most time-consuming expansion and simulation steps. Experiments on a propri- etary benchmark and the Atari Game benchmark demonstrate the linear speedup and the superior performance of WU-UCT comparing to existing techniques. 1 Code is available at https://github.com/liuanji/WU-UCT.
```

Figures/Tables Captions:
```
Figure 1: MCTS and its parallelization. (a) An overview of MCTS. (b) The ideal parallelization: the most up-to-date statistics {V s , N s } (in chromatic color) are assumed to be available to all workers as soon as a simulation begins (unrealistic in practice). (c) The key challenge in parallelizing MCTS: the workers can only access outdated {V s , N s } (in gray-color), leading problems like collapse of exploration. (d) WU-UCT tracks the number of incomplete simulation queries, which is denoted as O s , and modifies the UCT policy in a principled manner to retain effective exploration-exploitation tradeoff. It achieves comparable speedup and performance as the ideal parallelization.
Figure 2: Diagram of WU-UCT's system architecture and its time consumption. (a) the Green blocks and the task buffers are operated at the master, while the blue blocks are executed by the workers. (b-c) the breakdown of the time consumption on two game benchmarks (Section 5).
Figure 3: Three popular parallel MCTS algorithms. LeafP parallelizes the simulation steps, TreeP uses virtual loss to encourage exploration, and RootP parallelizes the subtrees of the root node.
Figure 4: WU-UCT speedup and performance. Results are averaged over 10 runs. WU- UCT achieves linear speedup with negligible performance loss (measured in game steps).
Figure 5: Speed and performance test of our WU-UCT along with three baselines on four Atari games. All experiments are repeated three times and the mean and standard deviation (for episode reward only) are reported. For WU-UCT, the number of expansion workers is fixed to be one.
Table 1: The performance on 15 Atari games. Average episode return (± standard deviation) over 10 trials are reported. The best average scores among parallel algorithms are highlighted in boldface. The mark * indicates that WU-UCT achieves statistically better performance (p-value < 0.0011 in paired t-test) than TreeP (no mark if both methods perform statistically similar). Similarly, the marks † and ‡ mean that WU-UCT performs statistically better than LeafP and RootP, respectively.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Recently, Monte Carlo Tree Search (MCTS) algorithms such as UCT ( Kocsis et al., 2006 ) have achieved great success in solving many challenging artificial intelligence (AI) benchmarks, includ- ing video games ( Guo et al., 2016 ) and Go ( Silver et al., 2016 ). However, they rely on a large number (e.g. millions) of interactions with the environment emulator to construct search trees for decision-making, which leads to high time complexity ( Browne et al., 2012 ). For this reason, there has been an increasing demand for parallelizing MCTS over multiple workers. However, paralleliz- ing MCTS without degrading its performance is difficult ( Segal, 2010 ;  Mirsoleimani et al., 2018a ;  Chaslot et al., 2008 ), mainly due to the fact that each MCTS iteration requires information from all previous iterations to provide effective exploration-exploitation tradeoff. Specifically, parallelizing MCTS would inevitably obscure these crucial information, and we will show in Section 2.2 that this loss of information potentially results in a significant performance drop. The key question is there- fore how to acquire and utilize more available information to mitigate the information loss caused by parallelization and help the algorithm to achieve better exploration-exploitation tradeoff. To this end, we propose WU-UCT (Watch the Unovserved in UCT), a novel parallel MCTS algo- rithm that attains linear speedup with only limited performance loss. This is achieved by a con- ceptual innovation (Section 3.1) as well as an efficient real system implementation (Section 3.2). Specifically, the key idea in WU-UCT to overcome the aforementioned challenge is a set of statis- tics that tracks the number of on-going yet incomplete simulation queries (named as unobserved samples). We combine these newly devised statistics with the original statistics of observed samples to modify UCT's policy in the selection steps in a principled manner, which, as we shall show in Section 4, effectively retains exploration-exploitation tradeoff during parallelization. Our proposed Published as a conference paper at ICLR 2020 approach has been successfully deployed in a production system for efficiently and accurately esti- mating the rate at which users pass levels (termed user pass-rate) in a mobile game "Joy City", with the purpose of reducing their design cycles. On this benchmark, we show that WU-UCT achieves near-optimal linear speedup and superior performance in predicting user pass-rate (Section 5.1). We further evaluate WU-UCT on the Atari Game benchmark and compare it to state-of-the-art parallel MCTS algorithms (Section 5.2), which also demonstrate our superior speedup and performance.

Section Title: ON THE DIFFICULTIES OF PARALLELIZING MCTS
  ON THE DIFFICULTIES OF PARALLELIZING MCTS We first introduce the MCTS and the UCT algorithms, along with their difficulties in parallelization.

Section Title: MONTE CARLO TREE SEARCH AND UPPER CONFIDENCE BOUND FOR TREES (UCT)
  MONTE CARLO TREE SEARCH AND UPPER CONFIDENCE BOUND FOR TREES (UCT) We consider the Markov Decision Process (MDP) S, A, R, P, γ , where an agent interacts with the environment in order to maximize a long-term cumulative reward. Specifically, an agent at state s t ∈ S takes an action a t ∈ A according to a policy π, so that the MDP transits to the next state s t+1 ∼ P (s t+1 |s t , a t ) and emits a reward R(s t , a t ). 2 The objective of the agent is to learn an optimal policy π * such that the long-term cumulative reward is maximized: max π E at∼π,st+1∼P ∞ t=0 γ t R(s t , a t ) | s 0 = s , (1) where s ∈ S denotes the initial state and γ ∈ (0, 1] is the discount factor. 3 Many reinforcement learning (RL) algorithms have been developed to solve the above problem ( Sutton & Barto, 2018 ), including model-free algorithms ( Mnih et al., 2013 ; 2016;  Williams, 1992 ;  Konda & Tsitsiklis, 2000 ;  Schulman et al., 2015 ; 2017) and model-based algorithms ( Nagabandi et al., 2018 ;  Weber et al., 2017 ;  Bertsekas, 2005 ;  Deisenroth & Rasmussen, 2011 ). Monte Carlo Tree Search (MCTS) is a model-based RL algorithm that plans the best action at each time step ( Browne et al., 2012 ). Specifically, it uses the MDP model (or its sampler) to identify the best action at each time step by constructing a search tree (Figure 1(a)), where each node s represents a visited state, each edge from s denotes an action a s that can be taken at that state, and the landing node s denotes the state it transits to after taking a s . As shown in Figure 1(a), MCTS repeatedly performs four sequential steps: selection, expansion, simulation and backpropagation. The selection step traverses over the existing search tree until the leaf node (or other termination conditions are satisfied) by choosing actions (edges) a s at each node s according to a tree policy. One widely used node-selection policy is the one used in the Upper Confidence bound for Trees (UCT) ( Kocsis et al., 2006 ): a s = arg max s ∈C(s) V s + β 2 log N s N s , (2) where C(s) denotes the set of all child nodes for s; the first term V s is an estimate for the long-term cumulative reward that can be received when starting from the state represented by node s , and the second term represents the uncertainty (size of the confidence interval) of that estimate. The confi- dence interval is calculated based on the Upper Confidence Bound (UCB) ( Auer et al., 2002 ;  Auer, 2002 ) using N s and N s , which denote the number of times that the nodes s and s have been visited, respectively. Therefore, the key idea of the UCT policy (2) is to select the best action according to an optimistic estimation (i.e., the upper confidence bound) of the expected return, which strikes a balance between the exploitation (first term) and the exploration (second term) with β controlling their tradeoff. Once the selection process reaches a leaf node of the search tree (or other termina- tion conditions are met), we will expand the node according to a prior policy by adding a new child node. Then, in the simulation step, we estimate its value function (cumulative reward)V s by running the environment simulator with a default (simulation) policy. Finally, during backpropagation, we update the statistics V s and N s from the leaf node s T to the root node s 0 of the selected path by recursively performing the following update (i.e., from t = T − 1 to t = 0): 2 In the context of MCTS, the action space A is assumed to be finite and the transition P is assumed to be deterministic, i.e., the next state st+1 is determined by the current state st and action at. 3 We assume certain regularity conditions hold so that the cumulative reward ∞ t=0 γ t R(st, at) is always bounded ( Sutton & Barto, 2018 ). whereV s T is the simulation return of s T ; a t denotes the action selected following (2) at state s t .

Section Title: THE INTRINSIC DIFFICULTIES OF PARALLELIZING MCTS
  THE INTRINSIC DIFFICULTIES OF PARALLELIZING MCTS The above discussion implies that the MCTS algorithm is intrinsically sequential: each selection step in a new rollout requires the previous rollouts to complete in order to deliver the updated statis- tics, V s and N s , for the UCT tree policy (2). Although this requirement of up-to-date statistics is not mandatory for implementation, it is in practice intensively required to achieve effective exploration- exploitation tradeoff ( Auer et al., 2002 ). Specifically, up-to-date statistics best help the UCT tree policy to identify and prune non-rewarding branches as well as extensively visiting rewarding paths for additional planning depth. Likewise, to achieve the best possible performance, when multiple workers are used, it is also important to ensure that each worker uses the most recent statistics (the colored V s and N s in Figure 1(b)) in its own selection step. However, this is impossible in paralleliz- ing MCTS based on the following observations. First, the expansion step and the simulation step are generally more time-consuming compared to the other two steps, because they involve a large number of interactions with the environment (or its simulator). Therefore, as exemplified by Figure 1(c), when a worker C initiates a new selection step, the other workers A and B are most likely still in their simulation or expansion steps. This prevents them from updating the (global) statistics for other workers like C, which happens at their respective backpropagation steps. Using outdated statistics (the gray-colored V s and N s ) at different workers could lead to a significant performance loss given a fixed target speedup, due to behaviors like collapes of exploration or exploitation fail- ure, which we shall discuss thoroughly in Section 4. To give an example, Figure 1(c) illustrates the collapse of exploration, where worker C traverses over the same path as the worker A in its selection step due to the determinism of (2). Specifically, if the statistics are unchanged between the moments that worker A and C begin their own selection steps, they will choose the same node according to (2), which greatly reduces the diversity of exploration. Therefore, the key question that we want to address in parallelizing MCTS is how to track the correct statistics and modify the UCT policy in a principled manner, with the hope of retaining effective exploration-exploitation tradeoff at different workers.

Section Title: WU-UCT
  WU-UCT In this section, we first develop the conceptual idea of our WU-UCT algorithm (Section 3.1), and then we present a real system implementation using a master-worker architecture (Section 3.2).

Section Title: WATCH THE UNOBSERVED SAMPLES IN UCT TREE POLICY
  WATCH THE UNOBSERVED SAMPLES IN UCT TREE POLICY As we pointed out earlier, the key question we want to address in parallelizing MCTS is how to deliver the most up-to-date statistics {V s , N s } to each worker so that they can achieve effective exploration-exploitation tradeoff in its selection step. This is assumed to be the case in the ideal parallelization in Figure 1(b). Algorithmically, it is equivalent to the sequential MCTS except that the rollouts are performed in parallel by different workers. Unfortunately, in practice, the statis- tics {V s , N s } available to each worker are generally outdated because of the slow and incomplete simulation and expansion steps at the other workers. Specifically, since the estimated valueV s is unobservable before simulations complete and workers should not wait for the updated statistics to proceed, the (partial) loss of statistics {V s , N s } is unavoidable. Now the question becomes: is there an alternative way to addressing the issue? The answer is in the affirmative and is explained below. Aiming at bridging the gap between naive parallelization and the ideal case, we closely examine their difference in terms of the availability of statistics. As illustrated by the colors of the statistics, their only difference in {V s , N s } is caused by the on-going simulation process. As suggested by (3), although V s can only be updated after a simulation step is completed, the newest N s information can actually be available as early as a worker initiates a new rollout. This is the key insight that we leverage to enable effective parallelization in our WU-UCT algorithm. Motivated by this, we introduce another quantity, O s , to count the number of rollouts that have been initiated but not yet completed, which we name as unobserved samples. That is, our new statistics, O s , watch the number of unobserved samples, and are then used to correct the UCT tree policy (2) into the following form: The intuition of the above modified node-selection policy is that when there are O s workers sim- ulating (querying) node s, the confidence interval at node s will eventually be shrunk after they complete. Therefore, adding O s and O s to the exploration term considers such a fact beforehand and let other workers be aware of it. Despite its simple form, (4) provides a principled way to retain effective exploration-exploitation tradeoff under parallel settings; it corrects the confidence bound towards better exploration-exploitation tradeoff. As the confidence level is instantly updated (i.e., at the beginning of simulation), more recent workers are guaranteed to observe additional statistics, which prevent them from extensively querying the same node as well as find better nodes for them to query. For example, when multiple children are in demand for exploration, (4) allows them to be explored evenly. In contrast, when a node has been sufficiently visited (i.e., large N s and N s ), adding O s and O s from the unobserved samples have little effect on (4) because the confidence interval is sufficiently shrunk around V s , allowing extensively exploitation of the best-valued child.

Section Title: SYSTEM IMPLEMENTATION USING MASTER-WORKER ARCHITECTURES
  SYSTEM IMPLEMENTATION USING MASTER-WORKER ARCHITECTURES We now proceed to explain the system implementation of WU-UCT, where the overall architecture is shown in Figure 2(a) (see Appendix A for the details). Specifically, we use a master-worker ar- chitecture to implement the WU-UCT algorithm with the following considerations. First, since the expansion and the simulation steps are much more time-consuming compared to the selection and the backpropagation steps, they should be intensively parallelized. In fact, they are relatively easy to parallelize (e.g., different simulations could be performed independently). Second, as we dis- cussed earlier, different workers need to access the most up-to-date statistics {V s , N s , O s } in order to achieve successful exploration-exploitation tradeoff. To this end, a centralized architecture for the selection and backpropagation step is more preferable as it allows adding strict restrictions to the retrieval and update of the statistics, making them up-to-date. Specifically, we use a central- ized master process to maintain a global set of statistics (in addition to other data such as game states), and let it be in charge of the backpropagation step (i.e., updating the global statistics) and the selection step (i.e., exploiting the global statistics). As shown in Figure 2(a), the master process repeatedly performs rollouts until a predefined number of simulations is reached. During each roll- out, it selects nodes to query, assign expansion and simulation tasks to different workers, and collect the returned results to update the global statistics. In particular, we use the following incomplete update and complete update (shown in Figure 2(a)) to track N s and O s along the traversed path (see Figure 1(d)): [incomplete update] O s ← O s + 1, (5) [complete update] O s ← O s − 1; N s ← N s + 1, (6) where incomplete update is performed before the simulation task starts, allowing the updated statis- tics to be instantly available globally; complete update is done after the simulation return is available, resembling the backpropagation step in the sequential algorithm. In addition, V s is also updated in the complete update step using (3). Such a clear division of labor between the master and the work- ers provides sequential selection and backpropagation steps when we parallelize the costly expan- sion and simulation steps. It ensures up-to-date statistics for all workers by the centralized master process and achieves linear speedup without much performance degradation (see Section 5 for the experimental results). To justify the above rationale of our system design, we perform a set of running time analysis for our developed WU-UCT system and report the results in Figure 2(b)-(c). We show the time- consumption for different parts at the master and at the workers. First, we focus exclusively on the workers. With a close-to-100% occupancy rate for the simulation workers, the simulation step is fully parallelized. Although the expansion workers are not fully utilized, the expansion step is max- imumly parallelized since the number of required simulation and expansion tasks is identical. This suggests the existence of an optimal (task-dependent) ratio between the number of expansion work- ers and the number of simulation workers that fully parallelize both steps with the least resources (e.g. memory). Returning to the master process, on both benchmarks, we see a clear dominance of the time spent on the simulation and the expansion steps even they are both parallelized by 16 workers. This supports our design to parallelize only the simulation and expansion steps. We finally focus on the communication overhead caused by parallelization. Although more time-consuming compared to simulation and backpropagation, the communication overhead is negligible compared to the time used by the expansion and the simulation steps. Other details in our system, such as the centralized game-state storage, are further discussed in Appendix A.

Section Title: THE BENEFITS OF WATCHING UNOBSERVED SAMPLES
  THE BENEFITS OF WATCHING UNOBSERVED SAMPLES In this section, we discuss the benefits of watching unobserved samples in WU-UCT, and compare it with several popular parallel MCTS algorithms ( Figure 3 ), including Leaf Parallelization (LeafP), Published as a conference paper at ICLR 2020 A B C During simulation, multiple workers (e.g. A, B, C) simultaneously query the same node. Selection, expansion, and backpropagation are sequentially executed (similar to UCT). Tree Parallelization (TreeP) with virtual loss, and Root Parallelization (RootP). 4 LeafP parallelizes the leaf simulation, which leads to an effective hex game solver ( Wang et al., 2018 ). TreeP with virtual loss has recently achieved great success in challenging real-world tasks such as Go ( Silver et al., 2016 ). And RootP parallelizes the subtrees of the root node at different workers and aggregates the statistics of the subtrees after all the workers complete their simulations ( Soejima et al., 2010 ). We argue that, by introducing the additional statistics O s , WU-UCT achieves a better exploration- exploitation tradeoff than the above methods. First, LeafP and TreeP represent two extremes in such a tradeoff. LeafP lacks diversity in exploration as all its workers are assigned to simulating the same node, leading to performance drop caused by collapse of exploration in much the same way as the naive parallelization (see Figure 1(c)). In contrast, although the virtual loss used in TreeP could encourage exploration diversity, this hard additive penalty could cause exploitatin failure: workers will be less likely to co-simulating the same node even when they are certain that it is optimal ( Mirsoleimani et al., 2017 ). RootP tries to avoid these issues by letting workers perform an independent tree search. However, this reduces the equivalent number of rollouts at each worker, decreasing the accuracy of the UCT policy (2). Different from the above three approaches, WU- UCT achieves a much better exploration-exploitation tradeoff in the following manner. It encourages exploration by using O s to "penalize" the nodes that have many in-progress simulations. Meanwhile, it allows multiple workers to exploit the most rewarding node since this "penalty" vanishes when N s becomes large (see (4)).

Section Title: EXPERIMENTS
  EXPERIMENTS This section evaluates the proposed WU-UCT algorithm on a production system to predict the user pass-rate of a mobile game (Section 5.1) as well as on the public Atari Game benchmark (Sec- tion 5.2), aiming at demonstrating the superior performance and near-linear speedup of WU-UCT.

Section Title: EXPERIMENTS ON THE "JOY CITY" GAME
  EXPERIMENTS ON THE "JOY CITY" GAME Joy City is a level-oriented game with diverse and challenging gameplay. Players tap to eliminate connected items on the game board. To pass a level, players have to complete certain goals within a given number of steps. 5 The number of steps used to pass a level (termed game step) is the main performance metric, which differentiates masters from beginners. It is a challenging reinforcement learning task due to its large number of game-state (over 12 9×9 ) and high randomness in the tran- sition. The goal of the production system is to accurately predict the user pass-rate of different game-levels, providing useful and fast feedback for game design. Powered by WU-UCT, the system runs 16× faster while accurately predicting user pass-rate (8.6% MAE). In this subsection, we con- centrate our analysis on the speedup and performance of WU-UCT using two typical game-levels (Level-35 and Level-58) 6 , and refer the readers interested in the user pass-rate prediction system to Appendix C. We evaluate WU-UCT with different numbers of expansion and simulation workers (from 1 to 16) and report the speedup results in Figures 4(a)-(b). For all experiments, we fix the total number of simulations to 500. First, note that when we have the same number of expansion workers and sim- ulation workers, WU-UCT achieves linear speedup. Furthermore,  Figures 4  also suggest that both the expansion workers and the simulation workers are crucial, since lowering the number of workers from either sets decreases the speedup. Besides the near-linear speedup property, WU-UCT suffers negligible performance loss with the increasing number of workers, as shown in Figures 4(c)-(d). The standard deviations of the performance (measured in the average game steps) over different numbers of expansion and simulation workers are only 0.67 and 1.22 for Level-35 and Level-58, respectively, which are much smaller than their average game steps (12 and 30).

Section Title: EXPERIMENTS ON THE ATARI GAME BENCHMARK
  EXPERIMENTS ON THE ATARI GAME BENCHMARK We further evaluate WU-UCT on Atari Games ( Bellemare et al., 2013 ), a classical benchmark for reinforcement learning (RL) and planning algorithms ( Guo et al., 2014 ). The Atari Games are an ideal testbed for MCTS algorithms for its long planning horizon (several thousand), sparse reward, and complex game strategy. We compare WU-UCT to three parallel MCTS algorithms discussed in Section 4: TreeP, LeafP, and RootP (additional experiment results comparing WU-UCT with a variant of TreeP is provided in Appendix E). We also report the results of sequential UCT (≈ 16× slower than WU-UCT) and PPO ( Schulman et al., 2017 ) as reference. Generally, the performance of sequential UCT sets an upper bound for parallel UCT algorithms. PPO is included since we used a distilled PPO policy network ( Hinton et al., 2015 ;  Rusu et al., 2015 ) as the roll-out policy for all other algorithms. It is considered as a performance lower bound for both parallel and sequential UCT algorithms. All experiments are performed with a total of 128 simulation steps, and all parallel algorithms use 16 workers (see Appendix D for the details). We first compare the performance, measured by average episode reward, between WU-UCT and the baselines on 15 Atari games, which is done with 16 simulation workers and 1 expansion worker (for a fair comparison, since baselines do not parallel the expansion step). Each task is repeated 10 times with the mean and standard deviation reported in  Table 1 . Due to the better exploration-exploitation tradeoff during selection, WU-UCT out-performs all other parallel algorithms in 12 out of 15 tasks. Pairwise student t-test further show that WU-UCT performs significantly better (adjusted by the Bonferroni method, p-value < 0.0011) than TreeP, LeafP, and RootP in 7, 9, and 7 tasks, respec- tively. Next, we examine the influence of the number of simulation workers on the speed and the Published as a conference paper at ICLR 2020 performance. In  Figure 5 , we compare the average episode return as well as time consumption (per step) for 4, 8, and 16 simulation workers. The bar plots indicate that WU-UCT experiences little performance loss with an increasing number of workers, while the baselines exhibit significant per- formance degradation when heavily parallelized. WU-UCT also achieves the fastest speed compared to the baselines, thanks to the efficient master-worker architecture (Section 3.2). In conclusion, our proposed WU-UCT not only out-performs baseline approaches significantly under the same number of workers but also achieves negligible performance loss with the increasing level of parallelization.

Section Title: RELATED WORK
  RELATED WORK

Section Title: MCTS
  MCTS Monte Carlo Tree Search is a planning method for optimal decision making in problems with either deterministic ( Silver et al., 2016 ) or stochastic ( Schäfer et al., 2008 ) environments. It has made a profound influence on Artificial Intelligence applications ( Browne et al., 2012 ), and has even been applied to predict and mimic human behavior (van Opheusden et al., 2016). Recently, there has been a wide range of work combining MCTS and other learning methods, providing mutual improvements to both methods. For example,  Guo et al. (2014)  harnesses the power of MCTS to boost the performance of model-free RL approaches;  Shen et al. (2018)  bridges the gap between MCTS and graph-based search, outperforming RL and knowledge base completion baselines.

Section Title: Parallel MCTS
  Parallel MCTS Many approaches have been developed to parallelize MCTS methods, with the objective being two-fold: achieve near-linear speedup under a large number of workers while main- taining the algorithm performance. Popular parallelization approaches of MCTS include leaf par- allelization, root parallelization, and tree parallelization ( Chaslot et al., 2008 ). Leaf parallelization aims at collecting better statistics by assigning multiple workers to query the same node ( Cazenave & Jouandeau, 2007 ). However, this comes at the cost of wasting diversity of the tree search. Therefore, its performance degrades significantly despite the near-ideal speedup with the help of a client-server network architecture (Kato & Takeuchi, 2010). In root parallelization, multiple search trees are built and assigned to different workers. Additional work incorporates periodical synchronization of statistics from different trees, which results in better performance in real-world tasks ( Bourki et al., 2010 ). However, a case study on Go reveals its inferiority with even a small number of workers ( Soejima et al., 2010 ). On the other hand, tree parallelization uses multiple workers to traverse, per- form queries, and update on a shared search tree. It benefits significantly from two techniques. First, a virtual loss is added to avoid querying the same node by different workers ( Chaslot et al., 2008 ). This has been adopted in various successful applications of MCTS such as Go ( Silver et al., 2016 ) and Dou-di-zhu ( Whitehouse et al., 2011 ). Additionally, architecture side improvements such as us- ing pipeline ( Mirsoleimani et al., 2018b ) or lock-free structure ( Mirsoleimani et al., 2018a ) speedup the algorithm significantly. However, though being able to increase diversity, virtual loss degrades the performance under even four workers ( Mirsoleimani et al., 2017 ;  Bourki et al., 2010 ). Finally, the idea of counting the unobserved samples to adjust the confidence interval in arm selection also appeared in  Zhong et al. (2017) . However, it mainly focuses on parallelizing the multi-armed thresh- olding bandit problem (Chen et al., 2014) instead of the tree search problem as we do.

Section Title: CONCLUSION
  CONCLUSION This paper proposes WU-UCT, a novel parallel MCTS algorithm that addresses the problem of outdated statistics during parallelization by watching the number of unobserved samples. Based on the newly devised statistics, it modifies the UCT node-selection policy in a principled manner, which achieves effective exploration-exploitation tradeoff. Together with our efficiency-oriented system implementation, WU-UCT achieves near-optimal linear speedup with only limited performance loss across a wide range of tasks, including a deployed production system and Atari games.

Section Title: ACKNOWLEDGEMENTS
  ACKNOWLEDGEMENTS
  Level-35 is relatively simple, requiring 18 steps for an average player to pass, while Level-58 is relatively difficult and needs more than 50 steps to solve.

```
