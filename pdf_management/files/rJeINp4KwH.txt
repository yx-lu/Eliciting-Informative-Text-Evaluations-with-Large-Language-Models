Title:
```
Published as a conference paper at ICLR 2020 POPULATION-GUIDED PARALLEL POLICY SEARCH FOR REINFORCEMENT LEARNING
```
Abstract:
```
In this paper, a new population-guided parallel learning scheme is proposed to en- hance the performance of off-policy reinforcement learning (RL). In the proposed scheme, multiple identical learners with their own value-functions and policies share a common experience replay buffer, and search a good policy in collabo- ration with the guidance of the best policy information. The key point is that the information of the best policy is fused in a soft manner by constructing an augmented loss function for policy update to enlarge the overall search region by the multiple learners. The guidance by the previous best policy and the enlarged range enable faster and better policy search. Monotone improvement of the ex- pected cumulative return by the proposed scheme is proved theoretically. Working algorithms are constructed by applying the proposed scheme to the twin delayed deep deterministic (TD3) policy gradient algorithm. Numerical results show that the constructed algorithm outperforms most of the current state-of-the-art RL al- gorithms, and the gain is significant in the case of sparse reward environment.
```

Figures/Tables Captions:
```
Figure 1: The overall structure of P3S
Figure 2: The conceptual search coverage in the policy space by parallel learners
Figure 3: Performance for PPO (red), ACKTR (purple), SQL (brown), (clipped double Q) SAC (orange), TD3 (green), and P3S-TD3 (proposed method, blue) on MuJoCo tasks.
Figure 4: Performance of different parallel learning methods on MuJoCo environments (up), on delayed MuJoCo environments (down)
Figure 5: Ablation study of P3S-TD3 on Delayed Ant-v1: (a) Performance and β (1 seed) with d min = 0.05, (b) Distance measures with d min = 0.05, and (c) Comparison with different d min = 0.02, 0.05
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION RL is an active research field and has been applied successfully to games, simulations, and ac- tual environments. With the success of RL in relatively easy tasks, more challenging tasks such as sparse reward environments ( Oh et al. (2018) ;  Zheng et al. (2018) ;  Burda et al. (2019) ) are emerg- ing, and developing good RL algorithms for such challenging tasks is of great importance from both theoretical and practical perspectives. In this paper, we consider parallel learning, which is an important line of RL research to enhance the learning performance by having multiple learners for the same environment. Parallelism in learning has been investigated widely in distributed RL ( Nair et al. (2015) ;  Mnih et al. (2016) ;  Horgan et al. (2018) ;  Barth-Maron et al. (2018) ;  Espeholt et al. (2018) ), evolutionary algorithms ( Salimans et al. (2017) ;  Choromanski et al. (2018) ; Khadka & Tumer (2018);  Pourchot & Sigaud (2019) ), concurrent RL ( Silver et al. (2013) ;  Guo & Brunskill (2015) ;  Dimakopoulou & Van Roy (2018) ;  Dimakopoulou et al. (2018) ) and population-based train- ing (PBT) ( Jaderberg et al. (2017 ; 2018);  Conti et al. (2018) ). In this paper, in order to enhance the learning performance, we apply parallelism to RL based on a population of policies, but the usage is different from the previous methods. One of the advantages of using a population is the capability to evaluate policies in the population. Once all policies in the population are evaluated, we can use information of the best policy to en- hance the performance. One simple way to exploit the best policy information is that we reset the policy parameter of each learner with that of the best learner at the beginning of the next M time steps; make each learner perform learning from this initial point for the next M time steps; select the best learner again at the end of the next M time steps; and repeat this procedure every M time steps in a similar way that PBT does ( Jaderberg et al. (2017) ). We will refer to this method as the resetting method in this paper. However, this resetting method has the problem that the search area covered by all N policies in the population collapses to one point at the time of parameter copying and thus the search area can be narrow around the previous best policy point. To overcome such disadvantage, instead of resetting the policy parameter with the best policy parameter periodically, Published as a conference paper at ICLR 2020 we propose using the best policy information in a soft manner. In the proposed scheme, the shared best policy information is used only to guide other learners' policies for searching a better policy. The chief periodically determines the best policy among all learners and distributes the best policy parameter to all learners so that the learners search for better policies with the guidance of the pre- vious best policy. The chief also enforces that the N policies are spread in the policy space with a given distance from the previous best policy point so that the search area by all N learners maintains a wide area and does not collapse into a narrow region. The proposed Population-guided Parallel Policy Search (P3S) learning method can be applied to any off-policy RL algorithms and implementation is easy. Furthermore, monotone improvement of the expected cumulative return by the P3S scheme is theoretically proved. We apply our P3S scheme to the TD3 algorithm, which is a state-of-the-art off-policy algorithm, as our base algorithm. Numerical result shows that the P3S-TD3 algorithm outperforms the baseline algorithms both in the speed of convergence and in the final steady-state performance.

Section Title: BACKGROUND AND RELATED WORKS
  BACKGROUND AND RELATED WORKS Distributed RL Distributed RL is an efficient way of taking advantage of parallelism to achieve fast training for large complex tasks ( Nair et al. (2015) ). Most of the works in distributed RL assume a common structure composed of multiple actors interacting with multiple copies of the same environment and a central system which stores and optimizes the common Q-function parameter or the policy parameter shared by all actors. The focus of distributed RL is to optimize the Q-function parameter or the policy parameter fast by generating more samples for the same wall clock time with multiple actors. For this goal, researchers investigated various techniques for distributed RL, e.g., asynchronous update of parameters ( Mnih et al. (2016) ;  Babaeizadeh et al. (2017) ), sharing an experience replay buffer ( Horgan et al. (2018) ), GPU-based parallel computation ( Babaeizadeh et al. (2017) ;  Clemente et al. (2017) ), GPU-based simulation ( Liang et al. (2018) ) and V-trace in case of on-policy algorithms ( Espeholt et al. (2018) ). Distributed RL yields performance improvement in terms of the wall clock time but it does not consider the possible enhancement by interaction among a population of policies of all learners like in PBT or our P3S. The proposed P3S uses a similar structure to that in ( Nair et al. (2015) ;  Espeholt et al. (2018) ): that is, P3S is composed of multiple learners and a chief. The difference is that each learner in P3S has its own Q or value function parameter and policy parameter, and optimizes the parameters in parallel to search in the policy space.

Section Title: Population-Based Training
  Population-Based Training Parallelism is also exploited in finding optimal parameters and hyper- parameters of training algorithms in PBT ( Jaderberg et al. (2017 ; 2018);  Conti et al. (2018) ). PBT trains neural networks, using a population with different parameters and hyper-parameters in paral- lel at multiple learners. During the training, in order to take advantage of the population, it evaluates the performance of networks with parameters and hyper-parameters in the population periodically. Then, PBT selects the best hyper-parameters, distributes the best hyper-parameters and the corre- sponding parameters to other learners, and continues the training of neural networks. Recently, PBT is applied to competitive multi-agent RL ( Jaderberg et al. (2018) ) and novelty search algorithms ( Conti et al. (2018) ). The proposed P3S uses a population to search a better policy by exploiting the best policy information similarly to PBT, but the way of using the best policy information is different. In P3S, the parameter of the best learner is not copied but used in a soft manner to guide the population for better search in the policy space.

Section Title: Guided Policy Search
  Guided Policy Search Our P3S method is also related to guided policy search ( Levine & Koltun (2013) ;  Levine et al. (2016) ;  Teh et al. (2017) ;  Ghosh et al. (2018) ).  Teh et al. (2017)  proposed a guided policy search method for joint training of multiple tasks in which a common policy is used to guide local policies and the common policy is distilled from the local policies. Here, the local policies' parameters are updated to maximize the performance and minimize the KL divergence between the local policies and the common distilled policy. The proposed P3S is related to guided policy search in the sense that multiple policies are guided by a common policy. However, the difference is that the goal of P3S is not learning multiple tasks but learning optimal parameter for a common task as in PBT. Hence, the guiding policy is not distilled from multiple local policies but chosen as the best performing policy among multiple learners.

Section Title: Exploiting Best Information
  Exploiting Best Information Exploiting best information has been considered in the previous works ( White & Sofge (1992) ;  Oh et al. (2018) ;  Gangwani et al. (2019) ). In particular,  Oh et al. (2018) ;  Gangwani et al. (2019)  exploited past good experiences to obtain a better policy, whereas P3S ex- ploits the current good policy among multiple policies to obtain a better policy. The overall structure of the proposed P3S scheme is described in  Fig. 1 . We have N iden- tical parallel learners with a shared common experience replay buffer D, and all N identi- cal learners employ a common base algorithm which can be any off-policy RL algorithm. The execution is in parallel. The i-th learner has its own environment E i , which is a copy of the common environment E, and has its own value function (e.g., Q-function) parameter θ i and policy parameter φ i . The i-th learner in- teracts with the environment copy E i with ad- ditional interaction with the chief, as shown in  Fig. 1 . At each time step, the i-th learner performs an action a i t to its environment copy E i by using its own policy π φ i , stores its experience (s i t , a i t , r i t , s i t+1 ) to the shared common replay buffer D for all i = 1, 2, · · · , N. Then, each learner updates its value function parameter and policy parameter once by drawing a mini-batch of size B from the shared common replay buffer D by minimizing its own value loss function and policy loss function, respectively. Due to parallel update of parameters, the policies of all learners compose a population of N different policies. In order to take advantage of this population, we exploit the policy information from the best learner periodically during the training like in PBT ( Jaderberg et al. (2017) ). Suppose that the Q-function parameter and policy parameter of each learner are initialized and learning is performed as described above for M time steps. At the end of the M time steps, we determine who is the best learner based on the average of the most recent E r episodic rewards for each learner. Let the index of the best learner be b. Then, the policy parameter information φ b of the best learner can be used to enhance the learning of other learners for the next M time steps. Instead of copying φ b to other learners like in PBT, we propose using the information φ b in a soft manner. That is, during the next M time steps, while we set the loss function L(θ i ) for the Q-function to be the same as the loss L(θ i ) of the base algorithm, we set the loss function L(φ i ) for the policy parameter φ i of the i-th learner as the following augmented version: L(φ i ) = L(φ i ) + 1 {i =b} βE s∼D D(π φ i , π φ b ) (1) where L(φ i ) is the policy loss function of the base algorithm, 1 {·} denotes the indicator function, β(> 0) is a weighting factor, D(π, π ) be some distance measure between two policies π and π .

Section Title: THEORETICAL GUARANTEE OF MONOTONE IMPROVEMENT OF EXPECTED CUMULATIVE RETURN
  THEORETICAL GUARANTEE OF MONOTONE IMPROVEMENT OF EXPECTED CUMULATIVE RETURN In this section, we analyze the performance of the proposed soft-fusion approach theoretically and show the effectiveness of the proposed soft-fusion approach. Consider the current update period and its previous update period. Let π old φ i be the policy of the i-th learner at the end of the previous update period and let π φ b be the best policy among all policies π old φ i , i = 1, · · · , N. Now, consider any learner i who is not the best in the previous update period. Let the policy of learner i in the current update period be denoted by π φ i , and let the policy loss function of the base algorithm be denoted as L(π φ i ). In order to analyze the performance, we consider L(π φ i ) in the form of L(π φ i ) = E s∼D,a∼π φ i (·|s) −Q π old φ i (s, a) . The reason behind this choice is that most of actor- critic methods update the value (or Q-)function and the policy iteratively. That is, for given π old φ i , the Q-function is first updated to approximate Q π old φ i . Then, with the approximation Q π old φ i , the policy is Published as a conference paper at ICLR 2020 updated to yield an updated policy π new φ i . This procedure is repeated iteratively. Such loss function is used in many RL algorithms such as SAC and TD3 ( Haarnoja et al. (2018) ;  Fujimoto et al. (2018) ). For the distance measure D(π, π ) between two policies π and π , we consider the KL divergence KL(π||π ) for analysis. Then, by eq. (1) the augmented loss function for non-best learner i at the current update period is expressed as Let π new φ i be a solution that minimizes the augmented loss function eq. (3). We assume the following conditions.

Section Title: Assumption 1. For all s,
  Assumption 1. For all s, Assumption 1 means that if we draw the first time step action a from π φ b and the following actions from π old φ i , then this yields better performance on average than the case that we draw all actions including the first time step action from π old φ i . This makes sense because of the definition of π φ b . Assumption 2 is about the distance relationship among the policies to ensure a certain level of spreading of the policies for the proposed soft-fusion approach. With the two assumptions above, we have the following theorem regarding the proposed soft-fusion parallel learning scheme: Theorem 1. Under Assumptions 1 and 2, the following inequality holds:

Section Title: Here, inequality (a) requires Assumption 1 only and inequality (b) requires Assumption 2.
  Here, inequality (a) requires Assumption 1 only and inequality (b) requires Assumption 2. Proof. See Appendix A. Theorem 1 states that the new solution π new φ i for the current update period with the augmented loss function yields better performance (in the expected reward sense) than the best policy π φ b of the previous update period for any non-best learner i of the previous update period. Hence, the proposed parallel learning scheme yields monotone improvement of expected cumulative return.

Section Title: IMPLEMENTATION
  IMPLEMENTATION The proposed P3S method can be applied to any off-policy base RL algorithms whether the base RL algorithms have discrete or continuous actions. For implementation, we assume that the best policy update period consists of M time steps. We determine the best learner at the end of each update period based on the average of the most recent E r episodic rewards of each learner. The key point in implementation is adaptation of β so that the improvement gap βE st+1:s∞∼π b ∞ k=t+1 γ k−t Δ(s k ) in (4) becomes non-negative and is maximized for given ρ and d. The gradient of the im- provement gap with respect to β is given byΔ := E st+1:s∞∼π b ∞ k=t+1 γ k−t Δ(s k ) , andΔ is the average (with forgetting) of Δ(s k ) by using samples from π b . Hence, ifΔ > 0, i.e., Published as a conference paper at ICLR 2020 KL π new φ i (·|s)||π φ b (·|s) > max ρ max s KL π new φ i (·|s )||π old φ i (·|s ) , d on average, then β should be increased to maximize the performance gain. Otherwise, β should be decreased. There- fore, we adopt the following adaptation rule for β which is common for all non-best learners: Here, D spread = 1 N −1 i∈I −b E s∼D D(π new φ i , π φ b ) is the estimated distance between π new φ i and π φ b , and D change = 1 N −1 i∈I −b E s∼D D(π new φ i , π old φ i ) is the estimated distance between π new φ i and π old φ i averaged over all N − 1 non-best learners, where d min and ρ are predetermined hyper- parameters. D spread and max{ρ D change , d min } are our practical implementations of the left-hand side (LHS) and the right-hand side (RHS) of eq. (A2), respectively. This adaptation method is similar to that used in PPO ( Schulman et al. (2017) ). The update (6) of β is done every M time steps and the updated β is used for the next M time steps. As time steps elapse, β is settled down so that D spread is around d search = max{ρ D change , d min } and this implements Assumption 2 with equality. Hence, the pro- posed P3S scheme searches a spread area with rough radius d search around the best policy in the policy space, as illustrated in  Fig. 2 . The search radius d search is determined proportionally to D change that represents the speed of change in each learner's policy. In the case of being stuck in local optima, the change D change can be small, making the search area narrow. Hence, we set a minimum search radius d min to encourage escaping out of local optima. We applied P3S to TD3 as the base algorithm. The constructed algorithm is named P3S-TD3. The details of TD3 is explained in Appendix G. We used the mean square difference given by 2 as the distance measure between two policies for P3S-TD3. Note that if we consider two deterministic policies as two stochastic policies with same standard deviation, the KL divergence between the two stochastic policies is the same as the mean square difference. For initial exploration P3S-TD3 uses a uniform random policy and does not update all policies over the first T initial time steps. The pseudocode of the P3S-TD3 is given in Appendix H. The implementation code for P3S-TD3 is available at https://github.com/wyjung0625/ p3s.

Section Title: EXPERIMENTS
  EXPERIMENTS

Section Title: COMPARISON TO BASELINES
  COMPARISON TO BASELINES In this section, we provide numerical results on performance comparison between the proposed P3S-TD3 algorithm and current state-of-the-art on-policy and off-policy baseline algorithms on sev- eral MuJoCo environments ( Todorov et al. (2012) ). The baseline algorithms are Proximal Policy Optimization (PPO) ( Schulman et al. (2017) ), Actor Critic using Kronecker-Factored Trust Region (ACKTR) ( Wu et al. (2017) ), Soft Q-learning (SQL) ( Haarnoja et al. (2017) ), (clipped double Q) Soft Actor-Critic (SAC) ( Haarnoja et al. (2018) ), and TD3 ( Fujimoto et al. (2018) ).

Section Title: Hyper-parameter setting
  Hyper-parameter setting All hyper-parameters we used for evaluation are the same as those in the original papers ( Schulman et al. (2017) ;  Wu et al. (2017) ;  Haarnoja et al. (2017 ; 2018);  Fujimoto et al. (2018) ). Here, we provide the hyper-parameters of the P3S-TD3 algorithm only, while details of the hyper-parameters for TD3 are provided in Appendix I. On top of the hyper-parameters for the base algorithm TD3, we used N = 4 learners for P3S-TD3. To update the best policy and β, the period M = 250 is used. The number of recent episodes E r = 10 was used to determine the best learner b. For the search range, we used the parameter ρ = 2, and tuned d min among d min = {0.02, 0.05} for all environments. Details on d min for each environment is shown in Appendix I. The time steps for initial exploration T initial is set as 250 for Hopper-v1 and Walker2d- v1 and as 2500 for HalfCheetah-v1 and Ant-v1. Evaluation method  Fig. 3  shows the learning curves over one million time steps for several MuJoCo tasks: Hopper-v1, Walker2d-v1, HalfCheetah-v1, and Ant-v1. In order to have sample-wise fair comparison among the considered algorithms, the time steps in the x-axis in  Fig. 3  for P3S-TD3 is the sum of time steps of all N users. For example, in the case that N = 4 and each learner performs 100 time steps in P3S-TD3, the corresponding x-axis value is 400 time steps. Since each learner performs parameter update once with one interaction with environment per each time step in P3S-TD3, the total number of parameter updates at the same x-axis value in  Fig. 3  is the same for all algorithms including P3S-TD3, and the total number of interactions with environment at the same x-axis value in  Fig. 3  is also the same for all algorithms including P3S-TD3. Here, the performance is obtained through the evaluation method which is similar to those in  Haarnoja et al. (2018) ;  Fujimoto et al. (2018) . Evaluation of the policies is conducted every R eval = 4000 time steps for all algorithms. At each evaluation instant, the agent (or learner) fixes its policy as the one at the evaluation instant, and interacts with the same environment separate for the evaluation purpose with the fixed policy to obtain 10 episodic rewards. The average of these 10 episodic rewards is the performance at the evaluation instant. In the case of P3S-TD3 and other parallel learning schemes, each of the N learners fixes its policy as the one at the evaluation instant, and interacts with the environment with the fixed policy to obtain 10 episodic rewards. First, the 10 episodic rewards are averaged for each learner and then the maximum of the 10-episode-average rewards of the N learners is taken as the performance at that evaluation instant. We performed this operation for five different random seeds, and the mean and variance of the learning curve are obtained from these five simulations. The policies used for evaluation are stochastic for PPO and ACKTR, and deterministic for the others.

Section Title: Performance on MuJoCo environments
  Performance on MuJoCo environments In  Fig. 3 , it is observed that all baseline algorithms is similar to that in the original papers ( Schulman et al. (2017) ;  Haarnoja et al. (2018) ;  Fujimoto et al. (2018) ). With this verification, we proceed to compare P3S-TD3 with the baseline algorithms. It is seen that the P3S-TD3 algorithm outperforms the state-of-the-art RL algorithms in terms of both the speed of convergence with respect to time steps and the final steady-state performance (except in Walker2d-v1, the initial convergence is a bit slower than TD3.) Especially, in the cases of Hopper-v1 and Ant-v1, TD3 has large variance and this implies that the performance of TD3 is quite dependent on the initialization and it is not easy for TD3 to escape out of bad local minima resulting from bad initialization in certain environments. However, it is seen that P3S-TD3 yields much smaller variance than TD3. This implies that the wide area search by P3S in the policy space helps the learners escape out of bad local optima.

Section Title: COMPARISON WITH OTHER PARALLEL LEARNING SCHEMES AND ABLATION STUDY
  COMPARISON WITH OTHER PARALLEL LEARNING SCHEMES AND ABLATION STUDY In the previous subsection, we observed that P3S enhances the performance and reduces dependence on initialization as compared to the single learner case with the same complexity. In fact, this should be accomplished by any properly-designed parallel learning scheme. Now, in order to demonstrate the true advantage of P3S, we compare P3S with other parallel learning schemes. P3S has several components to improve the performance based on parallelism: 1) sharing experiences from multiple policies, 2) using the best policy information, and 3) soft fusion of the best policy information for wide search area. We investigated the impact of each component on the performance improvement. For comparison we considered the following parallel policy search methods gradually incorporating more techniques: 1. Original Algorithm The original algorithm (TD3) with one learner 2. Distributed RL (DRL) N actors obtain samples from N environment copies. The com- mon policy and the experience replay buffer are shared by all N actors. 3. Experience-Sharing-Only (ESO) N learners interact with N environment copies and up- date their own policies using experiences drawn from the shared experience replay buffer. 4. Resetting (Re) At every M time steps, the best policy is determined and all policies are initialized as the best policy, i.e., the best learner's policy parameter is copied to all other learners. The rest of the procedure is the same as experience-sharing-only algorithm. 5. P3S At every M time steps, the best policy information is determined and this policy is used in a soft manner based on the augmented loss function. Note that the resetting method also exploits the best policy information from N learners. The main difference between P3S and the resetting method is the way the best learner's policy parameter is used. The resetting method initializes all policies with the best policy parameter every M time steps like in PBT ( Jaderberg et al. (2017) ), whereas P3S algorithm uses the best learner's policy parameter information determined every M time steps to construct an augmented loss function. For fair comparison, M and M are determined independently and optimally for P3S and Resetting, respectively, since the optimal period can be different for the two methods. We tuned M among {2000, 5000, 10000} (MuJoCo environments) and {10000, 20000, 50000} (Delayed MuJoCo envi- ronments) for Re-TD3, whereas M = 250 was used for P3S-TD3. The specific parameters used for Re-TD3 are in Appendix I. Since all N policies collapse to one point in the resetting method at the beginning of each period, we expect that a larger period is required for resetting to have sufficiently spread policies at the end of each best policy selection period. We compared the performance of the aforementioned parallel learning methods combined with TD3 on two classes of tasks; MuJoCo environments, and Delayed sparse reward MuJoCo environments.

Section Title: Performance on MuJoCo environments
  Performance on MuJoCo environments The upper part of  Fig. 4  shows the learning curves of the considered parallel learning methods combined with TD3 for the four tasks (Hopper-v1, Walkerd-v1, HalfCheetah-v1 and Ant v1). It is seen that P3S-TD3 outperforms other parallel methods: DRL- TD3, ESO-TD3 and Re-TD3 except the case that ESO-TD3 or Re-TD3 slightly outperforms P3S- TD3 in Hopper-v1 and Walker2d-v1. In the case of Hopper-v1 and Walker2d-v1, ESO-TD3 has better final (steady-state) performance than all other parallel methods. Note that ESO-TD3 obtains most diverse experiences since the N learners shares the experience replay buffer but there is no interaction among the N learners until the end of training. So, it seems that this diverse experience is beneficial to Hopper-v1 and Walker2d-v1.

Section Title: Performance on Delayed MuJoCo environments
  Performance on Delayed MuJoCo environments Sparse reward environments especially require more search to obtain a good policy. To see the performance of P3S in sparse reward environments, we performed experiments on Delayed MuJoCo environments. Delayed MuJoCo environments are reward-sparsified versions of MuJoCo environments and used in  Zheng et al. (2018) . Delayed Mu- JoCo environments give non-zero rewards periodically with frequency f reward or only at the end of episodes. That is, in a delayed MuJoCo environment, the environment accumulates rewards given by the corresponding MuJoCo environment while providing zero reward to the agent, and gives the accumulated reward to the agent. We evaluated the performance on the four delayed environments with f reward = 20: Delayed Hopper-v1, Delayed Walker2d-v1, Delayed HalfCheetah-v1 and De- layed Ant-v1. The lower part of  Fig. 4  shows the learning curves of the different parallel learning methods for the four delayed MuJoCo environments. It is seen that P3S outperforms all other considered parallel learning schemes on all environments except on delayed Hopper-v1. It seems that the enforced wide-area policy search with the soft-fusion approach in P3S is beneficial to improve performance in sparse reward environments. Benifits of P3S Delayed Ant-v1 is a case of sparse reward environment in which P3S shows signif- icant improvement as compared to other parallel schemes. As shown in Fig. 4h, the performance of TD3 drops below zero initially and converges to zero as time goes. Similar behavior is shown for other parallel methods except P3S. This is because in Delayed Ant-v1 with zero padding rewards between actual rewards, initial random actions do not generate significant positive speed to a for- ward direction, so it does not receive positive rewards but receives negative actual rewards due to the control cost. Once its performance less than 0, learners start learning doing nothing to reach zero reward (no positive reward and no negative reward due to no control cost). Learning beyond this seems difficult without any direction information for parameter update. This is the interpretation of the behavior of other algorithms in Fig. 4h. However, it seems that P3S escapes from this local optimum by following the best policy. This is evident in Fig. 5a, showing that after few time steps, β is increased to follow the best policy more. Note that at the early stage of learning, the perfor- mance difference among the learners is large as seen in the large D spread values in Fig. 5b. As time elapses, all learners continue learning, the performance improves, and the spreadness among the learners' policies shrinks. However, the spreadness among the learners' policies is kept at a certain level for wide policy search by d min , as seen in Fig. 5b. Fig. 5c shows the performance of P3S with d min = 0.05 and 0.02. It shows that a wide area policy search is beneficial as compared to a narrow area policy search. However, it may be detrimental to set too large a value for d min due to too large statistics discrepancy among samples from different learners' policies.

Section Title: CONCLUSION
  CONCLUSION In this paper, we have proposed a new population-guided parallel learning scheme, P3S, to enhance the performance of off-policy RL. In the proposed P3S scheme, multiple identical learners with their own value-functions and policies sharing a common experience replay buffer search a good policy with the guidance of the best policy information in the previous search interval. The information of the best policy parameter of the previous search interval is fused in a soft manner by constructing an augmented loss function for policy update to enlarge the overall search region by the multiple learners. The guidance by the previous best policy and the enlarged search region by P3S enables faster and better search in the policy space, and monotone improvement of expected cumulative return by P3S is theoretically proved. The P3S-TD3 algorithm constructed by applying the proposed P3S scheme to TD3 outperforms most of the current state-of-the-art RL algorithms. Furthermore, the performance gain by P3S over other parallel learning schemes is significant on harder environments especially on sparse reward environments by searching wide range in policy space.

```
