Title:
```
Under review as a conference paper at ICLR 2020 THE PROBLEM WITH DDPG: UNDERSTANDING FAIL- URES IN DETERMINISTIC ENVIRONMENTS WITH SPARSE REWARDS
```
Abstract:
```
In environments with continuous state and action spaces, state-of-the-art actor-critic reinforcement learning algorithms can solve very complex problems, yet can also fail in environments that seem trivial, but the reason for such failures is still poorly understood. In this paper, we contribute a formal explanation of these failures in the particular case of sparse reward and deterministic environments. First, using a very elementary control problem, we illustrate that the learning process can get stuck into a fixed point corresponding to a poor solution. Then, generalizing from the studied example, we provide a detailed analysis of the underlying mechanisms which results in a new understanding of one of the convergence regimes of these algorithms. The resulting perspective casts a new light on already existing solutions to the issues we have highlighted, and suggests other potential approaches.
```

Figures/Tables Captions:
```
Figure 1: The 1D-TOY environment
Figure 2: Success rate of variants of DDPG on 1D-TOY over learning steps, averaged over 10k seeds. More details on learning algorithm and success evaluation are given in Appendix E.
Figure 3: (a) Number of rewards found in mini-batches during training. After a rollout of n steps, the actor and critic are both trained on n minibatches of size 100. The red dotted line indicates an average of 6.03 rewarded transitions present in these n minibatches. (b) In red, normalized probability of finding the earliest reward at this step. In blue, for each earliest reward bin, fraction of these episodes that fail to converge to a good actor after 100k steps. Note that when the reward is found after one or two episodes, the convergence to a successful actor is certain.
Figure 4: Drift of max |Q| and max |π| in the DRIFT environment, for 10 different seeds. In the absence of reward, the critic oscillates briefly before stabilizing. However, the actor very quickly reaches a saturated state, at either ∀s, π(s) = 0.1 or −0.1.
Figure 5: Visualization of the critic in a failing run, in which the actor is stuck to ∀s, π(s) = 0.1.
Figure 6: Deadlock observed in 1D-TOY, represented as the cycle of red arrows.
Figure 7: A cyclic view of the undesirable convergence process in continuous action actor-critic algorithms, in the deterministic and sparse reward case.
Figure 8: (a) Example of a monotonous function approximator. (b) Simply changing the vertical scale of the graphs presented in Figure 5b reveals that the function approximator is not perfectly flat, and has many unwanted local extrema. Specifically, continuously moving from π(0) = 0.1 to π(0) < 0 requires crossing a significant valley in Q(0, a), while π(0) = 0.1 is a strong local maximum.
Figure 9: (a) Applying DDPG-argmax to 1D-TOY. (b) Applying SAC to 1D-TOY. In both cases, the success rate reaches 100% quickly. (c) Applying DDPG and DDPG-argmax to a sparse-reward variant of the REACHER-V2 environment. (d) Applying DDPG and DDPG-argmax to a sparse-reward variant of the HALFCHEETAH-V2 environment. Details on the changes made to REACHER-V2 and HALFCHEETAH-V2 are available in Appendix F.2.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION The Deep Deterministic Policy Gradient (DDPG) algorithm ( Lillicrap et al. (2015) ) is one of the earliest deep Reinforcement Learning (RL) algorithms designed to operate on potentially large continuous state and action spaces with a deterministic policy, and it is still one of the most widely used. However, it is often reported that DDPG suffers from instability in the form of sensitivity to hyper-parameters and propensity to converge to very poor solutions or even diverge. Various algorithms have improved stability by addressing well identified issues, such as the over-estimation bias in TD3 ( Fujimoto et al., 2018b ) but, because a fundamental understanding of the phenomena underlying these instabilities is still missing, it is unclear whether these ad hoc remedies truly address the source of the problem. Thus, better understanding why these algorithms can fail even in very simple environments is a pressing question. To investigate this question, we introduce in Section 4 a very simple one-dimensional environment with a sparse reward function where DDPG sometimes fails. Analyzing this example allows us to provide a detailed account of these failures. We then reveal the existence of a cycle of mechanisms operating in the sparse reward and deterministic case, leading to the quick convergence to a poor policy. In particular, we show that, when the reward is not discovered early enough, these mechanisms can lead to a deadlock situation where neither the actor nor the critic can evolve anymore. Critically, this deadlock persists even when the agent is subsequently trained with rewarded samples. The study of these mechanisms is backed-up with formal proofs in a simplified context where the effects of function approximation is ignored. Nevertheless, the resulting understanding helps analyzing the practical phenomena encountered when using actors and critics represented as neural networks. From this new light, we revisit in Section 5 a few existing algorithms whose components provide an alternative to the building blocks involved in the undesirable cyclic convergence process, and we suggest alternative solutions to these issues.

Section Title: RELATED WORK
  RELATED WORK Issues when combining RL with function approximation have been studied for a long time ( Baird & Klopf, 1993 ;  Boyan & Moore, 1995 ;  Tsitsiklis & Van Roy, 1997 ). In particular, it is well known that Under review as a conference paper at ICLR 2020 deep RL algorithms can diverge when they meet three conditions coined as the "deadly triad" ( Sutton & Barto, 2018 ), that is when they use (1) function approximation, (2) bootstrapping updates and (3) off-policy learning. However, these questions are mostly studied in the continuous state, discrete action case. For instance, several recent papers have studied the mechanism of this instability using DQN ( Mnih et al., 2013 ). In this context, four failure modes have been identified from a theoretical point of view by considering the effect of a linear approximation of the deep-Q updates and by identifying conditions under which the approximate updates of the critic are contraction maps for some distance over Q-functions ( Achiam et al., 2019 ). Meanwhile,  van Hasselt et al. (2018)  shows that, due to its stabilizing heuristics, DQN does not diverge much in practice when applied to the ATARI domain. In contrast to these papers, here we study a failure mode specific to continuous action actor-critic algorithms. It hinges on the fact that one cannot take the maximum over actions, and must rely on the actor as a proxy for providing the optimal action instead. Therefore, the failure mode identified in this paper cannot be reduced to any of the ones that affect DQN. Besides, the theoretical derivations provided in the appendices show that the failure mode we are investigating does not depend on function approximation errors, thus it cannot be directly related to the deadly triad. More related to our work, several papers have studied failure to gather rewarded experience from the environment due to poor exploration ( Colas et al., 2018 ;  Fortunato et al., 2017 ;  Plappert et al., 2017 ), but we go beyond this issue by studying a case where the reward is actually found but not properly exploited. Finally, like us the authors of  Fujimoto et al. (2018a)  study a failure mode which is specific to DDPG-like algorithms, but the studied failure mode is different. They show under a batch learning regime that DDPG suffers from an extrapolation error phenomenon, whereas we are in the more standard incremental learning setting and focus on a deadlock resulting from the shape of the Q-function in the sparse reward case.

Section Title: BACKGROUND: DEEP DETERMINISTIC POLICY GRADIENT
  BACKGROUND: DEEP DETERMINISTIC POLICY GRADIENT The DDPG algorithm ( Lillicrap et al., 2015 ) is a deep RL algorithm based on the Deterministic Policy Gradient theorem ( Silver et al., 2014 ). It borrows the use of a replay buffer and target networks from DQN ( Mnih et al., 2015 ). DDPG is an instance of the Actor-Critic model. It learns both an actor function π ψ (also called policy) and a critic function Q θ , represented as neural networks whose parameters are respectively noted ψ and θ. The deterministic actor takes a state s ∈ S as input and outputs an action a ∈ A. The critic maps each state-action pair (s, a) to a value in R. The reward r : S × A → R, the termination function t : S × A → {0, 1} and the discount factor γ < 1 are also specified as part of the environment. The actor and critic are updated using stochastic gradient descent on two losses L ψ and L θ . These losses are computed from mini-batches of samples (s i , a i , r i , t i , s i+1 ), where each sample corre- sponds to a transition s i → s i+1 resulting from performing action a i in state s i , with subsequent reward r i = r(s i , a i ) and termination index t i = t(s i , a i ). Two target networks π ψ and Q θ are also used in DDPG. Their parameters ψ and θ respectively track ψ and θ using exponential smoothing. They are mostly useful to stabilize function approximation when learning the critic and actor networks. Since they do not play a significant role in the phenomena studied in this paper, we ignore them in the formal proofs given in appendices. Equations (1) and (2) define L ψ and L θ : Training for the loss given in (1) yields the parameter update in (3), with α the learning rate: Under review as a conference paper at ICLR 2020 As DDPG uses a replay buffer, the mini-batch samples are acquired using a behaviour policy β which may be different from the actor π. Usually, β is defined as π plus a noise distribution, which in the case of DDPG is either a Gaussian function or the more sophisticated Ornstein-Uhlenbeck noise. Importantly for this paper, the behaviour of DDPG can be characterized as an intermediate between two extreme regimes: • When the actor is updated much faster than the critic, the policy becomes greedy with respect to this critic, resulting into a behaviour closely resembling that of the Q-LEARNING algorithm. When it is close to this regime, DDPG can be characterized as off-policy. • When the critic is updated much faster than the actor, the critic tends towards Q π (s, a). The problems studied in this paper directly come from this second regime. A more detailed characterization of these two regimes in given in Appendix A.

Section Title: A NEW FAILURE MODE
  A NEW FAILURE MODE In this section, we introduce a simplistic environment which we call 1D-TOY. It is a one-dimensional, discrete-time, continuous state and action problem, depicted in  Figure 1 . Despite its simplicity, DDPG can fail on 1D-TOY. We first show that DDPG fails to reach 100% success. We then show that if learning a policy does not succeed soon enough, the learning process can get stuck. Besides, we show that the initial actor can be significantly modified in the initial stages before finding the first reward. We explain how the combination of these phenomena can result into a deadlock situation. We generalize this explanation to any deterministic and sparse reward environment by revealing and formally studying a undesirable cyclic process which arises in such cases. Finally, we explore the consequences of getting into this cyclic process.

Section Title: EMPIRICAL STUDY
  EMPIRICAL STUDY In all experiments, we set the maximum episode length N to 50, but the observed phenomena persist with other values.

Section Title: Residual failure to converge using different noise processes
  Residual failure to converge using different noise processes We start by running DDPG on the 1D-TOY environment. This environment is trivial as one infinitesimal step to the left is enough to obtain the reward, end the episode and succeed, thus we might expect a quick 100% success. However, the first attempt using an Ornstein-Uhlenbeck (OU) noise process shows that DDPG succeeds in only 94% of cases, see Figure 2a. These failures might come from an exploration problem. Indeed, at the start of each episode the OU noise process is reset to zero and gives little noise in the first steps of the episode. In order to remove this potential source of failure, we replace the OU noise process with an exploration strategy similar to -greedy which we call "probabilistic noise". For some 0 < p < 1, with probability p, the action is randomly sampled (and the actor is ignored), and with probability 1 − p no noise is used Under review as a conference paper at ICLR 2020 0 20k 40k 60k 80k 100k Simulation steps 85 90 95 100 % of successful runs Probabilistic noise OU noise (a) Success rate of DDPG with Ornstein-Uhlenbeck (OU) and probabilistic noise. Even with probabilis- tic noise, DDPG fails on about 1% of the seeds. and the raw action is returned. In our tests, we used p = 0.1. This guarantees at least a 5% chance of success at the first step of each episode, for any policy. Nevertheless, Figure 2a shows that even with probabilistic noise, about 1% of seeds still fail to converge to a successful policy in 1D-TOY, even after 100k training steps. All the following tests are performed using probabilistic noise. We now focus on these failures. On all failing seeds, we observe that the actor has converged to a saturated policy that always goes to the right (∀s, π(s) = 0.1). However, some mini-batch samples have non-zero rewards because the agent still occasionally moves to the left, due to the probabilistic noise applied during rollouts. The expected fraction of non-zero rewards is slightly more than 0.1% 1 . Figure 3a shows the occurrence of rewards in minibatches taken from the replay buffer when training DDPG on 1D-TOY. After each rollout (episode) of n steps, the critic and actor networks are trained n times on minibatches of size 100. So for instance, a failed episode of size 50 is followed by a training on a total of 5000 samples, out of which we expect more than 5 in average are rewarded transitions. More details about the implementation are available in Appendix E. The constant presence of rewarded transitions in the minibatches suggests that the failures of DDPG on this environment are not due to insufficient exploration by the behaviour policy.

Section Title: Correlation between finding the reward early and finding the optimal policy
  Correlation between finding the reward early and finding the optimal policy We have shown that DDPG can get stuck in 1D-TOY despite finding the reward regularly. Now we show that when DDPG finds the reward early in the training session, it is also more successful in converging to the optimal policy. On the other hand, when the first reward is found late, the learning process more often gets stuck with a sub-optimal policy. From Figure 3b, the early steps appear to have a high influence on whether the training will be successful or not. For instance, if the reward is found in the first 50 steps by the actor noise (which happens in 63% of cases), then the success rate of DDPG is 100%. However, if the reward is first found after more than 50 steps, then the success rate drops to 96%. Figure 3b shows that finding the reward later results in lower success rates, down to 87% for runs in which the reward was not found in the first 1600 steps. Therefore, we claim that there exists a critical time frame for finding the reward in the very early stages of training.

Section Title: Spontaneous actor drift
  Spontaneous actor drift At the beginning of each training session, the actor and critic of DDPG are initialized to represent respectively close-to-zero state-action values and close-to-zero actions. Besides, as long as the agent does not find a reward, it does not benefit from any utility gradient. Thus we might expect that the actor and critic remain constant until the first reward is found. Actually, we 1 10% of steps are governed by probabilistic noise, of which at least 2% are the first episode step, of which 50% are steps going to the left and leading to the reward. show that even in the absence of reward, training the actor and critic triggers non-negligible updates that cause the actor to reach a saturated state very quickly. To investigate this, we use a variant of 1D-TOY called DRIFT where the only difference is that no rewarded or terminal transitions are present in the environment. We also use a stripped-down version of DDPG, removing rollouts and using random sampling of states and actions as minibatches for training. Figure 4b shows that even in the absence of reward, the actor function drifts rapidly (notice the horizontal scale in steps) to a saturated policy, in a number of steps comparable to the "critical time frame" identified above. The critic also has a transitive phase before stabilizing. In Figure 4a, the fact that max s,a |Q(s, a)| can increase in the absence of reward can seem counter- intuitive, since in the loss function presented in Equation (2), |y i | can never be greater than max s,a |Q(s, a)|. However, it should be noted that the changes made to Q are not local to the minibatch points, and increasing the value of Q for one input (s, a) may cause its value to increase for other inputs too, which may cause an increase in the global maximum of Q. This phenomenon is at the heart of the over-estimation bias when learning a critic ( Fujimoto et al., 2018b ), but this bias does not play a key role here.

Section Title: EXPLAINING THE DEADLOCK SITUATION FOR DDPG ON 1D-TOY
  EXPLAINING THE DEADLOCK SITUATION FOR DDPG ON 1D-TOY Up to now, we have shown that DDPG fails about 1% of times on 1D-TOY, despite the simplicity of this environment. We have now collected the necessary elements to explain the mechanisms of this deadlock in 1D-TOY.  Figure 5  shows the value of the critic in a failed run of DDPG on 1D-TOY. We see that the value of the reward is not propagated correctly outside of the region in which the reward is found in a single step {(s, a) | s + a < 0}. The key of the deadlock is that once the actor has drifted to ∀s, π(s) = 0.1, it is updated according to ∇ a Q θ (s, a)| a=π ψ (s) (Equation (3)). Figure 5b shows that for a = π(s) = 0.1, this gradient is zero therefore the actor is not updated. Besides, the critic is updated using y i = r(s i , a i ) + γQ(s i , π(s i )) as a target. Since Q(s i , 0.1) is zero, the critic only needs to be non-zero for directly rewarded actions, and for all other samples the target value remains zero. In this state the critic loss given in Equation (2) is minimal, so there is no further update of the critic and no further propagation of the state-action values. The combination of the above two facts clearly results in a deadlock. Importantly, the constitutive elements of this deadlock do not depend on the batches used to perform the update, and therefore do not depend on the experience selection method. We tested this experi- mentally by substituting the behaviour policy for the optimal policy after 20k training steps. Results are presented in Figure 2b and show that, once stuck, even when it is given ideal samples, DDPG stays stuck in the deadlock configuration. This also explains why finding the reward early results in better performance. When the reward is found early enough, π(s 0 ) has not drifted too far, and the gradient of Q(s 0 , a) at a = π(s 0 ) drives the actor back into the correct direction. Note however that even when the actor drifts to the right, DDPG does not always fail. Indeed, because of function approximators the shape of the critic when finding the reward for the first time varies, and sometimes converges slowly enough for the actor to be updated before the convergence of the critic.  Figure 6  summarizes the above process. The entry point is represented using a green dot. First, the actor drifts to ∀s, π(s) = 0.1, then the critic converges to Q π which is a piecewise-constant function (Experiment in  Figure 5 , proof in Theorem 1 in Appendix B), which in turn means that the critic provides no gradient, therefore the actor is not updated (as seen in Equation 3, more details in Theorem 2) 2 . at least DDPG and TD3, and acting in any deterministic and sparse reward environment. The generalized deadlock mechanism is illustrated in  Figure 7  and explained hereafter in the idealized context of perfect approximators, with formal proofs rejected in appendices.

Section Title: Entry point
  Entry point As shown in the previous section, before the behaviour policy finds any reward, training the actor and critic can still trigger non-negligible updates that may cause the actor to quickly reach a poor state and stabilize. This defines our entry point in the process. Q tends towards Q π : A first step into the cycle is that, if the critic is updated faster than the policy, the update rule of the critic Q given in Equation (2) makes Q converge to Q π . This is presented in detail in Appendix C. Q π is piecewise-constant: In Appendix D, we then show that, in a deterministic environment with sparse terminal rewards, Q π is piecewise-constant because V π (s ) only depends on two things: the (integer) number of steps required to reach a rewarded state from s , and the value of this reward state, which is itself piecewise-constant. Note that we can reach the same conclusion with non-terminal rewards, by making the stronger hypothesis on the actor that ∀s, r(s, π(s)) = 0. Notably, this is the case for the actor ∀s, π(s) = 0.1 on 1D-TOY. Q is approximately piecewise-constant and ∇ a Q(s, a)| a=π(s) ≈ 0: Quite obviously, from Q π is piecewise-constant and Q tends towards Q π , we can infer that Q progressively becomes almost piecewise-constant as the cyclic process unfolds. Actually, the Q function is estimated by a function approximator which is never truly discontinuous. The impact of this fact is studied in Section 4.5. However, we can expect Q to have mostly flat gradients since it is trained to match a piecewise- constant function. We can thus infer that, globally, ∇ a Q(s, a)| a=π(s) ≈ 0. And critically, the gradients in the flat regions far from the discontinuities give little information as to how to reach regions of higher values. π barely changes: DDPG uses the deterministic policy gradient update, as seen in Equation (3). This is an analytical gradient that does not incorporate any stochasticity, because Q is always differentiated exactly at (s, π(s)). Thus the actor update is stalled, even when the reward is regularly found by the behaviour policy. This closes the loop of our process.

Section Title: CONSEQUENCES OF THE CONVERGENCE CYCLE
  CONSEQUENCES OF THE CONVERGENCE CYCLE As illustrated with the red arrows in  Figure 7 , the more loops performed in the convergence process, the more the critic tends to be piecewise-constant and the less the actor tends to change. Importantly, this cyclic convergence process is triggered as soon as the changes on the policy drastically slow down or stop. What matters for the final performance is the quality of the policy reached before Under review as a conference paper at ICLR 2020 Q π Q (a) (b) this convergence loop is triggered. Quite obviously, if the loop is triggered before the policy gets consistently rewarded, the final performance is deemed to be poor. The key of this undesirable convergence cycle lies in the use of the deterministic policy gradient update given in Equation (3). Actually, rewarded samples found by the exploratory behaviour policy β tend to be ignored by the conjunction of two reasons. First, the critic is updated using Q(s , π(s )) and not Q(s, β(s)), thus if π differs too much from β, the values brought by β are not properly propagated. Second, the actor being updated through (3), i.e. using the analytical gradient of the critic with respect to the actions of π, there is no room for considering other actions than that of π. Besides, the actor update involves only the state s of the sample taken from the replay buffer, and not the reward found from this sample r(s, a) or the action performed. For each sample state s, the actor update is intended to make π(s) converge to argmax a π(s, a) but the experience of different actions performed for identical or similar states is only available through Q(s, ·), and in DDPG it is only exploited through the gradient of Q(s, ·) at π(s), so the process can easily get stuck in a local optimum, especially if the critic tends towards a piecewise-constant function, which as we have shown happens when the reward is sparse. Besides, since TD3 also updates the actor according to (3) and the critic according to (2), it is susceptible to the same failures as DDPG.

Section Title: IMPACT OF FUNCTION APPROXIMATION
  IMPACT OF FUNCTION APPROXIMATION We have just explained that when the actor has drifted to an incorrect policy before finding the reward, an undesirable convergence process should result in DDPG getting stuck to this policy. However, in 1D-TOY, we measured that the actor drifts to a policy moving to the right in 50% of cases, but the learning process only fails 1% of times. More generally, despite the issues discussed in this paper, DDPG has been shown to be efficient in many problems. This better-than-predicted success can be attributed to the impact of function approximation. Figure 8a shows a case in which the critic approximates Q π while keeping a monotonous slope between the current policy value and the reward. In this case, the actor is correctly updated towards the reward (if it is close enough to the discontinuity). This is the most often observed case, and naturally we expect approximators to smooth out discontinuities in target functions in a monotonous way, which facilitates gradient ascent. However, the critic is updated not only in state-action pairs where Q π (s, a) is positive, but also at points where Q π (s, a) = 0, which means that the bottom part of the curve also tends to flatten. As this happens, we can imagine phenomena that are common when trying to approximate discontinuous functions, such as the overshoot observed in Figure 8b. In this case, the gradient prevents the actor from improving.

Section Title: POTENTIAL SOLUTIONS
  POTENTIAL SOLUTIONS In the previous section, we have shown that actor-critic algorithms such as DDPG and TD3 could not recover from early convergence to a poor policy due to the combination of three factors whose Under review as a conference paper at ICLR dependence is highlighted in  Figure 7 : the use of the deterministic policy gradient update, the use of Q(s , π(s )) in the critic update, and the attempt to address sparse reward in deterministic environments. In this section, we categorize existing or potential solutions to the above issue in terms of which of the above factor they remove.

Section Title: Avoiding sparse rewards
  Avoiding sparse rewards Transforming a sparse reward problem into a dense one can solve the above issue as the critic should not converge to a piecewise-constant function anymore. This can be achieved for instance by using various forms of shaping ( Konidaris & Barto, 2006 ) or by adding auxiliary tasks ( Jaderberg et al., 2016 ;  Riedmiller et al., 2018 ). We do not further investigate these solutions here, as they are mainly problem-dependent and may introduce bias when the reward transformation results in deceptive gradient or modifies the corresponding optimal policy.

Section Title: Replacing the policy-based critic update
  Replacing the policy-based critic update As explained above, if some transition (s, a, s ) leading to a reward is found in the replay buffer, the critic update corresponding to this transition uses Q(s , π(s )), therefore not propagating the next state value that the behaviour policy may have found. Of course, when using the gradient from the critic, the actor update should tend to update π to reflect the better policy such that π(s ) → a , but the critic does not always provide an adequate gradient as shown before. If performing a maximum over a continuous action space was possible, using max a Q(s , a) instead of Q(s , π(s )) would solve the issue. Several works start from this insight. Some methods directly sample the action space and look for such an approximate maximum ( Kalashnikov et al., 2018 ;  Simmons-Edler et al., 2019 ). To show that this approach can fix the above issue, we applied it to the 1D-TOY environment. We take a straightforward implementation where the policy gradient update in DDPG is replaced by sampling 100 different actions, finding the argmax over these actions of Q(s, a), and regressing the actor towards the best action we found. We call the resulting algorithm DDPG-argmax, and more details are available in Appendix F.1. Results are shown in Figure 9a, in which we see that the success rate quickly reaches 100%. Quite obviously, even if sampling can provide a good enough baseline for simple enough benchmarks, these methods do not scale well to large actions spaces. Many improvements to this can be imagined by changing the way the action space is sampled, such as including π(s) in the samples, to prevent picking a worse action than the one provided by the actor, sampling preferentially around π(s), or around π(s + ), or just using actions taken from the replay buffer. Interestingly, using a stochastic actor such as in the Soft Actor Critic (SAC) algorithm ( Haarnoja et al., 2018a ;b) can be considered as sampling preferentially around π(s + ) where is driven by the entropy regularization term. In Figure 9b, we show that SAC also immediately solves 1D-TOY. Another approach relies on representing the critic as the V function rather than the Q function. The same way π(s) tends to approximate argmax a Q(s, a), V tends to approximate max a Q(s, a), and is updated when finding a transition that raises the value of a state. Using V , performing a maximum in the critic update is not necessary anymore. The prototypical actor-critic algorithm using a model of V as a critic is CACLA ( Van Hasselt & Wiering, 2007 ). However, approximating V with neural Under review as a conference paper at ICLR 2020 networks can prove more unstable than approximating Q, as function approximation can be sensitive to the discontinuities resulting form the implicit maximization over Q values.

Section Title: Replacing the deterministic policy gradient update
  Replacing the deterministic policy gradient update Instead of relying on the deterministic policy gradient update, one can rely on a stochastic policy to perform a different actor update. This is the case of SAC, as mentioned just above. Because SAC does not use Q(s , π(s )) in its update rule, it does not suffer from the undesirable convergence process described here. Another solution consists in completely replacing the actor update mechanism, using regression to update π(s) towards any action better than the current one. This could be achieved by updating the actor and the critic simultaneously: when sampling a higher-than-expected critic value y i > Q(s i , a i ), one may update π(s i ) towards a i using: This is similar to the behaviour of CACLA, as analyzed in  Zimmer & Weng (2019) .

Section Title: Larger benchmarks
  Larger benchmarks Whether the deadlock situation investigated so far occurs more in more complex environments is an important question. To investigate this, we performed additional experiments based on more complex environments, namely sparse versions of REACHER-V2 and HALFCHEETAH-V2. Results are depicted in Figure 9c and 9d and more details are presented in Appendix F.2. One can see that DDPG-argmax outperforms DDPG, which seems to indicate that the failure mode we are studying is also at play. However, with higher-dimensional and more complex environments, the analysis becomes more difficult and other failures modes such as the ones related to the deadly triad, the extrapolation error or the over-estimation bias might come into play, so it becomes harder to quantitatively analyze the impact of the phenomenon we are focusing on. On one hand, this point showcases the importance of using very elementary benchmarks in order to study the different failure modes in isolation. On the other hand, trying to sort out and quantify the impact of the different failure modes in more complex environments is our main objective for future work.

Section Title: CONCLUSION AND FUTURE WORK
  CONCLUSION AND FUTURE WORK In RL, continuous action and sparse reward environments are challenging. In these environments, the fact that a good policy cannot be learned if exploration is not efficient enough to find the reward is well-known and trivial. In this paper, we have established the less trivial fact that, if exploration does find the reward consistently but not early enough, an actor-critic algorithm can get stuck into a configuration from which rewarded samples are just ignored. We have formally characterized the reasons for this situation and we have outlined existing and potential solutions. Beyond this, we believe our work sheds new light on the convergence regime of actor-critic algorithms. Our study was mainly built on a simplistic benchmark which made it possible to study the revealed deadlock situation in isolation from other potential failure modes such as exploration issues, the over-estimation bias, extrapolation error or the deadly triad. The impact of this deadlock situation in more complex environments is a pressing question. For this, we need to sort out and quantify the impact of these different failure modes. Using new tools such as the ones provided in  Ahmed et al. (2019) , recent analyses of the deadly triad such as  Achiam et al. (2019)  as well as simple, easily visualized benchmarks and our own tools, for future work we aim to conduct deeper and more exhaustive analysis of all the instability factors of DDPG-like algorithms, with the hope to contribute in fixing them.

Section Title: ACKNOWLEDGEMENTS
  ACKNOWLEDGEMENTS
    Figure 5  shows a critic state which is slightly different from the one presented in  Figure 6 , due to the limitations of function approximators.

```
