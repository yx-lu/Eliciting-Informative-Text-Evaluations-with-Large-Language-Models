Title:
```
Under review as a conference paper at ICLR 2020 LEARNING TO DISCRETIZE: SOLVING 1D SCALAR CONSERVATION LAWS VIA DEEP REINFORCEMENT LEARNING
```
Abstract:
```
Conservation laws are considered to be fundamental laws of nature. It has broad application in many fields including physics, chemistry, biology, geology, and engineering. Solving the differential equations associated with conservation laws is a major branch in computational mathematics. Recent success of machine learning, especially deep learning, in areas such as computer vision and natural language processing, has attracted a lot of attention from the community of computational mathematics and inspired many intriguing works in combining machine learning with traditional methods. In this paper, we are the first to view numerical PDE solvers as a MDP and to use (deep) RL to learn new solvers. As a proof of concept, we focus on 1-dimensional scalar conservation laws. We deploy the machinery of deep reinforcement learning to train a policy network that can decide on how the numerical solutions should be approximated in a sequential and spatial-temporal adaptive manner. We will show that the problem of solving conservation laws can be naturally viewed as a sequential decision making process and the numerical schemes learned in such a way can easily enforce long-term accuracy. Furthermore, the learned policy network is carefully designed to determine a good local discrete approximation based on the current state of the solution, which essentially makes the proposed method a meta-learning approach. In other words, the proposed method is capable of learning how to discretize for a given situation mimicking human experts. Finally, we will provide details on how the policy network is trained, how well it performs compared with some state-of-the-art numerical solvers such as WENO schemes, and how well it generalizes. Our code is released anomynously at https://github.com/qwerlanksdf/L2D.
```

Figures/Tables Captions:
```
Figure 1: First row: solutions of RL-WENO (red), WENO (blue) and exact solutions (green). Second row: zoom-in views corresponding to the first row.
Figure 2: This figure compares the weights generated by the learned numerical flux policy π RL and those of WENO. The weights shown in (a) are {w r j− 1 2 } 1 r=−2 ; while those in (b) are {w r j+ 1 2 } 1 r=−2 . In each of the two plots, the 4 numbers in the upper bracket of each location are the weights of RL- WENO and those in the lower bracket are the weights of WENO. The relative errors of RL-WENO and WENO are 8.0 × 10 −3 and 2.5 × 10 −2 respectively.
Table 1: Comparison of relative errors (×10 −2 ) of RL-WENO and WENO with standard deviations of the errors among 10 trials in the parenthesis. Temporal discretization: RK4; flux function: 1 2 u 2 .
Table 2: Comparison of relative errors (×10 −2 ) of RL-WENO and WENO with standard deviations of the errors among 10 trials in the parenthesis. Temporal discretization: RK4; flux function: 1 16 u 4 .
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Conservation laws are considered to be one of the fundamental laws of nature, and has broad applications in multiple fields such as physics, chemistry, biology, geology, and engineering. For example, Burger's equation, a very classic partial differential equation (PDE) in conservation laws, has important applications in fluid mechanics, nonlinear acoustics, gas dynamics, and traffic flow. Solving the differential equations associated with conservation laws has been a major branch of computational mathematics (LeVeque, 1992;  2002 ), and a lot of effective methods have been proposed, from classic methods such as the upwind scheme, the Lax-Friedrichs scheme, to the advanced ones such as the ENO/WENO schemes ( Liu et al., 1994 ;  Shu, 1998 ), the flux-limiter methods ( Jerez Galiano & Uh Zapata, 2010 ), and etc. In the past few decades, these traditional methods have been proven successful in solving conservation laws. Nonetheless, the design of some of the high-end methods heavily relies on expert knowledge and the coding of these methods can be a laborious process. To ease the usage and potentially improve these traditional algorithms, machine learning, especially deep learning, has been recently incorporated into this field. For example, the ENO scheme requires lots of 'if/else' logical judgments when used to solve complicated system of equations or high-dimensional equations. This very much resembles the old-fashioned expert systems. The recent trend in artificial intelligence (AI) is to replace the expert systems by the so-called 'connectionism', e.g., deep neural networks, which leads to the recent bloom of AI. Therefore, it Under review as a conference paper at ICLR 2020 is natural and potentially beneficial to introduce deep learning in traditional numerical solvers of conservation laws.

Section Title: RELATED WORKS
  RELATED WORKS In the last few years, neural networks (NNs) have been applied to solving ODEs/PDEs or the associated inverse problems. These works can be roughly classified into three categories according to the way that the NN is used. The first type of works propose to harness the representation power of NNs, and are irrelevant to the numerical discretization based methods. For example,  Raissi et al. (2017a;b) ;  Yohai Bar-Sinai (2018)  treated the NNs as new ansatz to approximate solutions of PDEs. It was later generalized by  Wei et al. (2019)  to allow randomness in the solution which is trained using policy gradient. More recent works along this line include ( Magiera et al., 2019 ;  Michoski et al., 2019 ;  Both et al., 2019 ). Besides, several works have focused on using NNs to establish direct mappings between the parameters of the PDEs (e.g. the coefficient field or the ground state energy) and their associated solutions ( Khoo et al., 2017 ;  Khoo & Ying, 2018 ;  Li et al., 2019 ;  Fan et al., 2018b ). Furthermore,  Han et al. (2018) ;  Beck et al. (2017)  proposed a method to solve very high-dimensional PDEs by converting the PDE to a stochastic control problem and use NNs to approximate the gradient of the solution. The second type of works focus on the connection between deep neural networks (DNNs) and dynamic systems (Weinan, 2017;  Chang et al., 2017 ;  Lu et al., 2018 ;  Long et al., 2018b ;  Chen et al., 2018 ). These works observed that there are connections between DNNs and dynamic systems (e.g. differential equations or unrolled optimization algorithms) so that we can combine deep learning with traditional tools from applied and computational mathematics to handle challenging tasks in inverse problems ( Long et al., 2018b ;a;  Qin et al., 2018 ).The main focus of these works, however, is to solve inverse problems, instead of learning numerical discretizations of differential equations. Nonetheless, these methods are closely related to numerical differential equations since learning a proper discretization is often an important auxiliary task for these methods to accurately recover the form of the differential equations. The third type of works, which target at using NNs to learn new numerical schemes, are closely related to our work. However, we note that these works mainly fall in the setting of supervised learning (SL). For example,  Discacciati et al. (2019)  proposed to integrate NNs into high-order numerical solvers to predict artificial viscosity;  Ray & Hesthaven (2018)  trained a multilayer perceptron to replace traditional indicators for identifying troubled-cells in high-resolution schemes for conservation laws. These works greatly advanced the development in machine learning based design of numerical schemes for conservation laws. Note that in  Discacciati et al. (2019) , the authors only utilized the one-step error to train the artificial viscosity networks without taking into account the long- term accuracy of the learned numerical scheme.  Ray & Hesthaven (2018)  first constructed several functions with known regularities and then used them to train a neural network to predict the location of discontinuity, which was later used to choose a proper slope limiter. Therefore, the training of the NNs is separated from the numerical scheme. Then, a natural question is whether we can learn discretization of differential equations in an end-to-end fashion and the learned discrete scheme also takes long-term accuracy into account. This motivates us to employ reinforcement learning to learn good solvers for conservation laws.

Section Title: OUR APPROACH
  OUR APPROACH The main objective of this paper is to design new numerical schemes in an autonomous way. We propose to use reinforcement learning (RL) to aid the process of solving the conservation laws. To our best knowledge, we are the first to regard numerical PDE solvers as a MDP and to use (deep) RL to learn new solvers. We carefully design the proposed RL-based method so that the learned policy can generate high accuracy numerical schemes and can well generalize in varied situations. Details will be given in section 3. Here, we first provide a brief discussion on the benefits of using RL to solve conservation laws (the arguments apply to general evolution PDEs as well): • Most of the numerical solvers of conservation law can be interpreted naturally as a sequential decision making process (e.g., the approximated grid values at the current time instance definitely Under review as a conference paper at ICLR 2020 affects all the future approximations). Thus, it can be easily formulated as a Markov Decision Process (MDP) and solved by RL. • In almost all the RL algorithms, the policy π (which is the AI agent who decides on how the solution should be approximated locally) is optimized with regards to the values Q π (s 0 , a 0 ) = r(s 0 , a 0 ) + ∞ t=1 γ t r(s t , a t ), which by definition considers the long-term accumulated reward (or, error of the learned numerical scheme), thus could naturally guarantee the long-term accuracy of the learned schemes, instead of greedily deciding the local approximation which is the case for most numerical PDEs solvers. Furthermore, it can gracefully handle the cases when the action space is discrete, which is in fact one of the major strength of RL. • By optimizing towards long-term accuracy and effective exploration, we believe that RL has a good potential in improving traditional numerical schemes, especially in parts where no clear design principles exist. For example, although the WENO-5 scheme achieves optimal order of accuracy at smooth regions of the solution ( Shu, 1998 ), the best way of choosing templates near singularities remains unknown. Our belief that RL could shed lights on such parts is later verified in the experiments: the trained RL policy demonstrated new behaviours and is able to select better templates than WENO and hence approximate the solution better than WENO near singularities. • Non-smooth norms such as the infinity norm of the error is often used to evaluate the performance of the learned numerical schemes. As the norm of the error serves as the loss function for the learning algorithms, computing the gradient of the infinity norm can be problematic for supervised learning, while RL does not have such problem since it does not explicitly take gradients of the loss function (i.e. the reward function for RL). • Learning the policy π within the RL framework makes the algorithm meta-learning-like ( Schmid- huber, 1987 ;  Bengio et al., 1992 ;  Andrychowicz et al., 2016 ;  Li & Malik, 2016 ;  Finn et al., 2017 ). The learned policy π can decide on which local numerical approximation to use by judging from the current state of the solution (e.g. local smoothness, oscillatory patterns, dissipation, etc). This is vastly different from regular (non-meta-) learning where the algorithms directly make inference on the numerical schemes without the aid of an additional network such as π. As subtle the difference as it may seem, meta-learning-like methods have been proven effective in various applications such as in image restoration ( Jin et al., 2017 ;  Fan et al., 2018a ;  Zhang et al., 2019 ). See ( Vanschoren, 2018 ) for a comprehensive survey on meta-learning. • Another purpose of this paper is to raise an awareness of the connection between MDP and numerical PDE solvers, and the general idea of how to use RL to improve PDE solvers or even finding brand new ones. Furthermore, in computational mathematics, a lot of numerical algorithms are sequential, and the computation at each step is expert-designed and usually greedy, e.g., the conjugate gradient method, the fast sweeping method ( Zhao, 2005 ), matching pursuit ( Mallat & Zhang, 1993 ), etc. We hope our work could motivate more researches in combining RL and computational mathematics, and stimulate more exploration on using RL as a tool to tackle the bottleneck problems in computational mathematics. Our paper is organized as follows. In section 2 we briefly review 1-dimensional conservation laws and the WENO schemes. In section 3, we discuss how to formulate the process of numerically solving conservation laws into a Markov Decision Process. Then, we present details on how to train a policy network to mimic human expert in choosing discrete schemes in a spatial-temporary adaptive manner by learning upon WENO. In section 4, we conduct numerical experiments on 1-D conservation laws to demonstrate the performance of our trained policy network. Our experimental results show that the trained policy network indeed learned to adaptively choose good discrete schemes that offer better results than the state-of-the-art WENO scheme which is 5th order accurate in space and 4th order accurate in time. This serves as an evidence that the proposed RL framework has the potential to design high-performance numerical schemes for conservation laws in a data-driven fashion. Furthermore, the learned policy network generalizes well to other situations such as different initial conditions, mesh sizes, temporal discrete schemes, etc. The paper ends with a conclusion in section 5, where possible future research directions are also discussed.

Section Title: PRELIMINARIES
  PRELIMINARIES

Section Title: NOTATIONS
  NOTATIONS In this paper, we consider solving the following 1-D conservation laws: For example, f = u 2 2 is the famous Burger's Equation. We discretize the (x, t)-plane by choosing a mesh with spatial size ∆x and temporal step size ∆t, and define the discrete mesh points (x j , t n ) by We denote x j+ 1 2 = x j + ∆x/2 = a + (j + 1 2 )∆x. The finite difference methods will produce approximations U n j to the solution u(x j , t n ) on the given discrete mesh points. We denote point- wise values of the true solution to be u n j = u(x j , t n ), and the true point-wise flux values to be f n j = f (u(x j , t n )).

Section Title: WENO - WEIGHTED ESSENTIALLY NON-OSCILLATORY SCHEMES
  WENO - WEIGHTED ESSENTIALLY NON-OSCILLATORY SCHEMES WENO (Weighted Essentially Non-Oscillatory) ( Liu et al., 1994 ) is a family of high order accurate finite difference schemes for solving hyperbolic conservation laws, and has been successful for many practical problems. The key idea of WENO is a nonlinear adaptive procedure that automatically chooses the smoothest local stencil to reconstruct the numerical flux. Generally, a finite difference method solves Eq.1 by using a conservative approximation to the spatial derivative of the flux: du j (t) dt = − 1 ∆x f j+ 1 2 −f j− 1 2 , (2) where u j (t) is the numerical approximation to the point value u(x j , t) andf j+ 1 2 is the numerical flux generated by a numerical flux policŷ f j+ 1 2 = π f (u j−r , ..., u j+s ), which is manually designed. Note that the term "numerical flux policy" is a new terminology that we introduce in this paper, which is exactly the policy we shall learn using RL. In WENO, π f works as follows. Using the physical flux values {f j−2 , f j−1 , f j }, we could obtain a 3 th order accurate polynomial interpolationf −2 j+ 1 2 , where the indices {j − 2, j − 1, j} is called a 'stencil'. We could also use the stencil {j−1, j, j+1}, {j, j+1, j+2} or {j+1, j+2, j+3} to obtain another three interpolantŝ f −1 j+ 1 2 ,f 0 j+ 1 2 andf 1 j+ 1 2 . The key idea of WENO is to average (with properly designed weights) all these interpolants to obtain the final reconstruction: The weight w i depends on the smoothness of the stencil. A general principal is: the smoother is the stencil, the more accurate is the interpolant and hence the larger is the weight. To ensure convergence, we need the numerical scheme to be consistent and stable (LeVeque, 1992). It is known that WENO schemes as described above are consistent. For stability, upwinding is required in constructing the flux. The most easy way is to use the sign of the Roe speedā j+ 1 2 = (f j+ 1 2 − f j− 1 2 )/(u j+ 1 2 − u j− 1 2 ) to determine the upwind direction: ifā j+ 1 2 ≥ 0, we only average among the three interpolantsf −2 Some further thoughts. WENO achieves optimal order of accuracy (up to 5) at the smooth region of the solutions ( Shu, 1998 ), while lower order of accuracy at singularities. The key of the WENO method lies in how to compute the weight vector (w 1 , w 2 , w 3 , w 4 ), which primarily depends on the smoothness of the solution at local stencils. In WENO, such smoothness is characterized by handcrafted formula, and was proven to be successful in many practical problems when coupled with high-order temporal discretization. However, it remains unknown whether there are better ways to combine the stencils so that optimal order of accuracy in smooth regions can be reserved while, at the Under review as a conference paper at ICLR 2020 same time, higher accuracy can be achieved near singularities. Furthermore, estimating the upwind directions is another key component of WENO, which can get quite complicated in high-dimensional situations and requires lots of logical judgments (i.e. "if/else"). Can we ease the (some time painful) coding and improve the estimation at the aid of machine learning?

Section Title: METHODS
  METHODS In this section we present how to employ reinforcement learning to solve the conservation laws given by Eq.1. To better illustrate our idea, we first show in general how to formulate the process of numerically solving a conservation law into an MDP. We then discuss how to incorporate a policy network with the WENO scheme. Our policy network targets at the following two key aspects of WENO: (1) Can we learn to choose better weights to combine the constructed fluxes? (2) Can we learn to automatically judge the upwind direction, without complicated logical judgments? As shown in Algorithm 1, the procedure of numerically solving a conservation law is naturally a sequential decision making problem. The key of the procedure is the numerical flux policy π f and the temporal scheme π t as shown in line 6 and 8 in Algorithm 1. Both policies could be learned using RL. However, in this paper, we mainly focus on using RL to learn the numerical flux policy π f , while leaving the temporal scheme π t with traditional numerical schemes such as the Euler scheme or the Runge-Kutta methods. A quick review of RL is given in the appendix. Now, we show how to formulate the above procedure as an MDP and the construction of the state S, action A, reward r and transition dynamics P . Algorithm 2 shows in general how RL is incorporated into the procedure. In Algorithm 2, we use a single RL agent. Specifically, when computing U n j : • The state for the RL agent is s n j = g s (U n−1 j−r−1 , ..., U n−1 j+s ), where g s is the state function. • In general, the action of the agent is used to determine how the numerical fluxesf n j+ 1 2 andf n j− 1 2 is computed. In the next subsection, we detail how we incorporate a n j to be the linear weights of the fluxes computed using different stencils in the WENO scheme. • The reward should encourage the agent to generate a scheme that minimizes the error between its approximated value and the true value. Therefore, we define the reward function as r n However, it is impractical to train J different agents as J is usually very large, therefore we enforce the agents at different mesh point j to share the same weight, which reduces to case of using just a single agent. The single agent can be viewed as a counterpart of a human designer who decides on the choice of a local scheme based on the current state in traditional numerical methods.

Section Title: Algorithm 2: General RL Running Procedure
  Algorithm 2: General RL Running Procedure We now present how to transfer the actions of the RL policy to the weights of WENO fluxes. Instead of directly using π RL to generate the numerical flux, we use it to produce the weights of numerical fluxes computed using different stencils in WENO. Since the weights are part of the configurations of the WENO scheme, our design of action essentially makes the RL policy a meta-learner, and enables more stable learning and better generalization power than directly generating the fluxes. Specifically, at point x j (here we drop the time superscript n for simplicity), to compute the numerical fluxf j− 1 2 andf j+ 1 2 , we first construct four fluxes {f i j− 1 2 } 1 i=−2 and {f i j+ 1 2 } 1 i=−2 using four different stencils just as in WENO, and then use the RL policy π RL to generate the weights of these fluxes: The numerical flux is then constructed by averaging these fluxes: Note that the determination of upwind direction is automatically embedded in the RL policy since it generates four weights at once. For instance, when the roe speedā j+ 1 2 ≥ 0, we expect the 4 th weight w 1 j+ 1 2 ≈ 0 and whenā j+ 1 2 < 0, we expect w −2 j+ 1 2 ≈ 0. Note that the upwind direction can be very complicated in a system of equations or in the high-dimensional situations, and using the policy network to automatically embed such a process could save lots of efforts in algorithm design and implementation. Our numerical experiments show that π RL can indeed automatically determine upwind directions for 1D scalar cases. Although this does not mean that it works for systems and/or in high-dimensions, it shows the potential of the proposed framework and value for further studies.

Section Title: EXPERIMENTS
  EXPERIMENTS In this section, we describe training and testing of the proposed RL conservation law solver and compare it with WENO. More comparisons and discussions can be found in the appendix.

Section Title: SETUP
  SETUP In this subsection, we explain the general training setup. We train the RL policy network on the Burger's equation, whose flux is computed as f (u) = 1 2 u 2 . In all the experiments, we set the left-shift r = 2 and the right shift s = 3. The state function g s (s j ) = g s (U j−r−1 , ..., U j+s ) will generate two vectors: s l = (f j−r−1 , ..., f j+s−1 ,ā j− 1 2 ), and s r = (f j−r , ..., f j+s ,ā j+ 1 2 ) for computingf j− 1 2 and f j+ 1 2 respectively. s l and s r will be passed into the same policy neural network π RL θ to produce the desired actions, as described in section 3.2. The reward function g r simply computes the infinity norm, i.e., The policy network π RL θ is a feed-forward Multi-layer Perceptron with 6 hidden layers, each has 64 neurons and use Relu ( Goodfellow et al., 2016 ) as the activation function. We use the Deep Deterministic Policy Gradient Algorithm ( Lillicrap et al., 2015 ) to train the RL policy. To guarantee the generalization power of the trained RL agent, we randomly sampled 20 initial conditions in the form u 0 (x) = a + b · func(cπx), where |a| + |b| ≤ 3.5, func ∈ {sin, cos} and c ∈ {2, 4, 6}. The goal of generating such kind of initial conditions is to ensure they have similar degree of smoothness and thus similar level of difficulty in learning. The computation domain is −1 ≤ x ≤ 1 and 0 ≤ t ≤ 0.8 with ∆x = 0.02, ∆t = 0.004, and evolve steps N = 200 (which ensures the appearance of shocks). When training the RL agent, we use the Euler scheme for temporal discretization. The true solution needed for reward computing is generated using WENO on the same computation domain with ∆x = 0.001, ∆t = 0.0002 and the 4th order Runge-Kutta (RK4). In the following, we denote the policy network that generates the weights of the WENO fluxes (as described in section 3.2) as RL-WENO. We randomly generated another different 10 initial conditions in the same form as training for testing.

Section Title: RESULTS
  RESULTS We compare the performance of RL-WENO and WENO. We also test whether the trained RL policy can generalize to different temporal discretization schemes, mesh sizes and flux functions that are not included in training.  Table 1  and  Table 2  present the comparison results, where the number shows the relative error (computed as ||U −u||2 ||u||2 with the 2-norm taking over all x) between the approximated solution U and the true solution u, averaged over 250 evolving steps (T = 1.0) and 10 random initial values. Numbers in the bracket shows the standard deviation over the 10 initial conditions. Several entries in the table are marked as '-' because the corresponding CFL number is not small enough Under review as a conference paper at ICLR 2020 to guarantee convergence. Recall that training of the RL-WENO was conducted with Euler time discretization, (∆x, ∆t) = (0.02, 0.004), T = 0.8 and f (u) = 1 2 u 2 . Our experimental results show that, compared with the high order accurate WENO (5th order accurate in space and 4th order accurate in time), the linear weights learned by RL not only achieves smaller errors, but also generalizes well to: 1) longer evolving time (T = 0.8 for training and T = 1.0 for testing); 2) new time discretization schemes (trained on Euler, tested on RK4); 3) new mesh sizes (see  Table 1  and  Table 2  for results of varied ∆x and ∆t); and 4) a new flux function (trained on f (u) = 1 2 u 2 shown in  Table 1 , tested on 1 16 u 4  Table 2 ).  Figure 1  shows some examples of the solutions. As one can see, the solutions generated by RL-WENO not only achieve the same accuracy as WENO at smooth regions, but also have clear advantage over WENO near singularities which is particularly challenging for numerical PDE solvers and important in applications.  Figure 2  shows that the learned numerical flux policy can indeed correctly determine upwind directions and generate local numerical schemes in an adaptive fashion. More interestingly,  Figure 2  further shows that comparing to WENO, RL-WENO seems to be able to select stencils in a different way from it, and eventually leads to a more accurate solution. This shows that the proposed RL framework has the potential to surpass human experts in designing numerical schemes for conservation laws.

Section Title: CONCLUSION
  CONCLUSION In this paper, we proposed a general framework to learn how to solve 1-dimensional conservation laws via deep reinforcement learning. We first discussed how the procedure of numerically solving conservation laws can be naturally cast in the form of Markov Decision Process. We then elaborated how to relate notions in numerical schemes of PDEs with those of reinforcement learning. In particular, we introduced a numerical flux policy which was able to decide on how numerical flux should be designed locally based on the current state of the solution. We carefully design the action of our RL policy to make it a meta-learner. Our numerical experiments showed that the proposed RL based solver was able to outperform high order WENO and was well generalized in various cases. As part of the future works, we would like to consider using the numerical flux policy to inference more complicated numerical fluxes with guaranteed consistency and stability. Furthermore, we can use the proposed framework to learn a policy that can generate adaptive grids and the associated numerical schemes. Lastly, we would like consider system of conservation laws in 2nd and 3rd dimensional space. Under review as a conference paper at ICLR 2020

```
