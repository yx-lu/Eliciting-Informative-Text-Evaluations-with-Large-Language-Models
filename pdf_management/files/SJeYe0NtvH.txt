Title:
```
NEURAL TEXT DEGENERATION WITH UNLIKELIHOOD TRAINING
```
Abstract:
```
Neural text generation is a key tool in natural language applications, but it is well known there are major problems at its core. In particular, standard likelihood training and decoding leads to dull and repetitive outputs (Holtzman et al., 2019). While some post-hoc fixes have been proposed, in particular top-k and nucleus sampling, they do not address the fact that the token-level probabilities predicted by the model are poor. In this paper we show that the likelihood objective itself is at fault, resulting in a model that assigns too much probability to sequences con- taining repeats and frequent words, unlike those from the human training distri- bution. We propose a new objective, unlikelihood training, which forces unlikely generations to be assigned lower probability by the model. We show that both token and sequence level unlikelihood training give less repetitive, less dull text while maintaining perplexity, giving superior generations using standard greedy or beam search. According to human evaluations, our approach with standard beam search also outperforms the currently popular decoding methods of nucleus sam- pling or beam blocking, thus providing a strong alternative to existing techniques. * Equal contribution; the ordering was decided by a coin flip.
```

Figures/Tables Captions:
```
 
Table 1: Example greedy completions showing representative examples of the MLE model's de- generate single-token repetition (top), phrase-level repetition (middle), and 'structural' repetition (bottom), as well as the proposed method's ability to fix these degenerate behaviors.
Table 2: Results for token-level objectives (upper) and sequence-level fine-tuning (lower) according to sequence-level (left) and token-level (right) metrics using the test subset of Wikitext-103.
Table 3: Human eval results. * denotes statistical significance (2-sided binomial test, p < .05).
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Neural text generation is a vital tool in a wide range of natural language applications. However, the standard approach - training a sequence to sequence model, e.g. Transformer ( Vaswani et al., 2017 ), to maximize log-likelihood and approximately decoding the most likely sequence - is known to be flawed. Generated text in open-ended applications such as language modeling or dialogue has been observed to be dull, with high frequency tokens used too often and interesting content words used too rarely ( Holtzman et al., 2019 ;  Dinan et al., 2019 ). Moreover, the models repeat themselves at the token, phrase, and sentence levels, and statistics comparing a set of human-generated utterances and model-generated responses indicate a discrepancy between the human and model word distributions. This does not appear to be rectified by training on more data ( Radford et al., 2019 ). Recent fixes involve modifying the decoding strategy using sampling or more sophisticated beam search variants. However, these decoding strategies do not address the core issue: the model's underlying sequence probabilities are clearly not correct. Several reasons for exactly why neural text is degenerate have been posited, with the cause currently unknown. Possible candidates include the problem being (i) a by-product of the model architecture, e.g. the Transformer architecture preferring repeats ( Holtzman et al., 2019 ;  Vig, 2018 ), (ii) an intrin- sic property of human language ( Holtzman et al., 2019 ) rather than a modeling deficiency, or that (iii) a training objective relying on fixed corpora cannot take into account the real goal of using the language ( Choi, 2018 ). Our work shows that, while the above may be factors, a primary factor is the use of the likelihood objective itself, as we demonstrate that degeneration is alleviated if we replace the likelihood objective with our proposal. While low perplexity in the limit should lead to predicting the correct next target word, there are two major flaws of the likelihood objective: (i) it pays relatively little attention to the argmax or the top of the ranked list of next token probabilities, instead optimizing the likelihood of the entire distribution; (ii) it is not focused on optimizing sequence generation, only on producing the next token. The first issue means that greedy or beam search decoding, which rely on the top of the list to generate, are not optimized - there is a discrepancy between maximizing the log-probability of a ground-truth token and ensuring the rank of the ground-truth token to be one. The second issue means that during sequence generation, any imperfection in next token prediction leads to error accumulation that is not addressed by likelihood training. In this work, we introduce unlikelihood training, an approach that addresses the two aforementioned issues. It combines two types of updates: a likelihood update on the true target tokens so that they are assigned high probability, and an unlikelihood update on tokens that are otherwise assigned too high a probability. We can collect these unlikely token candidates either during next-token prediction or from generated sequences, allowing us to train at both the token and sequence levels. Both token and sequence level unlikelihood training are shown to improve metrics that measure dullness and repetition of the model, while maintaining performance in other metrics such as perplexity or token accuracy compared to the maximum likelihood baseline. Finally, we assess our models using human evaluations. We find that our generations have vastly improved quality compared to likelihood trained models when both models use beam search decoding. Moreover, our approach when using beam search also significantly improves over likelihood trained models using either beam blocking or nucleus sampling, thus outperforming the current state-of-the-art.

Section Title: RELATED WORK
  RELATED WORK Neural Text Degeneration Recently, several papers have observed various forms of neural text degeneration, especially in open-ended generation tasks. In dialogue, it has been shown that there is a mismatch between model and human word distributions, where generative models are more likely to output frequent words, but less likely to produce rare words compared to humans. For example, this was observed across all generative models submitted to the ConvAI2 NeurIPS 2018 competition ( Dinan et al., 2019 ). In language modeling, the work of  Holtzman et al. (2019)  highlighted problems with the word frequency distribution and level of repetition in model generations compared to human text. These issues are not remedied by simply increasing the amount of the training data; e.g. large- scale GPT-2 language models ( Radford et al., 2019 ) display the same issues.

Section Title: Improved Decoding Algorithms
  Improved Decoding Algorithms Several methods have been proposed to rectify these issues. The primary ones involve changing the decoding method to a sophisticated beam search variant or to stochastic decoding, e.g. sampling. Different variants of beam search have been explored ( Li et al., 2016 ;  Vijayakumar et al., 2018 ;  Kulikov et al., 2018 ;  Holtzman et al., 2018 ) which can decrease a model's level of repetition by selecting candidates that are unlike previously chosen ones. Separately, hard or soft beam blocking has been investigated ( Paulus et al., 2017 ;  Klein et al., 2017 ), whereby previously generated n-grams are blocked from subsequent generation. This approach is often used in dialogue generation, fixing some token or phrase level repetitions but removing repetitions that would naturally occur in human text. The second major approach is that of sampling from the model at generation time. Top k-sampling ( Fan et al., 2018 ) and nucleus sampling ( Holtzman et al., 2019 ) are two methods that sample se- quences based on a function of the predicted next token probability distribution given by the model. Both approaches vastly improve the repetition issue, as the randomization often reduces the number of duplicate tokens in a decoded sequence, even if highly scored paths under the model (represented by beam search candidates) contain repetitions. However, as the underlying model is unchanged, it often prefers semantically similar phrasing, depending on the temperature parameter of the sampling ( Holtzman et al., 2019 ). Furthermore, this solution is less relevant in less open-ended tasks such as machine translation, where beam search variants are the preferred method. Ideally we would like a model that can work with both beam and sampling decoding methods.

Section Title: Improved Learning Algorithms
  Improved Learning Algorithms The proposed learning criteria are closely related to structured output prediction methods in which the goal is to increase the scores assigned by a model to true examples while decreasing those assigned to negative examples often generated by the model it- self. Some representative algorithms include structured perceptron ( Collins, 2002 ), energy-based models ( LeCun et al., 2006 ) and more recently reflective likelihood ( Dieng et al., 2018 ). A par- ticular variant in this family of algorithms, called negative training, was recently used by  He and Glass (2019)  to prevent generic and malicious responses in dialogue models. Similarly, these struc- tured prediction algorithms with neural language models have been applied to machine translation in recent years by  Shen et al. (2015)  and  Edunov et al. (2017) .

Section Title: NEURAL TEXT GENERATION
  NEURAL TEXT GENERATION

Section Title: Language Modeling
  Language Modeling In language modeling, our goal is to model a probability distribution p * (x) over variable-length text sequences x = (x 1 , . . . , x |x| ) composed of tokens from a vocabulary, x t ∈ V. We wish to find a model p θ (x) which resembles p * (x), meaning that samplesx ∼ p θ are similar to samples from p * , and p θ (x) ≈ p * (x) for all x. When p θ (x) is parameterized by a neural network, we call p θ a neural language model. We assume that p θ takes the form p θ (x) = |x| t=1 p θ (x t |x <t ). The de facto approach to training such a model is to find parameters θ that maximize the log- likelihood of a finite set of samples D from p * by minimizing: Sequence Completion A closely related problem consists of sampling a sub-sequence, or prefix, x 1:k ∼ p * , then using p θ to conditionally decode a continuation,x k+1:N ∼ p θ (·|x 1:k ). We now want the resulting completion (x 1 , . . . , x k ,x k+1 , . . . ,x N ) to resemble a sample from p * . We use sequence completion as a setting to study the behavior of neural language models due to its generality. For instance, sequence completion encompasses story generation ( Fan et al., 2018 ), contextual text completion ( Radford et al., 2019 ), language modeling (for k = 0), and dialogue modeling ( Zhang et al., 2018 ) where x 1:k is a dialogue history and a continuation is a next utterance. Given p θ and a prefix x 1:k , finding the optimal continuation is not tractable, so in practice approxi- mate deterministic or stochastic decoding strategies are used to generate continuations.

Section Title: Deterministic Decoding
  Deterministic Decoding Two widely used deterministic decoding approaches are greedy search and beam search. The former can be seen as a special case of the latter. Greedy search selects the highest probability token at each time step: x t = arg max p θ (x t |x <t ). Beam search maintains a fixed-size set of partially-decoded sequences, called hypotheses. At each time step, beam search forms new hypotheses by appending each token in the vocabulary to each existing hypothesis, scor- ing the resulting sequences then selecting the highest scoring sequences. As we describe in Section 4, these deterministic decoding strategies, which depend highly on underlying model probabilities, expose issues with conventionally trained neural language models.

Section Title: Stochastic Decoding
  Stochastic Decoding An alternative is to sample from a model-dependent distribution at each step, x t ∼ q(x t |x <t , p θ ). In order to prevent sampling low probability tokens, a typical approach is to restrict sampling to a subset of the vocabulary U ⊂ V at each step: q(x t |x <t , p θ ) = p θ (x t |x <t )/Z x t ∈ U 0 otherwise, where Z = x∈U p θ (x|x <t ). The top-k sampler restricts sampling to the k most-probable tokens; i.e. U is the size k subset of V which maximizes x∈U p θ (x|x <t ) ( Fan et al., 2018 ). The nucleus sampler instead restricts sampling to the smallest set of tokens with total mass above a threshold p ∈ [0, 1]; i.e. U is the smallest subset with x∈U p θ (x|x <t ) >= p ( Holtzman et al., 2019 ).

Section Title: NEURAL TEXT DEGENERATION
  NEURAL TEXT DEGENERATION In this section we discuss two degenerate properties that frequently occur in conventional neural language models trained with the maximum likelihood objective (Equation 1). Repetition First, model-generated continuations exhibit sequence-level repetition, especially with deterministic decoding. The problem is seen by observing samples in Appendix Table 4, which shows completions from the state-of-the-art GPT-2 language model ( Radford et al., 2019 ). Greedy decoding as well as top-k and nucleus sampling exhibit degenerate repetition (with a certain hyper- parameter setting), although greedy decoding shows the worst degradation. Using a Transformer language model trained with maximum likelihood (§6), we find that the average percentage of re- peated n-grams in model continuations with greedy decoding (43%) far exceeds that of humans (0.5%), computed over prefixes drawn from a validation corpus. Unlike previous work which only focused on degenerate sequence-level repeats ( Holtzman et al., 2019 ), we additionally observe that neural language models exhibit substantially more repetition in next-token prediction compared to human text: For instance, the Transformer language model (§6) predicted next-tokens that appeared in the pre- ceding 128 words 62% of the time, versus 49% in ground-truth text. This is especially concerning since the maximum-likelihood objective focuses on optimizing next-token conditional distributions.

Section Title: Token Distribution Mismatch
  Token Distribution Mismatch Second, both greedy continuations and next-token predictions from conventional neural text generators have different token distributions from human text. As demonstrated by  Holtzman et al. (2019) , such models with greedy or beam search tend to produce high frequency tokens too often and low frequency tokens too rarely, where frequency is defined by the human token distribution. With the Transformer language model (§6), the set of next- token greedy predictions on a held-out validation set had roughly 40% fewer unique tokens than the ground-truth tokens (11.6k vs. 18.9k), and overproduced frequent tokens (Appendix Figure 1). Such behavior has been linked to generations being judged as dull by humans because rare words can add engaging specificity ( Weston et al., 2018 ;  See et al., 2019 ).

Section Title: THE UNLIKELIHOOD TRAINING OBJECTIVE
  THE UNLIKELIHOOD TRAINING OBJECTIVE We now describe unlikelihood training for neural language models, then in Section 6 demonstrate empirically that our proposal substantially improves neural text degeneration (§4).

Section Title: UNLIKELIHOOD TRAINING
  UNLIKELIHOOD TRAINING The key idea behind unlikelihood training is decreasing the model's probability of certain tokens, called negative candidates. Given a sequence (x 1 , . . . , x T ) and a set of negative candidate tokens C t = {c 1 , . . . , c m }, where each c j ∈ V, we define the unlikelihood loss for step t as: The loss decreases as p θ (c|x <t ) decreases. We incorporate the unlikelihood loss into a token-level unlikelihood objective which augments each time-step of maximum likelihood training: As candidates, we use previous context tokens: Intuitively, minimizing the unlikelihood loss with this candidate set makes (i) incorrect repeating tokens less likely, as the previous context contains potential repeats, and (ii) frequent tokens less likely, as these tokens appear often in the previous context. These candidates are efficient to com- pute, without requiring additional supervision.

Section Title: Gradient analysis
  Gradient analysis We assume p θ (x t |x <t ) = softmax(a) and consider the gradient of (4) with respect to the softmax input a ∈ R V . With a single negative candidate, the (negative) gradient is: where x * ∈ {0, 1} V is a one-hot ground-truth vector, m ∈ R V , p = p θ (·|x <t ), and p neg is the probability of the negative candidate at index i neg (derivation in Appendix A). This unlikelihood gradient (6) differs from the likelihood gradient, (x * −p), due to the term m which varies based on the hyper-parameter α and the model's negative candidate probability, p neg . At the ground-truth token index i * , the unlikelihood gradient is positive, increasing the ground-truth token's probability with a magnitude that grows with p neg . Conversely, at the negative candidate index i neg the gradient is negative. At all other token indices i ∈ {i * , i neg }, the gradient moves from negative to positive as p neg increases. For instance, with α = 1.0 the gradient increases the probability of each token x i when the model assigns high probability to the negative candidate (p neg > 0.5).

Section Title: SEQUENCE-LEVEL UNLIKELIHOOD TRAINING
  SEQUENCE-LEVEL UNLIKELIHOOD TRAINING While the token-level unlikelihood objective efficiently augments maximum likelihood training with token-level penalties, it is limited to prefixes drawn from the training distribution. The resulting distribution mismatch between training sequences and generated sequences is a known issue with maximum-likelihood training, motivating objectives that operate on model-generated sequences ( Daumé et al., 2009 ;  Ross et al., 2011 ;  Ranzato et al., 2015 ;  Yu et al., 2016 ). We thus propose a sequence-level unlikelihood objective which uses unlikelihood on decoded con- tinuations. That is, given a prefix (x 1 , . . . , x k ) ∼ p * , we decode a continuation (x k+1 , . . . , x k+N ) ∼ p θ (·|x 1 , . . . , x k ), construct per-step negative candidate sets (C k+1 , . . . , C k+N ), and define each per- step sequence-level loss for t ∈ {k + 1, . . . , k + N } as: Intuitively, the negative candidates can identify problematic tokens for the loss to penalize. We choose to penalize repeating n-grams in the continuation: which says that x t is the (single) negative candidate for step t if it is part of a repeating n-gram 1 . In our experiments we apply this sequence loss in two ways: (i) using it to fine-tune a standard MLE baseline; and (ii) using it to fine-tune an unlikelihood model trained at the token level, L UL-token . We refer to the former as L UL-seq and the latter as L UL-token+seq . In both cases, fine-tuning is done by equally mixing sequence-level unlikelihood updates (7) and the token-level loss from which it was initially trained (either likelihood updates (1) or token-level unlikelihood updates (4)).

Section Title: Efficiency
  Efficiency Any objective that requires explicitly decoding a sequence is constrained by sample efficiency when decoding is slow; if sample efficiency is low, the total decoding time is too large for practical use. In our experiments we show that when used for fine-tuning, the sequence-level unlike- lihood objective substantially reduced degeneration in under 1,500 updates, rendering it practical for modern large-scale neural models, even with high decoding costs.

Section Title: EXPERIMENTS
  EXPERIMENTS We follow a standard language modeling setup from  Baevski and Auli (2019)  and evaluate our method on the task of sequence completion, detailed below.

Section Title: Model Architecture
  Model Architecture Recent large-scale language models are based on the Transformer architec- ture, a multi-layer feed-forward network with self-attention ( Vaswani et al., 2017 ). We use a 16-layer Transformer with 8 attention heads, embedding dimension 1024, and fully-connected dimension 4096; the architecture is based on  Baevski and Auli (2019)  but with standard embedding and soft- max layers. Our proposed method is architecture agnostic; we choose this one as a representative of recent large-scale language models, e.g.  Radford et al. (2019) .

Section Title: Dataset
  Dataset We use the Wikitext-103 dataset ( Merity et al., 2016 ), a large-scale collection of Wikipedia articles containing over 100 million words and 260 thousand unique tokens. As a document-level dataset, Wikitext-103 is an open-source representative of recent datasets used for large-scale language modeling ( Baevski and Auli, 2019 ;  Radford et al., 2019 ). We perform experi- ments at the word level.

Section Title: Training
  Training We train on fixed-length contiguous sequences, in our case of length 1,536, which was selected based on GPU memory constraints. For the token-level losses (L MLE , L UL-token ), we train each model on 8 GPUs for a maximum of 150k updates, evaluating on the validation set and saving the model state every 10k updates. For the experiments below, we select the saved model state with the best validation perplexity. Sequence-level fine-tuning begins with the model state selected based on the validation perplexity. Models are fine-tuned for 1,500 total updates. With probability 0.5 an update uses L ULS and other- wise uses the token-level loss with which the model was trained. For a L ULS update, we split each training sequence and greedily decode continuations (details below). The experiments use a prefix length k = 50 and continuation length N = 100 for fine-tuning.

Section Title: Completions
  Completions We evaluate a model on sequence completion by using the model to decode contin- uations of prefixes derived from the validation (or test) set. Specifically, the validation (or test) set is first partitioned into sequences of 1,536 tokens, as in training. Then we split each sequence into a batch of prefixes of length k (discarding extra tokens), and decode a continuation of length N for each prefix. The experiments below use k = 50 and N = 100 for evaluation. For deterministic decoding we use greedy search and beam search with beam size 10, and for stochastic decoding we use top-k sampling with k ∈ {3, 50} and nucleus sampling with p ∈ {0.3, 0.9}.

Section Title: EVALUATION METRICS
  EVALUATION METRICS Repetition As a token-level metric for repetition, we use the fraction of next-token (top-1) predic- tions that occur in the previous tokens (rep/ ); given a set D of length-T sequences, A predicted token is called a "single-token repeat" when I [·] is 1. Some of these single-token repeats also occur in the human-generated sequences, and we thus report a variant which only counts single- token repeats that are additionally not equal to the ground-truth next-token (wrep/ ). We use the portion of duplicate n-grams (seq-rep-n) in a generated sequence to measure sequence- level repetition. That is, for a continuation x k+1:k+N we compute, seq-rep-n = 1.0 − |unique n-grams(x k+1:k+N )| |n-grams| , (10) and average over continuations. seq-rep-n is zero when the continuation has no repeating n-grams, and increases towards 1.0 as the model repeats. We compute seq-rep-n on the continuation.

Section Title: Token Distribution
  Token Distribution We quantify a model's predicted token distribution using the number of unique tokens. As a token-level metric (uniq), we use the number of unique next-token predic- tions on a validation or test set D, i.e. |{arg max p(x t |x <t ) | x <t ∈ D}|. As a sequence-level metric (uniq-seq) we use the number of unique tokens in continuations of validation or test prefixes (§6).

Section Title: Language Modeling Quality
  Language Modeling Quality We use perplexity (ppl), and next-token prediction accuracy (acc), defined as 1

Section Title: RESULTS
  RESULTS Token-level and sequence-level results on the test set are in  Table 2  (valid set in Appendix Table 5).

Section Title: Baseline
  Baseline The baseline model trained with maximum likelihood (L MLE ) achieved 25.64 test per- plexity, comparable to a current state-of-the-art system ( Baevski and Auli, 2019 ) (24.92). However, the greedy baseline's seq-level repeats (seq-rep-4 .442) and single-token repeats (rep .627) far ex- ceed those in human text (.006, .487 respectively). The baseline continuations have far fewer unique tokens than human text (uniq-seq 11.8k vs 19.8k), with a high rate of frequent tokens (Figure 1).

Section Title: Token-Level Objective
  Token-Level Objective The proposed token-level unlikelihood objective (L UL-token ) reduced next- token wrong repetition (wrep .311 vs. .352) while increasing the number of unique next-tokens (uniq 12.7k vs. 11.8k) compared to the baseline (L MLE ). Perplexity and accuracy were similar. Importantly, the token-level unlikelihood objective yielded substantial improvements in sequence- level generations. With greedy search, token-level unlikelihood training improved the 4-gram repe- tition in continuations by 36% (seq-rep-4 .283 vs. .442) while generating roughly 22% more unique tokens than the baseline (uniq-seq 13.2k vs. 10.8k), and a more favorable rate of infrequent tokens (Figure 1). With beam search, unlikelihood training showed similar improvements over the baseline.

Section Title: Sequence-Level Objective
  Sequence-Level Objective The sequence level fine-tuning (L UL-token+seq ) yielded further improve- ments, with a 97% reduction in 4-gram repetitions (seq-rep-4 .013 vs. .442) from the baseline level (greedy L MLE ), and 77% more unique tokens (uniq-seq 19.1k vs. 10.8k) with beam search. Compared to the token-level unlikelihood model (L UL-token ) which was the starting point of fine- tuning, the fine-tuned model's repetition substantially improved (seq-rep-4 .058 vs. .283), unique tokens increased (uniq-seq 15.4k vs. 13.2k), and token-level metrics such as perplexity improved (ppl 26.72 vs. 26.91), despite using only 1,500 updates. The token distribution improved, with in- frequent tokens produced more often than the baseline, and frequent tokens approaching the human level (Figure 1). Finally, after sequence-level fine-tuning, beam search out-performed greedy search. To visualize how these improvements in metrics translate to generation quality,  Table 1  shows greedy completions that characterize the baseline's degeneration and L UL-token+seq 's improved behavior.

Section Title: GPT-2 Fine-Tuning
  GPT-2 Fine-Tuning In the preceding experiment, sequence-level fine-tuning alone (L UL-seq ) showed substantial improvements over the baseline using a small number of updates. This indi- cates that the proposed sequence-level fine-tuning can be a cheap, effective way to improve existing pre-trained language models. We demonstrate this by fine-tuning a pre-trained GPT-2 ( Radford et al., 2019 ) language model with sequence-level unlikelihood, using a comparable experimental setup to §6 (details in Appendix C). Fine-tuning with unlikelihood yielded similar improvements in sequence-level repetition (seq-rep-4 .042 vs. .506) to those observed in Table 5, while maintaining language modeling quality according to perplexity and accuracy (see Appendix Table 7).

Section Title: Stochastic Decoding
  Stochastic Decoding Although we have focused on deterministic decoding, we also confirm that a model trained with the proposed unlikelihood objectives may still be used with stochastic decoders. Appendix Table 6 shows metrics for completions generated with top-k sampling ( Fan et al., 2018 ) and nucleus sampling ( Holtzman et al., 2019 ). Models trained with unlikelihood objectives maintain language modeling quality compared to the baseline, but with improvements in repetition.

Section Title: Human Evaluation
  Human Evaluation We perform a crowdworker evaluation to judge the quality of the generations of our proposed models compared to each other, the baseline, two other generation methods, and the reference. We employ a pairwise setup: an evaluator is presented with a prefix and shown continuations from two different models and asked to select which continuation they found more natural. Following  Li et al. (2019) , we filter workers using quality controls (detailed in Appendix E) and limit the number of annotations that they may complete. Prompts are from the Wikitext-103 test set. All models used beam search (beam size 10) for generation, except for those that use stochastic decoding. We report the win rates for each pairwise comparison. The main results are presented in  Table 3 , with additional experiments in Appendix Table 9. We find that all proposed models are preferred over the baseline, and that congruent with automatic metrics, win rates improve after adding the sequence level objective. Our best model also outperforms the baseline used with either nucleus sampling or beam blocking. We also collected limited annotations from other NLP researchers. These Expert annotators were given the same UI as the crowdworkers, and not told about models they were evaluating, but all annotators were familiar with language models. As shown in  Table 3 , the L UL-token+seq model signif- icantly outperforms both nucleus sampling and beam blocking according to the experts.

Section Title: CONCLUSION
  CONCLUSION We described unlikelihood training, an approach to training neural language models. We observed that state-of-the-art models trained to maximize likelihood exhibit neural text degeneration, which we characterized and quantified in terms of repetition and token distribution mismatch. Our results show that the likelihood objective is not constrained enough, in the sense that two models with the same perplexity can exhibit wildly different generation performance. We empirically showed that unlikelihood training - both at the token and sequence levels - substantially reduced degeneration according to automatic metrics, and outperformed likelihood-trained models with various decoding methods according to human evaluation, being superior to the current state-of-the-art approaches.
    Ott et al., 2019 ).

```
