Title:
```
Under review as a conference paper at ICLR 2020 BEHAVIOR REGULARIZED OFFLINE REINFORCEMENT LEARNING
```
Abstract:
```
In reinforcement learning (RL) research, it is common to assume access to direct online interactions with the environment. However in many real-world applications, access to the environment is limited to a fixed offline dataset of logged experience. In such settings, standard RL algorithms have been shown to diverge or otherwise yield poor performance. Accordingly, much recent work has suggested a number of remedies to these issues. In this work, we introduce a general framework, behavior regularized actor critic (BRAC), to empirically evaluate recently proposed methods as well as a number of simple baselines across a variety of offline continuous control tasks. Surprisingly, we find that many of the technical complexities introduced in recent methods are unnecessary to achieve strong performance. Additional ablations provide insights into which design choices matter most in the offline RL setting.
```

Figures/Tables Captions:
```
Figure 1: Comparing fixed α with adaptively trained α. Black dashed lines are the performance of the partially trained policies (distinct from the behavior policies which have injected noise). We report the mean over the last 10 evaluation points (during training) averaged over 5 different random seeds. Each evaluation point is the return averaged over 20 episodes. We report the performance as 0 if it is negative.
Figure 2: Comparing different number of Q-functions for target Q-value ensemble. We use a weighted mixture to compute the target value for all of these variants. As expected, we find that using an ensemble (k > 1) is better than using a single Q-function.
Figure 3: Comparing taking the minimum v.s. a weighted mixture in Q-value ensemble. We find that simply taking the minimum is usually slightly better, except in Hopper-v2.
Figure 4: Comparing policy regularization (pr) v.s. value penalty (vp) with MMD. The use of value penalty is usually slightly better.
Figure 5: Comparing different divergences under both policy regularization (top row) and value penalty (bottom row). All variants yield similar performance, which is significantly better than the partially trained policy.
Figure 6: Comparing value penalty with KL divergence (kl_vp) to vanilla SAC, behavior cloning (bc), BCQ and BEAR. Bottom row shows sampled training curves with 1 out of the 5 datasets. See Appendix for training curves on all datasets.
Figure 7: Correlation between learned Q-values and performance. x-axis is the average of learned Q ψ (s, a) over the last 500 training batches. y-axis is the average performance over the last 10 evaluation points. Each plot corresponds to a (environment, algorithm, dataset) tuple. Different points in each plot correspond to different hyperparameters and different random seeds. Although we utilized hyperparameter searches in our results, in pure offline RL settings, testing on the real environment is infeasible. Thus, a natural question is how to select the best hyperparameter or the best learned policy among many without direct testing. As a preliminary attempt, we evaluated whether the Q-values learned during training can be used as a proxy for hyperparameter selection. Specifically, we look at the correlation between the average learned Q-values (in mini-batches) and the true performance. Figure 7 shows sampled visualizations of these Q-values. We find that the learned Q-values are not a good indicator of the performance, even when they are within a reasonable range (i.e., not diverging during training). A more formal direction for doing hyperparameter selection is to do off-policy evaluation. However, off-policy evaluation is an open research problem with limited Under review as a conference paper at ICLR 2020 success on complex continuous control tasks (see Liu et al. (2018); Nachum et al. (2019); Irpan et al. (2019) for recent attempts), we leave hyperparameter selection as future work and encourage more researchers to investigate this direction.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Offline reinforcement learning (RL) describes the setting in which a learner has access to only a fixed dataset of experience. In contrast to online RL, additional interactions with the environment during learning are not permitted. This setting is of particular interest for applications in which deploying a policy is costly or there is a safety concern with updating the policy online ( Li et al., 2015 ). For example, for recommendation systems ( Li et al., 2011 ; Covington et al., 2016) or health applications ( Murphy et al., 2001 ), deploying a new policy may only be done at a low frequency after extensive testing and evaluation. In these cases, the offline dataset is often very large, potentially encompassing years of logged experience. Nevertheless, the inability to interact with the environment directly poses a challenge to modern RL algorithms. Issues with RL algorithms in the offline setting typically arise in cases where state and actions spaces are large or continuous, necessitating the use of function approximation. While off-policy (deep) RL algorithms such as DQN ( Mnih et al., 2013 ), DDPG ( Lillicrap et al., 2015 ), and SAC ( Haarnoja et al., 2018 ) may be run directly on offline datasets to learn a policy, the performance of these algorithms has been shown to be sensitive to the experience dataset distribution, even in the online setting when using a replay buffer ( Van Hasselt et al., 2018 ;  Fu et al., 2019 ). Moreover,  Fujimoto et al. (2018a)  and  Kumar et al. (2019)  empirically confirm that in the offline setting, DDPG fails to learn a good policy, even when the dataset is collected by a single behavior policy, with or without noise added to the behavior policy. These failure cases are hypothesized to be caused by erroneous generalization of the state-action value function (Q-value function) learned with function approximators, as suggested by  Sutton (1995) ;  Baird (1995) ;  Tsitsiklis & Van Roy (1997) ;  Van Hasselt et al. (2018) . To remedy this issue, two types of approaches have been proposed recently: 1)  Agarwal et al. (2019)  proposes to apply a random ensemble of Q-value targets to stabilize the learned Q-function, 2)  Fujimoto et al. (2018a) ;  Kumar et al. (2019) ;  Jaques et al. (2019) ;  Laroche & Trichelair (2017)  propose to regularize the learned policy towards the behavior policy based on the intuition that unseen state-action pairs are more likely to receive overestimated Q-values. These proposed remedies have been shown to improve upon DQN or DDPG at performing policy improvement based on offline data. Still, each proposal makes several modifications to the building components of baseline off-policy RL algorithms, and each modification may be implemented in various ways. So a natural question to ask is, which of the design choices in these offline RL algorithms are necessary to achieve good performance? For example, to estimate the target Q-value when minimizing the Bellman error,  Fujimoto et al. (2018a)  uses a soft combination of two target Q-values, which is different from TD3 Under review as a conference paper at ICLR 2020 ( Fujimoto et al., 2018b ), where the minimum of two target Q-values is used. This soft combination is maintained by  Kumar et al. (2019) , while further increasing the number of Q-networks from two to four. As another example, when regularizing towards the behavior policy,  Jaques et al. (2019)  uses Kullback-Leibler (KL) divergence with a fixed regularization weight while  Kumar et al. (2019)  proposes to use Maximum Mean Discrepancy (MMD) with an adaptively trained regularization weight. Are these design choices crucial to success in offline settings? Or are they simply the result of multiple, human-directed iterations of research? In this work, we aim at evaluating the importance of different algorithmic building components as well as comparing different design choices in offline RL approaches. We focus on behavior regularized approaches applied to continuous action domains, encompassing many of the recently demonstrated successes ( Fujimoto et al., 2018a ;  Kumar et al., 2019 ). We introduce behavior regularized actor critic (BRAC), a general algorithmic framework which covers existing approaches while enabling us to compare the performance of different variants in a modular way. We find that many simple variants of the behavior regularized approach can yield good performance, while previously suggested sophisticated techniques such as weighted Q-ensembles and adaptive regularization weights are not crucial. Experimental ablations reveal further insights into how different design choices affect the performance and robustness of the behavior regularized approach in the offline RL setting.

Section Title: BACKGROUND
  BACKGROUND

Section Title: MARKOV DECISION PROCESSES
  MARKOV DECISION PROCESSES We consider the standard fully-observed Markov Decision Process (MDP) setting ( Puterman, 1990 ). An MDP can be represented as M = (S, A, P, R, γ) where S is the state space, A is the action space, P (·|s, a) is the transition probability distribution function, R(s, a) is the reward function and γ is the discount factor. The goal is to find a policy π(·|s) that maximizes the cumulative discounted reward starting from any state s ∈ S. Let P π (·|s) denote the induced transition distri- bution for policy π. For later convenience, we also introduce the notion of multi-step transition distributions as P π t , where P π t (·|s) denotes the distribution over the state space after rolling out P π for t steps starting from state s. For example, P π 0 (·|s) is the Dirac delta function at s and P π 1 (·|s) = P π (·|s). We use R π (s) to denote the expected reward at state s when following policy π, i.e. R π (s) = E a∼π(·|s) [R(s, a)]. The state value function (a.k.a. value function) is defined by V π (s) = ∞ t=0 γ t E st∼P π t (s) [R π (s t )]. The action-value function (a.k.a. Q-function) can be written as Q π (s, a) = R(s, a) + γE s ∼P (·|s,a) [V π (s )]. The optimal policy is defined as the policy π * that maximizes V π * (s) at all states s ∈ S. In the commonly used actor critic paradigm, one optimizes a policy π θ (·|s) by alternatively learning a Q-value function Q ψ to minimize Bellman errors over single step transitions (s, a, r, s ), E a ∼π θ (·|s ) r + γQ(s , a ) − Q ψ (s, a) 2 , whereQ denotes a target Q function; e.g., it is common to use a slowly-updated target parameter set ψ to determine the target Q function as Q ψ (s , a ). Then, the policy is updated to maximize the Q-values, E a∼π(·|s) [Q ψ (s, a)].

Section Title: OFFLINE REINFORCEMENT LEARNING
  OFFLINE REINFORCEMENT LEARNING Offline RL (also known as batch RL (Lange et al., 2012)) considers the problem of learning a policy π from a fixed dataset D consisting of single-step transitions (s, a, r, s ). Slightly abusing the notion of "behavior", we define the behavior policy π b (a|s) as the conditional distribution p(a|s) observed in the dataset distribution D. Under this definition, such a behavior policy π b is always well-defined even if the dataset was collected by multiple, distinct behavior policies. Because we do not assume direct access to π b , it is common in previous work to approximate this behavior policy with max-likelihood over D:π We denote the learned policy asπ b and refer to it as the "cloned policy" to distinguish it from the true behavior policy. In this work, we focus on the offline RL problem for complex continuous domains. We briefly review two recently proposed approaches, BEAR ( Kumar et al., 2019 ) and BCQ ( Fujimoto et al., 2018a ). Under review as a conference paper at ICLR 2020 BEAR Motivated by the hypothesis that deep RL algorithms generalize poorly to actions outside the support of the behavior policy,  Kumar et al. (2019)  propose BEAR, which learns a policy to maximize Q-values while penalizing it from diverging from behavior policy support. BEAR measures divergence from the behavior policy using kernel MMD ( Gretton et al., 2007 ): MMD 2 k (π(·|s), π b (·|s)) = E x,x ∼π(·|s) [K(x, x )] − 2E x∼π(·|s) y∼π b (·|s) [K(x, y)] + E y,y ∼π b (·|s) [K(y, y )] , (2) where K is a kernel function. Furthermore, to avoid overestimation in the Q-values, the target Q-value functionQ is calculated as, Q(s , a ) := 0.75 · min j=1,...,k Q ψ j (s , a ) + 0.25 · max j=1,...,k Q ψ j (s , a ), (3) where ψ j is denotes a soft-updated ensemble of target Q functions. In BEAR's implementation, this ensemble is of size k = 4. BEAR also penalizes target Q-values by an ensemble variance term. However, their empirical results show that there is no clear benefit to doing so, thus we omit this term. BCQ BCQ enforces π to be close to π b with a specific parameterization of π: where ξ θ is a function approximator with bounded ouptput in [−Φ, Φ] where Φ is a hyperparameter. N is an additional hyperparameter used during evaluation to compute π θ and during training for Q-value updates. The target Q-value functionQ is calculated as in Equation 3 but with k = 2.

Section Title: BEHAVIOR REGULARIZED ACTOR CRITIC
  BEHAVIOR REGULARIZED ACTOR CRITIC Encouraging the learned policy to be close to the behavior policy is a common theme in previous approaches to offline RL. To evaluate the effect of different behavior policy regularizers, we introduce behavior regularized actor critic (BRAC), an algorithmic framework which generalizes existing approaches while providing more implementation options. There are two common ways to incorporate regularization to a specific policy: through a penalty in the value function or as a penalty solely on the policy. We begin by introducing the former, value penalty (vp). Similar to SAC ( Haarnoja et al., 2018 ) which adds an entropy term to the target Q-value calculation, we add a term to the target Q-value calculation that regularizes the learned policy π towards the behavior policy π b . Specifically, we define the penalized value function as V π D (s) = ∞ t=0 γ t E st∼P π t (s) [R π (s t ) − αD (π(·|s t ), π b (·|s t ))] , (5) where D is a divergence function between distributions over actions (e.g., MMD or KL divergence). Following the typical actor critic framework, the Q-value objective is given by, min Q ψ E (s,a,r,s )∼D a ∼π θ (·|s ) r + γ Q (s , a ) − αD (π θ (·|s ), π b (·|s )) − Q ψ (s, a) 2 , (6) whereQ again denotes a target Q function andD denotes a sample-based estimate of the divergence function D. The policy learning objective can be written as, Accordingly, one performs alternating gradient updates based on (6) and (7). This algorithm is equiv- alent to SAC when using a single-sample estimate of the entropy forD; i.e.,D(π θ (·|s ), π b (·|s )) := log π(a |s ) for a ∼ π(·|s ). The second way to add the regularizer is to only regularize the policy during policy optimization. That is, we use the same objectives in Equations 6 and 7, but use α = 0 in the Q update while using a non-zero α in the policy update. We call this variant policy regularization (pr). This proposal is similar to the regularization employed in A3C ( Mnih et al., 2016 ), if one uses the entropy of π θ to computeD. In addition to the choice of value penalty or policy regularization, the choice of D and how to perform sample estimation ofD is a key design choice of BRAC:

Section Title: Kernel MMD
  Kernel MMD We can compute a sample based estimate of kernel MMD (Equation 2) by drawing samples from both π θ and π b . Because we do not have access to multiple samples from π b , this requires a pre-estimated cloned policyπ b . KL Divergence With KL Divergence, the behavior regularizer can be written as Directly estimating D KL via samples requires having access to the density of both π θ and π b ; as in MMD, the clonedπ b can be used in place of π b . Alternatively, we can avoid estimating π b explicitly, by using the dual form of the KL-divergence. Specifically, any f -divergence ( Csiszár, 1964 ) has a dual form ( Nowozin et al., 2016 ) given by, where f * is the Fenchel dual of f . In this case, one no longer needs to estimate a cloned policŷ π b but instead needs to learn a discriminator function g with minimax optimization as in  Nowozin et al. (2016) . This sample based dual estimation can be applied to any f -divergence. In the case of a KL-divergence, f (x) = − log x and f * (t) = − log(−t) − 1.

Section Title: Wasserstein Distance
  Wasserstein Distance One may also use the Wassertein distance as the divergence D. For sample- based estimation, one may use its dual form, W (p, q) = sup g:||g|| L ≤1 E x∼p [g(x)] − E x∼q [g(x)] and maintain a discriminator g as in  Gulrajani et al. (2017) . Now we discuss how existing approaches can be instantiated under the framework of BRAC.

Section Title: BEAR
  BEAR To re-create BEAR with BRAC, one uses policy regularization with the sample-based kernel MMD forD and uses a min-max ensemble estimate forQ (Equation 3). Furthermore, BEAR adaptively trains the regularization weight α as a Lagriagian multiplier: it sets a threshold > 0 for the kernel MMD distance and increases α if the current average divergence is above the threshold and decreases α if below the threshold.

Section Title: BCQ
  BCQ The BCQ algorithm does not use any regularizers (i.e. α = 0 for both value and policy objectives). Still, the algorithm may be realized by BRAC if one restricts the policy optimization in Equation 7 to be over parameterized policies based on Equation 4.

Section Title: KL-Control
  KL-Control There has been a rich set of work which investigates regularizing the learned policy through KL-divergence with respect to another policy, e.g.  Abdolmaleki et al. (2018) ;  Kakade (2002) ;  Peters et al. (2010) ;  Schulman et al. (2015) ;  Nachum et al. (2017) . Notably,  Jaques et al. (2019)  apply this idea to offline RL in discrete action domains by introducing a KL value penalty in the Q-value definition. It is clear that BRAC can realize this algorithm as well. To summarize, one can instantiate the behavior regularized actor critic framework with different design choices, including how to estimate the target Q value, which divergence to use, whether to learn α adaptively, whether to use a value penalty in the Q function objective (6) or just use policy regularization in (7) and so on. In the next section, we empirically evaluate a set of these different design choices to provide insights into what actually matters when approaching the offline RL problem.

Section Title: EXPERIMENTS
  EXPERIMENTS The BRAC framework encompasses several previously proposed methods depending on specific design choices (e.g., whether to use value penalty or policy regularization, how to compute the target Q-value, and how to impose the behavior regularization). For a practitioner, key questions are: How should these design choices be made? Which variations among these different algorithms actually matter? To answer these questions, we perform a systematic evaluation of BRAC under different design choices. Under review as a conference paper at ICLR 2020 Following  Kumar et al. (2019) , we evaluate performance on four Mujoco ( Todorov et al., 2012 ) continuous control environments in OpenAI Gym ( Brockman et al., 2016 ): Ant-v2, HalfCheetah- v2, Hopper-v2, and Walker2d-v2. In many real-world applications of RL, one has logged data from sub-optimal policies (e.g., robotic control and recommendation systems). To simulate this scenario, we collect the offline dataset with a sub-optimal policy perturbed by additional noise. To obtain a partially trained policy, we train a policy with SAC and online interactions until the policy performance achieves a performance threshold (1000, 4000, 1000, 1000 for Ant-v2, HalfCheetah-v2, Hopper-v2, Walker2d-v2, respectively, similar to the protocol established by  Kumar et al. (2019) ). Then, we perturb the partially trained policy with noise (Gaussian noise or -greedy at different levels) to simulate different exploration strategies resulting in five noisy behavior policies. We collect 1 million transitions according to each behavior policy resulting in five datasets for each environment (see Appendix for implementation details). We evaluate offline RL algorithms by training on these fixed datasets and evaluating the learned policies on the real environments. In preliminary experiments, we found that policy learning rate and regularization strength have a significant effect on performance. As a result, for each variant of BRAC and each environment, we do a grid search over policy learning rate and regularization strength. For policy learning rate, we search over six values, ranging from 3 · 10 6 to 0.001. The regularization strength is controlled differently in different algorithms. In the simplest case, the regularization weight α is fixed; in BEAR the regularization weight is adaptively trained with dual gradient ascent based on a divergence constraint that is tuned as a hyperparameter; in BCQ the corresponding tuning is for the perturbation range Φ. For each of these options, we search over five values (see Appendix for details). For existing algorithms such as BEAR and BCQ, the reported hyperparameters in their papers ( Kumar et al., 2019 ;  Fujimoto et al., 2018a ) are included in this search range, We select the best hyperparameters according to the average performance over all five datasets. Currently, BEAR ( Kumar et al., 2019 ) provides state-of-the-art performance on these tasks, so to understand the effect of variations under our BRAC framework, we start by implementing BEAR in BRAC and run a series of comparisons by varying different design choices: adaptive vs. fixed regu- larization, different ensembles for estimating target Q-values, value penalty vs. policy regularization and divergence choice for the regularizer. We then evaluate BCQ, which has a different design in the BRAC framework, and compare it to other BRAC variants as well as several baseline algorithms.

Section Title: FIXED V.S. ADAPTIVE REGULARIZATION WEIGHTS
  FIXED V.S. ADAPTIVE REGULARIZATION WEIGHTS In BEAR, regularization is controlled by a threshold , which is used for adaptively training the Lagrangian multiplier α, whereas typically (e.g., in KL-control) one uses a fixed α. In our initial experiments with BEAR, we found that when using the recommended value of , the learned value of α consistently increased during training, implying that the MMD constraint between π θ and π b was almost never satisfied. This suggests that BEAR is effectively performing policy regularization with a large α rather than constrained optimization. This led us to question if adaptively training α is better than using a fixed α. To investigate this question, we evaluate the performance of both approaches (with appropriate hyperparameter tuning for each, over either α or ) in  Figure 1 . On most datasets, both approaches learn a policy that is much better than the partially trained policy 1 , although we do observe a consistent modest advantage when using a fixed α. Because using a fixed α is simpler and performs better than adaptive training, we use this approach in subsequent experiments.

Section Title: ENSEMBLE FOR TARGET Q-VALUES
  ENSEMBLE FOR TARGET Q-VALUES Another important design choice in BRAC is how to compute the target Q-value, and specifically, whether one should use the sophisticated ensemble strategies employed by BEAR and BCQ. Both BEAR and BCQ use a weighted mixture of the minimum and maximum among multiple learned Q-functions (compared to TD3 which simply uses the minimum of two). BEAR further increases the number of Q-functions from 2 to 4. To investigate these design choices, we first experiment with different number of Q-functions k = {1, 2, 4}. Results are shown in  Figure 2 .  Fujimoto et al. (2018b)  show that using two Q-functions provides significant improvements in online RL; similarly, we find that using k = 1 sometimes fails to learn a good policy (e.g., in Walker2d) in the offline setting. Using k = 4 has a small advantage compared to k = 2 except in Hopper. Both k = 2 and k = 4 significantly improve over the partially trained policy baseline. In general, increasing the value of k in ensemble will lead to more stable or better performance, but requires more computation cost. On these domains we found that k = 4 only gives marginal improvement over k = 2, so we use k = 2 in our remaining experiments. Regarding whether using a weighed mixture of Q-values or the minimum, we compare these two options under k = 2. Results are shown in  Figure 3 . We find that taking the minimum performs slightly better than taking a mixture except in Hopper, and both successfully outperform the partially trained policy in all cases. Due to the simplicity and strong performance of taking the minimum of two Q-functions, we use this approach in subsequent experiments.

Section Title: VALUE PENALTY OR POLICY REGULARIZATION
  VALUE PENALTY OR POLICY REGULARIZATION So far, we have evaluated variations in regularization weights and ensemble of Q-values. We found that the technical complexity introduced in recent works is not always necessary to achieve state-of- the-art performance. With these simplifications, we now evaluate a major variation of design choices in BRAC - using value penalty or policy regularization. We follow our simplified version of BEAR: MMD policy regularization, fixed α, and computation of target Q-values based on the minimum of a k = 2 ensemble. We compare this instantiation of BRAC to its value penalty version, with results shown in  Figure 4 . While both variants outperform the partially trained policy, we find that value penalty performs slightly better than policy regularization in most cases. We consistently observed this advantage with other divergence choices (see Appendix Figure 8 for a full comparison).

Section Title: DIVERGENCES FOR REGULARIZATION
  DIVERGENCES FOR REGULARIZATION We evaluated four choices of divergences used as the regularizer D: (a) MMD (as in BEAR), (b) KL in the primal form with estimated behavior policy (as in KL-control), and (c) KL and (d) Wasserstein in their dual forms without estimating a behavior policy. As shown in  Figure 5 , we do not find any specific divergence performing consistently better or worse than the others. All variants are able to learn a policy that significantly improves over the behavior policy in all cases. In contrast,  Kumar et al. (2019)  argue that sampled MMD is superior to KL based on the idea that it is better to regularize the support of the learned policy distribution to be within the support of the behavior policy rather than forcing the two distributions to be similar. While conceptually reasonable, we do not find support for that argument in our experiments: (i) we find that KL and Wassertein can perform similarly well to MMD even though they are not designed for support matching; (ii) we briefly tried divergences that are explicitly designed for support matching (the relaxed KL and relaxed Wasserstein distances proposed by  Wu et al. (2019) ), but did not observe a clear benefit to the additional complexity. We conjecture that this is because even if one uses noisy or multiple behavior policies to collect data, the noise is reflected more in the diversity of states rather than the diversity of actions on a single state (due to the nature of environment dynamics). However, we expect this support matching vs. distribution matching distinction may matter in other scenarios such as smaller state spaces or contextual bandits, which is a potential direction for future work.

Section Title: COMPARISON TO BCQ AND OTHER BASELINES
  COMPARISON TO BCQ AND OTHER BASELINES We now compare one of our best performing algorithms so far, kl_vp (value penalty with KL divergence in the primal form), to BCQ, BEAR, and two other baselines: vanilla SAC (which uses adaptive entropy regularization) and behavior cloning.  Figure 6  shows the comparison. We find that vanilla SAC only works in the HalfCheetah environment and fails in the other three environments. Behavior cloning never learns a better policy than the partially trained policy used to collect the data. Although BCQ consistently learns a policy that is better than the partially trained policy, its performance is always clearly worse than kl_vp (and other variants whose performance is similar to kl_vp, according to our previous experiments). We conclude that BCQ is less favorable than explicitly Under review as a conference paper at ICLR 2020 using a divergence for behavior regularization (BEAR and kl_vp). Although, tuning additional hyperparameters beyond Φ for BCQ may improve performance.

Section Title: HYPERPARAMETER SENSITIVITY
  HYPERPARAMETER SENSITIVITY In our experiments, we find that many simple algorithmic designs achieve good performance under the framework of BRAC. For example, all of the 4 divergences we tried perform similarly well when used for regularization. In these experiments, we allowed for appropriate hyperparameter tuning over policy learning rate and regularization weight, as we initially found that not doing so can lead to premature and incorrect conclusions.  2  However, some design choices may be more robust to hyperparameters than others. To investigate this, we also analyzed the sensitivity to hyperparameters for all algorithmic variants (Appendix Figures 9 and 10). To summarize, we found that (i) MMD and KL Divergence are similar in terms of sensitivity to hyperparameters, (ii) using the dual form of divergences (e.g. KL dual, Wasserstein) appears to be more sensitive to hyperparameters, possibly because of the more complex training procedure (optimizing a minimax objective), and (iii) value penalty is slightly more sensitive to hyperparameters than policy regularization despite its more favorable performance under the best hyperparameters.

Section Title: CONCLUSION
  CONCLUSION In this work, we introduced behavior regularized actor critic (BRAC), an algorithmic framework, which generalizes existing approaches to solve the offline RL problem by regularizing to the behavior policy. In our experiments, we showed that many sophisticated training techniques, such as weighted target Q-value ensembles and adaptive regularization coefficients are not necessary in order to achieve state-of-the-art performance. We found that the use of value penalty is slightly better than policy regularization, while many possible divergences (KL, MMD, Wasserstein) can achieve similar performance. Perhaps the most important differentiator in these offline settings is whether proper hyperparameters are used. Although some variants of BRAC are more robust to hyperparameters than others, every variant relies on a suitable set of hyperparameters to train well. Off-policy evaluation without interacting with the environment is a challenging open problem. While previous off-policy evaluation work focuses on reducing mean-squared-error to the expected return, in our problem, we only require a ranking of policies. This relaxation may allow novel solutions, and we encourage more researchers to investigate this direction in the pursuit of truly offline RL. Another potential direction is to look at the situations when the dataset is much smaller. Our preliminary observations on smaller datasets is that it is hard to get a hyperparameter that works consistently well on multiple runs with different random seeds. So we conjecture that smaller datasets may need either more careful hyperparameter search or (more interestingly) a better algorithm. We leave an extensive study of this setting to future work.
  For example, taking the optimal hyperparameters from one design choice and then applying them to a different design choice (e.g., MMD vs KL divergence) can lead to incorrect conclusions (specifically, that using KL is worse than using MMD, only because one transferred the hyperparameters used for MMD to KL).

```
