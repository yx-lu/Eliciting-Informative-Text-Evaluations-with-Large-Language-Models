Title:
```
Published as a conference paper at ICLR 2020 LEARNING TO GUIDE RANDOM SEARCH
```
Abstract:
```
We are interested in derivative-free optimization of high-dimensional functions. The sample complexity of existing methods is high and depends on problem dimensionality, unlike the dimensionality-independent rates of first-order meth- ods. The recent success of deep learning suggests that many datasets lie on low-dimensional manifolds that can be represented by deep nonlinear models. We therefore consider derivative-free optimization of a high-dimensional func- tion that lies on a latent low-dimensional manifold. We develop an online learn- ing approach that learns this manifold while performing the optimization. In other words, we jointly learn the manifold and optimize the function. Our anal- ysis suggests that the presented method significantly reduces sample complex- ity. We empirically evaluate the method on continuous optimization benchmarks and high-dimensional continuous control problems. Our method achieves sig- nificantly lower sample complexity than Augmented Random Search, Bayesian optimization, covariance matrix adaptation (CMA-ES), and other derivative-free optimization algorithms.
```

Figures/Tables Captions:
```
Figure 1: Average reward vs. number of episodes for MuJoCo locomotion tasks. In each condition, we perform 5 runs with different random seeds. Shaded areas represent 1 standard deviation. The grey horizontal line indicates the prescribed threshold at which the task is considered 'solved'.
Figure 2: Average reward vs. wall-clock time for MuJoCo locomotion tasks. In each condition, we perform 5 runs with different random seeds. Shaded areas represent 1 standard deviation. The grey horizontal line indicates the prescribed threshold at which the task is considered 'solved'. Measure- ments are performed on Intel Xeon E7-8890 v3 processors and Nvidia GeForce RTX 2080 Ti GPUs. We list the number of cores used for each experiment.
Figure 3: Manifold learning accuracy. We plot 1 T T t=1 ∇ x f (x t ) − P Jq(x t ,θ t ) (∇ x f (x t )) 2 . In order to estimate the gradient, we use GRADEST with a high number of directions.
Figure 4: Performance profiles of our method and baselines on an optimization benchmark.
Figure 5: Effect of problem dimensionality and manifold dimensionality. Average objective value over 10 random seeds vs. number of function evaluations. Shaded areas represent 1 standard devia- tion.
Table 1: Number of episodes required to reach the prescribed threshold on each MuJoCo locomotion task for our method, baselines, and ablations. Lower is better. We average over five random seeds. We denote the number of successful trials as (success/trial) and average over successful trials only. If the number of successful trials is not noted, the method solved the task for all random seeds.
Table 2: Generated airfoils with their lift and drag values after 1500 calls to XFoil (Drela, 1989).
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION A typical approach to machine learning problems is to define an objective function and optimize it over a dataset. First-order optimization methods are widely used for this purpose since they can scale to high-dimensional problems and their convergence rates are independent of problem dimensionality in most cases. However, gradients are not available in many important settings such as control, black-box optimization, and interactive learning with humans in the loop. Derivative- free optimization (DFO) can be used to tackle such problems. The challenge is that the sample complexity of DFO scales poorly with the problem dimensionality. The design of DFO methods that solve high-dimensional problems with low sample complexity is a major open problem. The success of deep learning methods suggests that high-dimensional data that arises in real-world settings can commonly be represented in low-dimensional spaces via learned nonlinear features. In other words, while the problems of interest are high-dimensional, the data typically lies on low- dimensional manifolds. If we could perform the optimization directly in the manifold instead of the full space, intuition suggests that we could reduce the sample complexity of DFO methods since their convergence rates are generally a function of the problem dimensionality ( Nesterov & Spokoiny, 2017 ;  Dvurechensky et al., 2018 ). In this paper, we focus on high-dimensional data distributions that are drawn from low-dimensional manifolds. Since the manifold is typically not known prior to the optimization, we pose the following question. Can we develop an adaptive derivative-free opti- mization algorithm that learns the manifold in an online fashion while performing the optimization? There exist DFO methods that aim to identify a low-dimensional search space ( Maheswaranathan et al., 2019 ;  Choromanski et al., 2019 ). However, they are limited to linear subspaces. In contrast, we propose to use expressive nonlinear models (specifically, neural networks) to represent the mani- fold. Our approach not only increases expressivity but also enables utilization of domain knowledge concerning the geometry of the problem. For example, if the function of interest is known to be translation invariant, convolutional networks can be used to represent the underlying manifold struc- ture. On the other hand, the high expressive power and flexibility brings challenges. Our approach requires solving for the parameters of the nonlinear manifold at each iteration of the optimization. To address this, we develop an efficient online method that learns the underlying manifold while the function is being optimized.

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 We specifically consider random search methods and extend them to the nonlinear manifold learn- ing setting. Random search methods choose a set of random directions and perform perturbations to the current iterate in these directions. Differences of the function values computed at perturbed points are used to compute an estimator for the gradient of the function. We first extend this to random search over a known manifold and show that sampling directions in the tangent space of the manifold provides a similar estimate. We then propose an online learning method that estimates this manifold while jointly performing the optimization. We theoretically analyze sample complex- ity and show that our method reduces it. We conduct extensive experiments on continuous control problems, continuous optimization benchmarks, and gradient-free optimization of an airfoil. The re- sults indicate that our method significantly outperforms state-of-the-art derivative-free optimization algorithms from multiple research communities.

Section Title: PRELIMINARIES
  PRELIMINARIES We are interested in high-dimensional stochastic optimization problems of the form min x∈R d f (x) = E ξ [F (x, ξ)], (1) where x is the optimization variable and f : R d → R is the function of interest, which is de- fined as expectation over a noise variable ξ. We assume that the stochastic function is bounded (|F (x, ξ)| ≤ Ω), L-Lipschitz, and µ-smooth 1 with respect to x for all ξ, and has uniformly bounded variance (E ξ [(F (x, ξ) − f (x)) 2 ] ≤ V F ). In DFO, we have no access to the gradients. Instead, we only have zeroth-order access by evaluating the function F (i.e. sampling F (x, ξ) for the input x). We are specifically interested in random search methods in which an estimate of the gradient is computed using function evaluations at points randomly sampled around the current iterate. Before we formalize this, we introduce some definitions. Denote the d-dimensional unit sphere and unit ball by S d−1 and B d , respectively. We define a smoothed function following  Flaxman et al. (2005) . For a function f : R d → R, its δ-smoothed version isf (x) = E v∼B d [f (x + δv)]. The main workhorse of random search is the following result by  Flaxman et al. (2005) . Let s be a random vector sampled from the uniform distribution over S d−1 . Then f (x + δs)s is an unbiased estimate of the gradient of the smoothed function: We use antithetic samples since this is known to decrease variance ( Kroese et al., 2013 ) and define the final gradient estimator as y(x, s) = (F (x + δs, ξ) − F (x − δs, ξ)) s. Extending (2) to the antithetic case, E ξ,s∈S d−1 [y(x, s)] = 2δ d ∇ xf (x). A simple way to optimize the function of interest is to use the gradient estimate in stochastic gradient descent (SGD), as summarized in Algorithm 1. This method has been analyzed in various forms and its convergence is characterized well for nonconvex smooth functions. We restate the convergence rate and defer the constants and proof to Appendix A.2. Proposition 1 ( Flaxman et al., 2005 ;  Vemula et al., 2019 ). Let f (x) be differentiable, L-Lipschitz, and µ-smooth. Consider running random search (Algorithm 1) for T steps. Let k = 1 for simplicity.

Section Title: ONLINE LEARNING TO GUIDE RANDOM SEARCH
  ONLINE LEARNING TO GUIDE RANDOM SEARCH Proposition 1 implies that the sample complexity of random search scales linearly with the dimen- sionality. This dependency is problematic when the function of interest is high-dimensional. We argue that in many practical problems, the function of interest lies on a low-dimensional nonlinear 7: end procedure manifold. This structural assumption will allow us to significantly reduce the sample complexity of random search, without knowing the manifold a priori. Assume that the function of interest is defined on an n-dimensional manifold (n d) and this manifold can be defined via a nonlinear parametric family (e.g. a neural network). Formally, we are interested in derivative-free optimization of functions with the following properties: • Smoothness: F (·, ξ) : R d → R is µ-smooth and L-Lipschitz for all ξ. • Manifold: F (·, ξ) is defined on an n-dimensional manifold M for all ξ. • Representability: The manifold M and the function of interest can be represented using parametrized function classes r(·; θ) and g(·; ψ). Formally, given ξ, there exist θ and ψ such that F (x, ξ) = g(r(x; θ ); ψ ) ∀x ∈ R d . We will first consider an idealized setting where the manifold is already known (i.e. we know θ ). Then we will extend the developed method to the practical setting where the manifold is not known in advance and must be estimated with no prior knowledge as the optimization progresses.

Section Title: WARM-UP: RANDOM SEARCH OVER A KNOWN MANIFOLD
  WARM-UP: RANDOM SEARCH OVER A KNOWN MANIFOLD If the manifold is known a priori, we can perform random search directly over the manifold instead of the full space. Consider the chain rule applied to g(r(x; θ); ψ) as ∇ x f (x) = J(x; θ )∇ r g(r; ψ), where J(x; θ ) = ∂r(x;θ ) /∂x and r = r(x, θ ). The gradient of the function of interest lies in the column space of the Jacobian of the parametric family. In light of this result, we can perform random search in the column space of the Jacobian, which has lower dimensionality than the full space. For numerical stability, we will first orthonormalize the Jacobian using the Gram-Schmidt proce- dure, and perform the search in the column space of this orthonormal matrix since it spans the same space. We denote the orthonormalized version of J(x; θ ) by J q (x; θ ). In order to perform random search, we sample an n-dimensional vector uniformly (s ∼ S n−1 ) and lift it to the input space via J q (x; θ )s. As a consequence of the manifold Stokes' theorem, using the lifted vector as a random direction gives an unbiased estimate of the gradient of the smoothed function as E ξ,s∈S n−1 [y(x, J q (x; θ )s)] = 2δ n ∇ xfθ (x), (3) where the smoothed function is defined asf θ (x) = Eṽ ∼B n [f (x + δJ q (x; θ )ṽ)]. We show this result as Lemma 1 in Appendix A.1. We use the resulting gradient estimate in SGD. The following proposition summarizes the sample complexity of this method. The constants and the proof are given in Appendix A.2. Proposition 2. Let f (x) be differentiable, L-Lipschitz, and µ-smooth. Consider running manifold random search (Algorithm 2) for T steps. Let k = 1 for simplicity. Then Published as a conference paper at ICLR 2020

Section Title: JOINT OPTIMIZATION AND MANIFOLD LEARNING
  JOINT OPTIMIZATION AND MANIFOLD LEARNING When n d, the reduction in the sample complexity of random search (summarized in Proposi- tion 2) is significant. However, the setting of Algorithm 2 and Proposition 2 is impractical since the manifold is generally not known a priori. We thus propose to minimize the function and learn the manifold jointly. In other words, we start with an initial guess of the parameters and solve for them at each iteration using all function evaluations that have been performed so far. Our major objective is to improve the sample efficiency of random search. Hence, minimizing the sample complexity with respect to manifold parameters is an intuitive way to approach the problem. We analyze the sample complexity of SGD using biased gradients in Appendix A.3.1 and show the following informal result. Consider running manifold random search with a sequence of manifold parameters θ 1 , ψ 1 , . . . , θ T , ψ T for T steps. Then the additional suboptimality caused by biased gradients, defined as SUBOPTIMALITY = 1 T T t=1 E[∇ x f (x)], is bounded as follows: where SUBOPTIMALITY(θ , ψ ) is the suboptimality of the oracle case (Algorithm 2). Our aim is to minimize the additional suboptimality with respect to θ t and ψ t . However, we do not have access to ∇ x f (x) since we are in a derivative-free setting. Hence we cannot directly minimize (4). At each iteration, we observe y(x t , s t ). Moreover, y(x t , s t ) = 2δs t ∇ xF (x t , ξ) + O(δ 2 ), due to the smoothness. Since we observe the projection of the gradient onto the chosen directions, we minimize the projection of (4) onto these directions. Formally, we define our one-step loss as We use the Follow the Regularized Leader (FTRL) algorithm ( Hazan, 2016 ;  Shalev-Shwartz, 2012 ) to minimize the aforementioned loss function and learn the manifold parameters: θ t+1 , ψ t+1 = arg min θ,ψ t i=1 L(x i , s i , θ, ψ) + λR(θ, ψ), (6) where the regularizer R(θ, ψ) = ∇ x g(r(x t ; θ t ); ψ t ) − ∇ x g(r(x t ; θ); ψ) 2 is a temporal smooth- ness term that penalizes sudden changes in the gradient estimates. Algorithm 3 summarizes our algorithm. We add exploration by sampling a mix of directions from the manifold and the full space. In each iteration, we sample directions and produce two gradient estimates g m , g e using the samples from the tangent space and the full space, respectively. We mix them to obtain the final estimate g = (1 − β)g m + βg e . We discuss the implementation details of the FTRL step in Section 4. In our theoretical analysis, we assume that (6) can be solved optimally. Although this is a strong assumption, experimental results suggest that neural networks can easily fit any training data ( Zhang et al., 2017 ). Our experiments also support this observation. Theorem 1 states our main result concerning the sample complexity of our method. As expected, the sample complexity includes both the input dimensionality d and the manifold dimensionality n. On the other hand, the sample complexity only depends on n √ d rather than d. Thus our method significantly decreases sample complexity when n d. Theorem 1. Let f (x) be bounded, L-Lipschitz, and µ-smooth. Consider running learned manifold random search (Algorithm 3) for T steps. Let k e = 1 and k m = 1 for simplicity. Then

Section Title: Proof sketch
  Proof sketch The empirical loss we minimize is the projection of (4) onto randomly chosen directions. Next, we show that the expectation of the empirical loss is (4) when the directions are chosen uniformly at random from the unit sphere: A crucial argument in our analysis is the concentration of the empirical loss around its expectation. In order to study this concentration, we use Freedman's inequality ( Freedman, 1975 ), inspired by the analysis of generalization in online learning by  Kakade & Tewari (2009) . Our analysis bounds the difference Next, we use the FTL-BTL Lemma ( Kalai & Vempala, 2005 ) to analyze the empirical loss T t=1 L t . We bound the empirical loss in terms of the distances between the iterates T t=1 x t+1 − x t 2 . Such a bound would not be useful in an adversarial setting since the adversary chooses x t , but we set appropriate step sizes, which yield sufficiently small steps and facilitate convergence. Our analysis of learning requires the directions in (7) to be sampled from a unit sphere. On the other hand, our optimization method requires directions to be chosen from the tangent space of the manifold. We mix exploration (directions sampled from S d−1 ) and exploitation (directions sampled from the tangent space of the manifold) to address this mismatch. We show that mixing weight β = 1 /d yields both fast optimization and no-regret learning. Finally, we combine the analyses of empirical loss, concentration, and SGD to obtain the statement of the theorem.

Section Title: IMPLEMENTATION DETAILS AND LIMITATIONS
  IMPLEMENTATION DETAILS AND LIMITATIONS We summarize important details here and elaborate further in Appendix B. A full implementation is available at https://github.com/intel-isl/LMRS.

Section Title: Parametric family
  Parametric family We use multilayer perceptrons with ReLU nonlinearities to define g and r. We initialize our models with standard normal distributions. Our method thus starts with random search at initialization and transitions to manifold random search as the learning progresses. Solving FTRL. Results on training deep networks suggest that local SGD-based methods perform well. We thus use SGD with momentum as a solver for FTRL in (6). We do not solve each learning problem from scratch but initialize with the previous solution. Since this process may be vulnerable to local optima, we fully solve (6) from scratch for every 100 th iteration of the method.

Section Title: Computational complexity
  Computational complexity Our method increases the amount of computation since we need to learn a model while performing the optimization. However, in DFO, the major computational bot- tleneck is typically the function evaluation. When efficiently implemented on a GPU, the time spent on learning the manifold is negligible in comparison to function evaluations.

Section Title: Parallelization
  Parallelization Random search is highly parallelizable since directions can be processed independently. Communication costs include i) sending the current iterate to work- ers, ii) sending directions to each corresponding worker, and iii) workers sending the function values back. When the directions are chosen independently, they can be indi- cated to each worker via a single integer by first creating a shared noise table in pre- processing. For a d-dimensional problem with k random directions, these costs are d, k, and k, respectively. The total communication cost is therefore d + 2k. In our method, each worker also needs a copy of the Jacobian, resulting in a communication cost of d + 2k + kd. Hence our method increases commu- nication cost from d + 2k to d + 2k + kd. See Algorithms 1 & 2 for definitions of GRADEST and MANIFOLDGRADEST.

Section Title: EXPERIMENTS
  EXPERIMENTS We empirically evaluate the presented method (referred to as Learned Manifold Random Search (LMRS)) on the following sets of problems. i) We use the MuJoCo simulator ( Todorov et al., 2012 ) to evaluate our method on high-dimensional control problems. ii) We use 46 single-objective un- constrained functions from the Pagmo suite of continuous optimization benchmarks ( Biscani et al., 2019 ). iii) We use the XFoil simulator ( Drela, 1989 ) to benchmark gradient-free optimization of an airfoil. We consider the following baselines. i) Augmented Random Search (ARS): Random search with all the augmentations from  Mania et al. (2018) . ii) Guided ES ( Maheswaranathan et al., 2019 ): A method to guide random search by adapting the covariance matrix. iii) CMA-ES ( Hansen, 2016 ): Adaptive derivative-free optimization based on evolutionary search. iv) REMBO ( Wang et al., 2016 ): A Bayesian optimization method which uses random embeddings in order to scale to high-dimensional problems. Although CMA-ES and REMBO are not based on random search, we include them for the sake of completeness. Additional implementation details are provided in Appendix B.

Section Title: LEARNING CONTINUOUS CONTROL
  LEARNING CONTINUOUS CONTROL Following the setup of  Mania et al. (2018) , we use random search to learn control of highly articu- lated systems. The MuJoCo locomotion suite ( Todorov et al., 2012 ) includes six problems of varying difficulty. We evaluate our method and the baselines on all of them. We use linear policies and in- clude all the tricks (whitening the observation space and scaling the step size using the variance of the rewards) from  Mania et al. (2018) . We report average reward over five random experiments versus the number of episodes (i.e. number of function evaluations) in  Figure 1 . We also report the average number of episodes required to reach the prescribed reward threshold at which the task is considered 'solved' in  Table 1 . We include proximal policy optimization (PPO) ( Schulman et al., 2017 ;  Hill et al., 2018 ) for reference. Note that our results are slightly different from the numbers reported by  Mania et al. (2018)  as we use 5 random seeds instead of 3. The results suggest that our method improves upon ARS in all environments. Our method also outperforms all other baselines. The improvement is particularly significant for high-dimensional problems such as Humanoid. Our method is at least twice as efficient as ARS in all environments except Swimmer, which is the only low-dimensional problem in the suite. Interestingly, Guided-ES fails to solve the Humanoid task, which we think is due to biased gradient estimation. Furthermore, CMA-ES performs similarly to ARS. These results suggest that a challenging task like Humanoid is out of reach for heuristics like local adaptation of the covariance matrix due to high stochasticity and nonconvexity. REMBO only solves the Swimmer task and fails to solve others. We believe this is due to the fact that these continuous control problems have no global structure and are highly nonsmooth. The number of possible sets of contacts with the environment is combinatorial in the number of joints, and each contact configuration yields a distinct reward surface. This contradicts the global structure assumption in Bayesian optimization.

Section Title: Wall-clock time analysis
  Wall-clock time analysis Our method performs additional computation as we learn the underlying manifold. In order to quantify the effect of the additional computation, we perform wall-clock time analysis and plot average reward vs wall-clock time in  Figure 2 . Our method outperforms all baselines with similar margins to  Figure 1 . The trends and shapes of the curves in  Figures 1  and 2 are similar. This is not surprising since computation requirements of all the optimizers are rather negligible when compared with the simulation time of MuJoCo. The only major differences we notice are on the Hopper task. Here the margin between our method and the baselines narrows and the relative ordering of Guided-ES and ARS changes. This is due to the fact that simulation stops when the agent falls. In other words, the simulation time depends on the current solution. Methods that query the simulator for these unstable solutions lose less wall-clock time.

Section Title: Quantifying manifold learning performance
  Quantifying manifold learning performance In order to evaluate the learning performance, we project the gradient of the function to the tangent space of the learned manifold and plot the norm of the residual. Since we do not have access to the gradients, we estimate them at 30 time instants, evenly distributed through the learning process. We perform accurate gradient estimation using a very large number of directions (2000). We compute the norm of the residual of the projection as 1 T T t=1 ∇ x f (x t ) − P Jq(x t ,θ t ) (∇ x f (x t )) 2 , where P A (·) is projection onto the column space of A. The results are visualized in  Figure 3 . Our method successfully and quickly learns the manifold in all cases.

Section Title: Ablation studies
  Ablation studies Our method uses three major ideas. i) We learn a manifold that the function lies on. ii) We learn this manifold in an online fashion. iii) We perform random search on the learned manifold. To study the impact of each of these ideas, we perform the following exper- iments. i) No learning. We randomly initialize the manifold r(·; θ) by sampling the entries of θ from the standard normal distribution. Then we perform random search on this random mani- fold. ii) No online learning. We collect an of- fline training dataset by sampling x i values uni- formly at random from a range that includes the optimal solutions. We evaluate function values at sampled points and learn the manifold. We perform random search on this manifold without updating the manifold model. iii) No search. We use the gradients of the estimated function (∇ x g(r(x; θ t )ψ t )) as surrogate gradients and minimize the function of interest using first-order methods. We list the results in  Table 1 . We do not include the no-search baseline since it fails to solve any of the tasks. Failure of the no-search baseline suggests that the estimated functions are powerful enough to guide the search, but not accurate enough for optimization. The no-learning baseline outperforms ARS on the simplest problem (Swimmer), but either fails completely or increases sample complexity on other problems, suggesting that random features are not effective, especially on high-dimensional problems. Although the offline learning baseline solves more tasks than the no-learning one, it has worse sample complexity since initial offline sampling is expensive. This study indicates that all three of the ideas that underpin our method are important.

Section Title: CONTINUOUS OPTIMIZATION BENCHMARKS
  CONTINUOUS OPTIMIZATION BENCHMARKS We use continuous optimization problems from the Pagmo problem suite ( Biscani et al., 2019 ). This benchmark includes minimization of 46 functions such as Rastrigin, Rosenbrock, Schwe- fel, etc. (See Appendix B for the complete list.) We use ten random starting points and re- port the average number of function evaluations required to reach a stationary point.  Figure 4  reports the results as performance profiles ( Dolan & Moré, 2002 ). Performance profiles rep- resent how frequently a method is within distance τ of optimality. Specifically, if we de- note the number of function evaluations that method m requires to solve problem p by T m (p) and the number of function evaluations used by the best method by T (p) = min m T m (p), the performance profile is the fraction of problems for which method m is within distance τ of the best: 1 /Np p 1[T m (p) − T (p) ≤ τ ], where 1[·] is the indicator function and N p Fraction of problems (%) LMRS ARS Guided ES CMA-ES REMBO is the number of problems. As can be seen in  Figure 4 , our method out- performs all baselines. The success of our method is not surprising since the functions are typically defined as nonconvex functions of some statistics, inducing manifold structure by construction. REMBO (Bayesian optimiza- tion) is close to our method and outperforms the other baselines. We believe this is due to the global geometric structure of the consid- ered functions. Both CMA-ES and Guided-ES outperform ARS.

Section Title: OPTIMIZATION OF AN AIRFOIL
  OPTIMIZATION OF AN AIRFOIL We apply our method to gradient-free opti- mization of a 2D airfoil. We use a computa- tional fluid dynamics (CFD) simulator, XFoil ( Drela, 1989 ), which can simulate an airfoil using its contour plot. We parametrize the airfoils using smooth polynomials of up to 36 degrees. We model the upper and lower parts of the airfoil with different polynomials. The dimensionality of the problem is thus 72. XFoil can simulate various viscosity properties, speeds, and angles of attack. The details are discussed in Appendix B. We plot the resulting airfoil after 1500 simulator calls in  Table 2 . We also report the lift and drag of the resulting shape. The objective we optimize is LIFT − DRAG.  Table 2  suggests that all methods find airfoils that can fly (LIFT > DRAG). Our method yields the highest LIFT − DRAG. Bayesian optimization outperforms the other baselines.

Section Title: EFFECT OF MANIFOLD AND PROBLEM DIMENSIONALITY
  EFFECT OF MANIFOLD AND PROBLEM DIMENSIONALITY In this section, we perform a controlled experiment to understand the effect of problem dimension- ality (d) and manifold dimensionality (n). We generate a collection of synthetic optimization prob- lems. All synthesized functions follow the manifold hypothesis: f (x) = g(r(x, θ )), where r(x, θ ) is a multilayer perceptron with the architecture Linear(d, 2n) → ReLU → Linear(2n, n) and g(·) is a randomly sampled convex quadratic function. In order to sample a convex quadratic function, we sample the parameters of the quadratic function from a Gaussian distribution and project the result to the space of convex quadratic functions. We choose d ∈ {100, 1000} and plot the objective value with respect to the number of function evaluations for various manifold dimensionalities n in  Figure 5 . The results suggest that for a given ambient dimensionality d, the lower the dimensionality of the data manifold n, the more sample- efficient our method. In concordance with our theoretical analysis, the improvement is very signifi- cant when n d, as can be seen in the cases n = 5, d = 1000 and n = 2, d = 100. Interestingly, our method is effective even when the manifold assumption is violated (n = d). We hypothesize that this is due to anisotropy in the geometry of the problem. Although all directions are important when n = d, some will result in faster search since the function changes more along them. It appears that our method can identify these direction and thus accelerate the search.

Section Title: RELATED WORK
  RELATED WORK

Section Title: Derivative-free optimization
  Derivative-free optimization We summarize the work on DFO that is relevant to our paper. For a complete review, readers are referred to  Custódio et al. (2017)  and  Conn et al. (2009) . We are specif- ically interested in random search methods, which have been developed as early as  Matyas (1965)  and  Rechenberg (1973) . Convergence properties of these methods have recently been analyzed by  Agarwal et al. (2010) ,  Bach & Perchet (2016) ,  Nesterov & Spokoiny (2017) , and  Dvurechensky et al. (2018) . A lower bound on the sample complexity for the convex case has been given by  Duchi et al. (2015)  and  Jamieson et al. (2012) . Bandit convex optimization is also highly relevant and we utilize the work of  Flaxman et al. (2005)  and  Shamir (2013) .

Section Title: Random search for learning continuous control
  Random search for learning continuous control Learning continuous control is an active research topic that has received significant interest in the reinforcement learning community. Recently,  Sali- mans et al. (2017)  and  Mania et al. (2018)  have shown that random search methods are competitive with state-of-the-art policy gradient algorithms in this setting.  Vemula et al. (2019)  analyzed this phenomenon theoretically and characterized the sample complexity of random search and policy gradient methods for continuous control.

Section Title: Adaptive random search
  Adaptive random search There are various methods in the literature that adapt the search space by using anisotropic covariance as in the case of CMA-ES ( Hansen et al., 2003 ;  Hansen, 2016 ), guided evolutionary search ( Maheswaranathan et al., 2019 ), and active subspace methods ( Choromanski et al., 2019 ). There are also methods that enforce structure such as orthogonality in the search directions ( Choromanski et al., 2018 ). Other methods use information geometry tools as in  Wierstra et al. (2014)  and  Glasmachers et al. (2010) .  Lehman et al. (2018)  use gradient magnitudes to guide neuro-evolutionary search.  Staines & Barber (2012)  use a variational lower bound to guide the search. In contrast to these methods, we explicitly posit nonlinear manifold structure and directly learn this latent manifold via online learning. Our method is the only one that can learn an arbitrary nonlinear search space given a parametric class that characterizes its geometry.

Section Title: Adaptive Bayesian optimization
  Adaptive Bayesian optimization Bayesian optimization (BO) is another approach to zeroth-order optimization with desirable theoretical properties ( Srinivas et al., 2010 ). Although we are only interested in methods based on random search, some of the ideas we use have been utilized in BO.  Calandra et al. (2016)  used the manifold assumption for Gaussian processes. In contrast to our method, they use autoencoders for learning the manifold and assume initial availability of offline data. Similarly,  Djolonga et al. (2013)  consider the case where the function of interest lies on some linear manifold and collect offline data to identify this manifold. In contrast, we only use online information and our models are nonlinear.  Wang et al. (2016)  and  Kirschner et al. (2019)  propose using random low-dimensional features instead of adaptation.  Rolland et al. (2018)  design adaptive BO methods for additive models. Major distinctions between our work and the adaptive BO literature include our use of nonlinear manifolds, no reliance on offline data collection, and formulation of the problem as online learning.

Section Title: CONCLUSION
  CONCLUSION We presented Learned Manifold Random Search (LMRS): a derivative-free optimization algorithm. Our algorithm learns the underlying geometric structure of the problem online while performing the optimization. Our experiments suggest that LMRS is effective on a wide range of problems and significantly outperforms prior derivative-free optimization algorithms from multiple research communities.

```
