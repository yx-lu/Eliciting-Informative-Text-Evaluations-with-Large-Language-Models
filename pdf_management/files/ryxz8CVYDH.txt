Title:
```
Published as a conference paper at ICLR 2020 LEARNING TO LEARN BY ZEROTH-ORDER ORACLE
```
Abstract:
```
In the learning to learn (L2L) framework, we cast the design of optimization algo- rithms as a machine learning problem and use deep neural networks to learn the update rules. In this paper, we extend the L2L framework to zeroth-order (ZO) op- timization setting, where no explicit gradient information is available. Our learned optimizer, modeled as recurrent neural networks (RNNs), first approximates gra- dient by ZO gradient estimator and then produces parameter update utilizing the knowledge of previous iterations. To reduce the high variance effect due to ZO gradient estimator, we further introduce another RNN to learn the Gaussian sam- pling rule and dynamically guide the query direction sampling. Our learned op- timizer outperforms hand-designed algorithms in terms of convergence rate and final solution on both synthetic and practical ZO optimization problems (in partic- ular, the black-box adversarial attack task, which is one of the most widely used applications of ZO optimization). We finally conduct extensive analytical experi- ments to demonstrate the effectiveness of our proposed optimizer. 1
```

Figures/Tables Captions:
```
Figure 1: Model architecture of our proposed optimizer. All the operations are applied coordinate- wisely except querying ZO Oracle to obtain ZO gradient estimator (equation 1). Each coordinate shares the QueryRNN and the UpdateRNN parameters but maintains its own hidden state.
Figure 2: (a)-(b) & (d)-(e): Black-box attack loss versus iterations on selected test images. The loss curves are averaged over 10 independent random trails and the shaded areas indicate the standard deviation. (c) & (f): Black-box attack loss curves averaged over all 100 test images. Attack on each image is run for 10 trails. On CIFAR-10 attack task, we also test the performance of the learned optimizer trained on MINST attack task with finetuning (ZO-LSTM-finetune, which will be introduced in Section 4.3).
Figure 3: Optimization performance comparison on synthetic binary classification problem. Each line is averaged over 10 test datasets with random initialization. (a): Training loss against iterations. ZO-LSTM-finetune denotes the learned optimizer trained on the MNIST attack task and fintuned on the binary classification task (see Section 4.3). (b)-(d): Effects of query direction number q, batch size b, and problem dimension d, respectively.
Figure 4: Analytical experiments demonstrating the effectiveness of our proposed optimizer. (a)- (c): Ablation study on MNIST attack task, CIFAR-10 attack task, and binary classification task respectively. For MINST and CIFAR-10 attack task, We average the loss curve over all 100 test images and attack on each image is run for 10 independent trails (see Appendix A.4 for additional plots on single test images). (d): Evaluation of average cosine similarity between ZO gradient estimator and ground-truth gradient with and without the QueryRNN. (e): Optimization trajectory of one coordinate when applying ZO-LSTM on MNIST attack task. In the bottom figure, we apply ZO-SGD and ZO-ADAM to the same optimization trajectory as ZO-LSTM, i.e., assume they use the same ZO gradient estimator at each iteration but produce different parameter updates.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Learning to learn (L2L) is a recently proposed meta-learning framework where we leverage deep neural networks to learn optimization algorithms automatically. The most common choice for the learned optimizer is recurrent neural network (RNN) since it can capture long-term dependencies and propose parameter updates based on knowledge of previous iterations. By training RNN opti- mizers on predefined optimization problems, the optimizers are capable of learning to explore the loss landscape and adaptively choose descent directions and steps (Lv et al., 2017). Recent works ( Andrychowicz et al., 2016 ;  Wichrowska et al., 2017 ; Lv et al., 2017) have shown promising results that these learned optimizers can often outperform widely used hand-designed algorithms such as SGD, RMSProp, ADAM, etc. Despite great prospects in this field, almost all previous learned op- timizers are gradient-based, which cannot be applied to solve optimization problems where explicit gradients are difficult or infeasible to obtain. Such problems mentioned above are called zeroth-order (ZO) optimization problems, where the optimizer is only provided with function values (zeroth-order information) rather than explicit gra- dients (first-order information). They are attracting increasing attention for solving ML problems in the black-box setting or when computing gradients is too expensive ( Liu et al., 2018a ). Recently, one of the most important applications of ZO optimization is the black-box adversarial attack to well- trained deep neural networks, since in practice only input-output correspondence of targeted models rather than internal model information is accessible ( Papernot et al., 2017 ;  Chen et al., 2017a ). Although ZO optimization is popular for solving ML problems, the performance of existing algo- rithms is barely satisfactory. The basic idea behind these algorithms is to approximate gradients via ZO oracle ( Nesterov & Spokoiny, 2017 ;  Ghadimi & Lan, 2013 ). Given the loss function f with its parameter θ to be optimized (called the optimizee), we can obtain its ZO gradient estimator by: Published as a conference paper at ICLR 2020 where µ is the smoothing parameter, {u i } are random query directions drawn from standard Gaus- sian distribution ( Nesterov & Spokoiny, 2017 ) and q is the number of sampled query directions. However, the high variance of ZO gradient estimator which results from both random query direc- tions and random samples (in stochastic setting) hampers the convergence rate of current ZO algo- rithms. Typically, as problem dimension d increases, these ZO algorithms suffer from increasing iteration complexity by a small polynomial of d to explore the higher dimensional query space. In this paper, we propose to learn a zeroth-order optimizer. Instead of designing variance reduced and faster converging algorithms by hand as in  Liu et al. (2018a ;b), we replace parameter update rule as well as guided sampling rule for query directions with learned recurrent neural networks (RNNs). The main contributions of this paper are summarized as follows: • We extend the L2L framework to ZO optimization setting and propose to use RNN to learn ZO update rules automatically. Our learned optimizer contributes to faster convergence and lower final loss compared with hand-designed ZO algorithms. • Instead of using standard Gaussian sampling for random query directions as in traditional ZO algorithms, we propose to learn the Gaussian sampling rule and adaptively modify the search distribution. We use another RNN to adapt the variance of random Gaussian sam- pling. This new technique helps the optimizer to automatically sample on a more important search space and thus results in a more accurate gradient estimator at each iteration. • Our learned optimizer leads to significant improvement on some ZO optimization tasks (especially the black-box adversarial attack task). We also conduct extensive experiments to analyze the effectiveness of our learned optimizer.

Section Title: RELATED WORK
  RELATED WORK

Section Title: Learning to learn (L2L)
  Learning to learn (L2L) In the L2L framework, the design of optimization algorithms is cast as a learning problem and deep neural network is used to learn the update rule automatically. In  Cotter & Conwell (1990) , early attempts were made to model adaptive learning algorithms as recurrent neu- ral network (RNN) and were further developed in  Younger et al. (2001)  where RNN was trained to optimize simple convex functions. Recently,  Andrychowicz et al. (2016)  proposed a coordinatewise LSTM optimizer model to learn the parameter update rule tailored to a particular class of optimiza- tion problems and showed the learned optimizer could be applied to train deep neural networks. In  Wichrowska et al. (2017)  and  Lv et al. (2017) , several elaborate designs were proposed to improve the generalization and scalability of learned optimizers.  Li & Malik (2016)  and  Li & Malik (2017)  took a reinforcement learning (RL) perspective and used policy search to learn the optimization al- gorithms (viewed as RL policies). However, most previous learned optimizers rely on first-order information and use explicit gradients to produce parameter updates, which is not applicable when explicit gradients are not available. In this paper, we aim to learn an optimizer for ZO optimization problems. The most relevant work to ours is  Chen et al. (2017b) . In this work, the authors proposed to learn a global black-box (zeroth-order) optimizer which takes as inputs current query point and function value and outputs the next query point. Although the learned optimizer achieves comparable performance with tradi- tional Bayesian optimization algorithms on some black-box optimization tasks, it has several crucial drawbacks. As is pointed out in their paper, the learned optimizer scales poorly with long training steps and is specialized to a fixed problem dimension. Furthermore, it is not suitable for solving black-box optimization problems of high dimensions.

Section Title: Zeroth-order (ZO) optimization
  Zeroth-order (ZO) optimization The most common method of ZO optimization is to approx- imate gradient by ZO gradient estimator. Existing ZO optimization algorithms include ZO-SGD ( Ghadimi & Lan, 2013 ), ZO-SCD ( Lian et al., 2016 ), ZO-signSGD ( Liu et al., 2019 ), ZO-ADAM ( Chen et al., 2017a ), etc. These algorithms suffer from high variance of ZO gradient estimator and typically increase the iteration complexity of their first-order counterparts by a small-degree polyno- mial of problem dimension d. To tackle this problem, several variance reduced and faster converging algorithms were proposed. ZO-SVRG ( Liu et al., 2018b ) reduced the variance of random samples by dividing optimization steps into several epochs and maintaining a snapshot point at each epoch whose gradient was estimated using a larger or the full batch. And the snapshot point served as a reference in building a modified stochastic gradient estimate at each inner iteration. ZO-SZVR-G Published as a conference paper at ICLR 2020 ( Liu et al., 2018a ) adopted a similar strategy and extended to reduce the variance of both random samples and random query directions. But these methods reduce the variance at the cost of higher query complexity. In this paper, we avoid laborious hand design of these algorithms and aim to learn ZO optimization algorithms automatically.

Section Title: METHOD
  METHOD

Section Title: MODEL ARCHITECTURE
  MODEL ARCHITECTURE Our proposed RNN optimizer consists of three main parts: UpdateRNN, Guided ZO Oracle, and QueryRNN, as shown in  Figure 1 .

Section Title: UpdateRNN
  UpdateRNN The function of the UpdateRNN is to learn the parameter update rule of ZO opti- mization. Following the idea in  Andrychowicz et al. (2016) , we use coordinatewise LSTM to model the UpdateRNN. Each coordinate of the optimizee shares the same network but maintains its own separate hidden state, which means that different parameters are optimized using the same update rule based on their own knowledge of previous iterations. Different from previous design in the first-order setting, UpdateRNN takes as input ZO gradient estimator in equation 1 rather than exact gradient and outputs parameter update for each coordinate. Thus the parameter update rule is: θ t = θ t−1 + UpdateRNN(∇f (θ t )) (2) where θ t is the optimizee parameter at iteration t. Besides learning to adaptively compute parameter updates by exploring the loss landscape, the UpdateRNN can also reduce negative effects caused by the high variance of ZO gradient estimator due to its long-term dependency.

Section Title: Guided ZO Oracle
  Guided ZO Oracle In current ZO optimization approaches, ZO gradient estimator is computed by finite difference along the query direction which is randomly sampled from multivariate standard Gaussian distribution. But this estimate suffers from high variance and leads to poor convergence rate when applied to optimize problems of high dimensions ( Duchi et al., 2015 ). To tackle this prob- lem, we propose to use some prior knowledge learned from previous iterates during optimization to guide the random query direction search and adaptively modify the search distribution. Specifically, at iteration t, we use N (0, Σ t ) to sample query directions (Σ t is produced by the QueryRNN which is introduced later) and then obtain ZO gradient estimator along sampled directions via ZO Oracle (equation 1). The learned adaptive sampling strategy will automatically identify important sampling space which leads to a more accurate gradient estimator under a fixed query budget, thus further increases the convergence rate in ZO optimization tasks. For example, in the black-box adversarial attack task, there is usually a clear important subspace for successful attack, and sampling directions from that subspace will lead to much faster convergence. This idea is similar to that of search distri- bution augmentation techniques for evolutionary strategies (ES) such as Natural ES ( Wierstra et al., 2008 ), CMA-ES ( Hansen, 2016 ) and Guided ES ( Maheswaranathan et al., 2018 ). However, these methods explicitly define the sampling rule whereas we propose to learn the Gaussian sampling rule (i.e., the adaption of covariance matrix Σ t ) in an automatic manner.

Section Title: QueryRNN
  QueryRNN We propose to use another LSTM network called QueryRNN to learn the Gaussian sampling rule and dynamically predict the covariance matrix Σ t . We assume Σ t is diagonal so that it could be predicted in a coordinatewise manner as in the UpdateRNN and the learned QueryRNN is invariant to the dimension of optimizee parameter. It takes as input ZO gradient estimator and pa- rameter update at last iterate (which could be viewed as surrogate gradient information) and outputs the sampling variance coordinatewisely, which can be written as: The intuition is that if estimated gradients or parameter updates of previous iterates are biased toward a certain direction, then we can probably increase the sampling probability toward that direction. Using predicted covariance Σ t to sample query directions increases the bias of estimated gradient and reduces the variance, which leads to a tradeoff between bias and variance. The reduction of variance contributes to faster convergence, but too much bias tends to make the learned optimizer stuck at bad local optima (See more illustrations in Appendix C.3). To balance the bias and variance, at test time we randomly use the covariance of standard Gaussian distribution I d and the predicted covariance Σ t as the input of Guided ZO Oracle: Σ t = XΣ t + (1 − X)I d where X ∼ Ber(p) is a Bernoulli random variable that trades off between bias and variance. Note that the norm of the sampling covariance Σ t may not equal to that of standard Gaussian sampling covariance I d , which makes the expectation of the sampled query direction norm u change. To keep the norm of query direction invariant, we then normalize the norm of Σ t to the norm of I d .

Section Title: OBJECTIVE FUNCTION
  OBJECTIVE FUNCTION The objective function of training our proposed optimizer can be written as follows: L(φ) = T t=1 ω t f (θ t (φ)) + λ Σ t (φ) − I d 2 (4) where φ is the parameter of the optimizer including both the UpdateRNN and the QueryRNN, θ t is updated by the optimizer (equation 2) and thus determined by φ, T is the horizon of the optimization trajectory and {ω t } are predefined weights associated with each time step t. The objective function consists of two terms. The first one is the weighted sum of the optimizee loss values at each time step. We use linearly increasing weight (i.e., ω t = t) to force the learned optimizer to attach greater importance to the final loss rather than focus on the initial optimization stage. The second one is the regularization term of predicted Gaussian sampling covariance Σ t with regularization parameter λ. This term prevents the QueryRNN from predicting too big or too small variance value.

Section Title: TRAINING THE LEARNED OPTIMIZER
  TRAINING THE LEARNED OPTIMIZER In experiments, we do not train the UpdateRNN and the QueryRNN jointly for the sake of stability. Instead, we first train the UpdateRNN using standard Gaussian random vectors as query directions. Then we freeze the parameters of the UpdateRNN and train the QueryRNN separately. Both two modules are trained by truncated Backpropagation Through Time (BPTT) and using the same ob- jective function in equation 4. In order to backpropagate through the random Gaussian sampling module to train the QueryRNN, we use the reparameterization trick ( Kingma & Welling, 2013 ) to generate random query directions. Specifically, to generate query direction u ∼ N (0, Σ t ), we first sample standard Gaussian vector z ∼ N (0, I d ), and then apply the reparameterization u = Σ 1/2 t z. To train the optimizer, we first need to take derivatives of the optimizee loss function w.r.t. the opti- mizee parameters, and then backpropagate to the optimizer parameters by unrolling the optimziation steps. However, the gradient information of the optimizee is not available in zeroth-order setting. In order to obtain the derivatives, we can follow the assumption in  Chen et al. (2017b)  that we could get the gradient information of the optimizee loss function at training time, and this information is not needed at test time. However, this assumption cannot hold when the gradient of optimizee loss func- tion is not available neither at training time. In this situation, we propose to approximate the gradient of the optimizee loss function w.r.t its parameter using coordinatewise ZO gradient estimator ( Lian Published as a conference paper at ICLR 2020 et al., 2016 ;  Liu et al., 2018b ): ∇f (θ) = d i=1 (1/2µ i )[f (θ + µ i e i ) − f (θ − µ i e i )]e i (5) where d is the dimension of the optimizee loss function, µ i is the smoothing parameter for the i th coordinate, and e i ∈ R d is the standard basis vector with its i th coordinate being 1, and others being 0s. This estimator is deterministic and could achieve an accurate estimate when {µ i } are sufficiently small. And it is used only to backpropagate the error signal from the optimizee loss function to its parameter to train the optimizer, which is different from the estimator in equation 1 that is used by the optimizer to propose parameter update. Note that this estimator requires function queries scaled with d, which would slow down the training speed especially when optimizee is of high dimension. However, we can compute the gradient estimator of each coordinate in parallel to significantly reduce the computation overhead.

Section Title: EXPERIMENTAL RESULTS
  EXPERIMENTAL RESULTS In this section, we empirically demonstrate the superiority of our proposed ZO optimizer on a prac- tical application (black-box adversarial attack on MINST and CIFAR-10 dataset) and a synthetic problem (binary classification in stochastic zeroth-order setting). We compare our learned optimizer (called ZO-LSTM below) with existing hand-designed ZO optimization algorithms, including ZO- SGD ( Ghadimi & Lan, 2013 ), ZO-signSGD ( Liu et al., 2019 ), and ZO-ADAM ( Chen et al., 2017a ). For each task, we tune the hyperparameters of baseline algorithms to report the best performance. Specifically, we set the learning rate of baseline algorithms to δ/d. We first coarsely tune the con- stant δ on a logarithmic range {0.01, 0.1, 1, 10, 100, 1000} and then finetune it on a linear range. For ZO-ADAM, we tune β 1 values over {0.9, 0.99} and β 2 values over {0.99, 0.996, 0.999}. To ensure fair comparison, all optimizers are using the same number of query directions to obtain ZO gradient estimator at each iteration. In all experiments, we use 1-layer LSTM with 10 hidden units for both the UpdateRNN and the QueryRNN. For each RNN, another linear layer is applied to project the hidden state to the output (1-dim parameter update for the UpdateRNN and 1-dim predicted variance for the QueryRNN). The regularization parameter λ in the training objective function (equation 4) is set to 0.005. We use ADAM to train our proposed optimizer with truncated BPTT, each optimization is run for 200 steps and unrolled for 20 steps unless specified otherwise. At test time, we set the Bernoulli random variable (see Section 3.1) X ∼ Ber(0.5).

Section Title: ADVERSARIAL ATTACK TO BLACK-BOX MODELS
  ADVERSARIAL ATTACK TO BLACK-BOX MODELS We first consider an important application of our learned ZO optimizer: generating adversarial ex- amples to attack black-box models. In this problem, given the targeted model F (·) and an original example x 0 , the goal is to find an adversarial example x with small perturbation that minimizes a loss function Loss(·) which reflects attack successfulness. The black-box attack loss function can be formulated as f (x) = c x − x 0 + Loss(F (x)), where c balances the perturbation norm and attack successfulness ( Carlini & Wagner, 2017 ;  Tu et al., 2019 ). Due to the black-box setting, one can only compute the function value of the above objective, which leads to ZO optimization problems ( Chen et al., 2017a ). Note that attacking each sample x 0 in the dataset corresponds to a particular ZO optimization problem instance, which motivates us to train a ZO optimizer (or "attacker") offline with a small subset and apply it to online attack to other samples with faster convergence (which means lower query complexity) and lower final loss (which means less distortion). Here we experiment with black-box attack to deep neural network image classifier, see detailed problem formulation in Appendix A.1. We follow the same neural network architectures used in  Cheng et al. (2019)  for MNIST and CIFAR-10 dataset, which achieve 99.2% and 82.7% test accu- racy respectively. We randomly select 100 images that are correctly classified by the targeted model in each test set to train the optimizer and select another 100 images to test the learned optimizer. The dimension of the optimizee function is d = 28 × 28 for MNIST and d = 32 × 32 × 3 for CIFAR-10. The number of sampled query directions is set to q = 20 for MNIST and q = 50 for CIFAR-10 respectively. All optimizers use the same initial points for finding adversarial examples.  Figure 2  shows black-box attack loss versus iterations using different optimizers. We plot the loss curves of two selected test images (see Appendix A.3 for more plots on other test images) as well as the average loss curve over all 100 test images for each dataset. It is clear that our learned optimizer (ZO-LSTM) leads to much faster convergence and lower final loss than other baseline optimizers both on MNIST and CIFAR-10 attack tasks. The visualization of generated adversarial examples versus iterations can be found in Appendix A.2.

Section Title: STOCHASTIC ZEROTH-ORDER BINARY CLASSIFICATION
  STOCHASTIC ZEROTH-ORDER BINARY CLASSIFICATION Next we apply our learned optimizer in the stochastic ZO optimization setting. We consider a synthetic binary classification problem ( Liu et al., 2019 ) with non-convex least squared loss function: To generate one dataset for the binary classification task, we first randomly sample a d-dimensional vector θ ∈ R d from N (0, I d ) as the ground-truth. Then we draw samples {x i } from N (0, I d ) and obtain the label y i = 1 if θ T x i > 0 and y i = 0 otherwise. The size of training set is 2000 for each dataset. Note that each dataset corresponds to a different optimizee function in the class of binary classification problem. We generate 100 different datasets in total, and use 90 generated datasets (i.e. 90 binary classification problem instances) to train the optimizer and other 10 to test the performance of the learned optimizer. Unless specified otherwise, the problem dimension is d = 100; the batch size and the number of query directions are set to b = 64 and q = 20 respectively. At each iteration of training, the optimizer is allowed to run 500 steps and unrolled for 20 steps. In Figure 3a, we compare various ZO optimizers and observe that our learned optimizer outperforms all other hand-designed ZO optimization algorithms. Figure 3b-3c compares the performance of ZO-SGD and ZO-LSTM with different query direction number q and batch size b. ZO-LSTM consistently outperforms ZO-SGD in different optimization settings. In Figure 3d, we generate binary classification problems with different dimension d and test the performance of ZO-LSTM. Our learned optimizer generalizes well and still achieves better performance than ZO-SGD.

Section Title: GENERALIZATION OF THE LEARNED OPTIMIZER
  GENERALIZATION OF THE LEARNED OPTIMIZER In previous experiments, we train the optimizer using a small subset of problem instances in a particular ZO optimization task and apply the learned optimizer in other problem instances, which Published as a conference paper at ICLR 2020 demonstrates the generalization in a specific class of ZO optimization problems. In this subsection, we study the generalization of the learned optimizer across different classes of ZO optimization problems. Current L2L framework (first-order) aims to train an optimizer on a small subset of problems and make the learned optimizer generalize to a wide range of different problems. However, in practice, it is difficult to train a general optimizer that can achieve good performance on problems with different structures and loss landscapes. In experiments, we find that the learned optimizer could not easily generalize to those problems with different relative scales between parameter update and estimated gradient (similar to the definition of learning rate). Therefore, we scale the parameter update pro- duced by the UpdateRNN by a factor α when generalizing the learned optimizer to another totally different task and tune this hyperparameter α on that task (similar to SGD/Adam). We first train the optimizer on MNIST attack task and then finetune it on CIFAR-10 attack task 2 , as shown in Figure 2d-2f. We see that the finetuned optimizer (ZO-LSTM-finetune) achieves compa- rable performance with ZO-LSTM which is trained from scratch on a CIFAR-10 subset. We also generalize the learned optimizer trained on the MNIST attack task to the totally different binary clas- sification task (Figure 3a) and surprisingly find that it could achieve almost identical performance with ZO-LSTM directly trained on this target task. These results demonstrate that our optimizer has learned a rather general ZO optimization algorithm which can generalize to different classes of ZO optimization problems well.

Section Title: ANALYSIS
  ANALYSIS In this section, we conduct experiments to analyze the effectiveness of each module and understand the function mechanism of our proposed optimizer (especially the QueryRNN).

Section Title: Ablation study
  Ablation study To assess the effectiveness of each module, we conduct ablation study on each task, as shown in Figure 4a-4c. We compare the performance of ZO-SGD, ZO-LSTM (our model), ZO-LSTM-no-query (our model without the QueryRNN, i.e., use standard Gaussian sampling), ZO- LSTM-no-update (our model without the UpdateRNN, i.e., ZO-SGD with the QueryRNN). We observe that both the QueryRNN and the UpdateRNN improves the performance of the learned optimizer in terms of convergence rate or/and final solution. Noticeably, the improvement induced by the QueryRNN is less significant on binary classification task than on black-box attack task. We conjecture the reason is that the gradient directions are more random in binary classification task so it is much more difficult for the QueryRNN to identify the important sampling space. To further demonstrate the effectiveness of the QueryRNN, we also compare ZO-LSTM, ZO-LSTM- no-query with ZO-LSTM-GuidedES, whose parameter update is produced by the UpdateRNN but the covariance matrix of random Gaussian sampling is adapted by guided evolutionary strategy (Guided ES). For fair comparison, we use the ZO gradient estimator and the parameter update at last iterate (the same as the input of our QueryRNN) as surrogate gradients for GuidedES (see Appendix B for details). We find that using GuidedES to guide the query direction search also improves the convergence speed on MNIST attack task, but the improvement is much less than that of the QueryRNN. In addition, GuidedES leads to negligible effects on the other two tasks.

Section Title: Estimated gradient evaluation
  Estimated gradient evaluation In this experiment, we evaluate the estimated gradient produced by the Guided ZO Oracle with and without the QueryRNN. Specifically, we test our learned optimizer on MNIST attack task and compute the average cosine similarity between the ground-truth gradient and the ZO gradient estimator over optimization steps before convergence. In Figure 4d, we plot the average cosine similarity of ZO-LSTM and ZO-LSTM-no-query against different query direction number q. We observe that the cosine similarity becomes higher with the QueryRNN, which means that the direction of ZO gradient estimator is closer to that of the ground-truth gradient. And with the query direction number q increasing, the improvement of cosine similarity becomes more significant. These results can explain the effectiveness of the QueryRNN in terms of obtaining more accurate ZO gradient estimators. In Appendix C.1, we evaluate the iteration complexity with and without the QueryRNN to further verify its improved convergence rate and scalability with problem dimension.

Section Title: Optimization trajectory analysis
  Optimization trajectory analysis To obtain a more in-depth understanding of what our proposed optimizer learns, we conduct another analysis on the MNIST attack task. We use the learned opti- mizer (or "attacker") to attack one test image in the MNIST dataset. Then we select one pixel in the image (corresponds to one coordinate to be optimized), and trace the predicted variance, the gradient estimator and the parameter update of that coordinate at each iteration, as shown in Figure 4e. We can observe that although the ZO gradient estimator is noisy due to the high variance of random Gaussian sampling, the parameter update produced by the UpdateRNN is less noisy, which makes the optimization process less stochastic. The smoothing effect of the UpdateRNN is similar to that of ZO-ADAM, but it is learned automatically rather than by hand design. The predicted variance produced by the QueryRNN is even smoother. With a larger value of ZO gradient estimator or the parameter update, the QueryRNN produces a larger predicted variance to increase the sampling bias toward that coordinate. We observe that the overall trend of the predicted variance is more similar to that of the parameter update, which probably means the parameter update plays a more important role in the prediction of the Gaussian sample variance. Finally, in Appendix C.2, we also visualize the predicted variance by the QueryRNN and compare it with final added perturbation to the image (i.e., the final solution of attack task).

Section Title: CONCLUSION
  CONCLUSION In this paper, we study the learning to learn framework for zeroth-order optimization problems. We propose a novel RNN-based optimizer that learns both the update rule and the Gaussian sampling rule. Our learned optimizer leads to significant improvement in terms of convergence speed and final loss. Experimental results on both synthetic and practical problems validate the superiority of our learned optimizer over other hand-designed algorithms. We also conduct extensive analytical experiments to show the effectiveness of each module and to understand our learned optimizer. Despite the prospects of the L2L framework, current learned optimizers still have several drawbacks, such as lack of theoretical convergence proof and extra training overhead. In our future work, we aim to prove the improved convergence in theory and further improve the training methodology.
  2 Although black-box attack tasks on MNIST and CIFAR-10 dataset seem to be similar on intuition, the ZO optimization problems on these two datasets are not such similar. Because targeted models are of very different architectures and image features also vary a lot, the loss landscape and gradient scale are rather different.

```
