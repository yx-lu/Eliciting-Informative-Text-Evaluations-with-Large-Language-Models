Title:
```
Published as a conference paper at ICLR 2020 LOGIC AND THE 2-SIMPLICIAL TRANSFORMER
```
Abstract:
```
We introduce the 2-simplicial Transformer, an extension of the Transformer which includes a form of higher-dimensional attention generalising the dot-product at- tention, and uses this attention to update entity representations with tensor prod- ucts of value vectors. We show that this architecture is a useful inductive bias for logical reasoning in the context of deep reinforcement learning.
```

Figures/Tables Captions:
```
Figure 1: A 3-way relationship between blocks.
Figure 2: The geometry of 1- and 2-simplicial attention. Left: the dot product in terms of the area A in R 2 . Right: the triple product in terms of the volume V in R 3 .
Figure 3: Right: a sample episode of the BoxWorld environment. The rightmost column is the player inventory, currently empty. Left: graph representation of the puzzle, with key colours as vertices and an arrow C −→ D if key C can be used to obtain key D. paths (of the same length) leading to each of the locks on the Gem are generated with no overlapping colours, beginning with two loose keys. In episodes with multiple locks we do not consider distractor boxes of the old kind; instead there is a new type of distractor that we call a bridge. This is a locked box whose lock colour is taken from one solution branch and whose key colour is taken from the other branch. Opening the bridge renders the puzzle unsolvable. An episode ends when the player either obtains the Gem (reward +10) or opens the bridge (reward −1). Opening a box other than the bridge, or picking up a loose key, has a reward of +1 as before. In this paper we consider episodes with zero or one bridge (the player cannot fail to solve an episode with no bridge).
Figure 4: Right: a sample episode of the bridge BoxWorld environment, in which the Gem has two locks and there is a marked bridge. Left: graph representation of the puzzle, with upper and lower solutions paths and the bridge between them. There is a source involving the orange key and a sink involving the purple lock.
Figure 6: Training curve of mean relational and simplicial agents on bridge BoxWorld. Shown are the mean and standard deviation of four runs of each agent, including the best run of each.
Figure 7: Visualization of 2-simplicial attention in step 18 of an episode.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Deep learning contains many differentiable algorithms for computing with learned representations. These representations form vector spaces, sometimes equipped with additional structure. A recent example is the Transformer (Vaswani et al., 2017) in which there is a vector space V of value vectors and an inner product space H of query and key vectors. This structure supports a kind of message- passing, where a value vector v j ∈ V derived from entity j is propagated to update an entity i with weight q i · k j , where q i ∈ H is a query vector derived from entity i, k j ∈ H is a key vector derived from entity j, and the inner product on H is written as a dot product. The Transformer therefore represents a relational inductive bias, where a relation from entity j to entity i is perceived to the extent that q i · k j is large and positive. However, the real world has structure beyond entities and their direct relationships: for example, the three blocks in  Figure 1  are arranged in such a way that if either of the supporting blocks is removed, the top block will fall. This is a simple 3-way relationship between entities i, j, k that is complex to represent as a system of 2-way relationships. It is natural to make the hypothesis that such higher-order relationships are essential to extracting the full predictive power of data, across many domains. In accordance with this hypothesis, we introduce a generalisation of the Transformer architecture, the 2-simplicial Transformer, which incorporates both 2- and 3-way interactions. Mathematically, the key observation is that higher-order interactions between entities can be understood using al- gebras. This is nothing but Boole's insight (Boole, 1847) which set in motion the development of modern logic. In our situation, an appropriate algebra is the Clifford algebra Cl(H) of the space H of queries and keys, which contains that space H ⊆ Cl(H) and in which queries and keys can be multiplied. To represent a 3-way interaction we map each entity i to a triple (p i , l 1 i , l 2 i ) of vectors in H consisting of a query vector p i , a (first) key vector l 1 i and a (second) key vector l 2 i . Given a triple i, j, k we first form the product p i l 1 j l 2 k in the Clifford algebra, and then extract a scalar quantity η(p i l 1 j l 2 k ) using a natural continuous function η : Cl(H) −→ R associated to the Z-grading of Cl(H). This scalar Published as a conference paper at ICLR 2020 measures how strongly the network perceives a 3-way interaction involving i, j, k. In summary, the 2-simplicial Transformer learns how to represent entities in its environment as vectors v ∈ V , and how to transform those entities to queries and (pairs of) keys in H, so that the signals provided by the scalars q i · k j and η(p i l 1 j l 2 k ) are informative about higher-order structure in the environment. As a toy example of higher-order structure, we consider the reinforcement learning problem in a variant of the BoxWorld environment from (Zambaldi et al., 2019). The original BoxWorld is played on a rectangular grid populated by keys and locked boxes of varying colours, with the goal being to open the box containing the "Gem". In our variant of the BoxWorld environment, bridge BoxWorld, the agent must use two keys simultaneously to obtain the Gem; this structure in the environment creates many 3-way relationships between entities, including for example the relationship between the locked boxes j, k providing the two keys and the Gem entity i. This structure in the environment is fundamentally logical in nature, and encodes a particular kind of conjunction; see Appendix I. The architecture of our deep reinforcement learning agent largely follows (Zambaldi et al., 2019) and the details are given in Section 4. The key difference between our simplicial agent and the relational agent of (Zambaldi et al., 2019) is that in place of a standard Transformer block we use a 2-simplicial Transformer block. Our experiments show that the simplicial agent confers an advantage over the relational agent as an inductive bias in our reasoning task. Motivation from neuroscience for a simplicial inductive bias for abstract reasoning is contained in Appendix J. Our use of tensor products of value vectors is inspired by the semantics of linear logic in vector spaces (Girard, 1987; Melliès, 2009; Clift & Murfet, 2017; Wallbridge, 2018) in which an algorithm with multiple inputs computes on the tensor product of those inputs, but this is an old idea in natural language processing, used in models including the second-order RNN (Giles et al., 1989; Pollack, 1991; Goudreau et al., 1994; Giles et al., 1991), multiplicative RNN (Sutskever et al., 2011; Irsoy & Cardie, 2015), Neural Tensor Network (Socher et al., 2013) and the factored 3-way Restricted Boltzmann Machine (Ranzato et al., 2010), see Appendix A. Tensors have been used to model pred- icates in a number of neural network architectures aimed at logical reasoning (Serafini & Garcez, 2016; Dong et al., 2019). The main novelty in our model lies in the introduction of the 2-simplicial attention, which allows these ideas to be incorporated into the Transformer architecture.

Section Title: 2-SIMPLICIAL TRANSFORMER
  2-SIMPLICIAL TRANSFORMER In this section we first review the definition of the ordinary Transformer block and then explain the 2- simplicial Transformer block. We distinguish between the Transformer architecture which contains a word embedding layer, an encoder and a decoder (Vaswani et al., 2017), and the Transformer block which is the sub-model of the encoder that is repeated. The fundamental idea, of propagating information between nodes using weights that depend on the dot product of vectors associated to those nodes, comes ultimately from statistical mechanics via the Hopfield network (Appendix B). The ordinary and 2-simplicial Transformer blocks define operators on sequences e 1 , . . . , e N of entity representations. Strictly speaking the entities are indices 1 ≤ i ≤ N but we sometimes identify the entity i with its representation e i . The space of entity representations is denoted V , while the space of query, key and value vectors is denoted H. We use only the vector space structure on V , but H = R d is an inner product space with the usual dot product pairing (h, h ) → h · h and in defining the 2-simplicial Transformer block we will use additional algebraic structure on H, including the "multiplication" tensor B : H ⊗ H −→ H of (10) (used to propagate tensor products of value vectors) and the Clifford algebra of H (used to define the 2-simplicial attention). In the first step of the standard Transformer block we generate from each entity e i a tuple of vectors via a learned linear transformation E : V −→ H ⊕3 . These vectors are referred to respectively as query, key and value vectors and we write Stated differently, q i = W Q e i , k i = W K e i , v i = W V e i for weight matrices W Q , W K , W V . In the second step we compute a refined value vector for each entity Published as a conference paper at ICLR 2020 Finally, the new entity representation e i is computed by the application of a feedforward network g θ , layer normalisation and a skip connection Remark 2.1. In the introduction we referred to the idea that a Transformer model learns represen- tations of relations. To be more precise, these representations are heads, each of which determines an independent set of transformations W Q , W K , W V which extract queries, keys and values from entities. Thus a head determines not only which entities are related (via W Q , W K ) but also what information to transmit between them (via W V ). In multiple-head attention with K heads, there are K channels along which to propagate information between every pair of entities, each of dimension dim(H)/K. More precisely, we choose a decomposition H = H 1 ⊕ · · · ⊕ H K so that To compute the output of the attention, we take a direct sum of the value vectors propagated along every one of these K channels, as in the formula In combinatorial topology the canonical one-dimensional object is the 1-simplex (or edge) j −→ i. Since the standard Transformer model learns representations of relations, we refer to this form of attention as 1-simplicial attention. The canonical two-dimensional object is the 2-simplex (or triangle) which we may represent diagrammatically in terms of indices i, j, k as In the 2-simplicial Transformer block, in addition to the 1-simplicial contribution, each entity e i is updated as a function of pairs of entities e j , e k using the tensor product of value vectors u j ⊗ u k and a probability distribution derived from a scalar triple product p i , l 1 j , l 2 k in place of the scalar product q i · k j . This means that we associate to each entity e i a four-tuple of vectors via a learned linear transformation E : V −→ H ⊕4 , denoted Definition 2.2. The unsigned scalar triple product of a, b, c ∈ H is a, b, c = (a · b)c − (a · c)b + (b · c)a (7) whose square is a polynomial in the pairwise dot products This scalar triple product has a simple geometric interpretation in terms of the volume of the tetra- hedron with vertices 0, a, b, c. To explain, recall that the triangle spanned by two unit vectors a, b in R 2 has an area A which can be written in terms of the dot product of a and b. In three dimensions, the analogous formula involves the volume V of the tetrahedron with vertices given by unit vectors a, b, c, and the scalar triple product as shown in  Figure 2 . In general, given nonzero vectors a, b, c letâ,b,ĉ denote unit vectors in the same directions. Then we can by Lemma C.10(v) factor out the length in the scalar triple product so that a general scalar triple product can be understood in terms of the vector norms and config- urations of three points on the 2-sphere. One standard approach to calculating volumes of such tetrahedrons is the cross product which is only defined in three dimensions. Since the space of rep- resentations H is high dimensional the natural framework for the triple scalar product a, b, c is instead the Clifford algebra of H (see Appendix C). For present purposes, we need to know that a, b, c attains its minimum value (which is zero) when a, b, c are pairwise orthogonal, and attains its maximum value (which is a b c ) if and only if {a, b, c} is linearly dependent (Lemma C.10). Using the number p i , l 1 j , l 2 k as a measure of the degree to which entity i is attending to (j, k), or put differently, the degree to which the network predicts the existence of a 2-simplex (i, j, k), the update rule for the entities when using purely 2-simplicial attention is where B : H ⊗ H −→ H is a learned linear transformation. Although we do not impose any further constraints, the motivation here is to equip H with the structure of an algebra; in this respect we model conjunction by multiplication, an idea going back to Boole (Boole, 1847). We compute multiple-head 2-simplicial attention in the same way as in the 1-simplicial case. To combine 1-simplicial heads (that is, ordinary Transformer heads) and 2-simplicial heads we use separate inner product spaces H 1 , H 2 for each simplicial dimension, so that there are learned linear transformations E 1 : V −→ (H 1 ) ⊕3 , E 2 : V −→ (H 2 ) ⊕4 and the queries, keys and values are extracted from an entity e i according to The update rule (for a single head in each simplicial dimension) is then: If there are K 1 heads of 1-simplicial attention and K 2 heads of 2-simplicial attention, then (11) is modified in the obvious way using H 1 = K1 u=1 H 1 u and H 2 = K2 u=1 H 2 u . Remark 2.3. Without the additional layer normalisation on the output of the 2-simplicial attention we find that training is unstable. The natural explanation is that these outputs are constructed from polynomials of higher degree than the 1-simplicial attention, and thus computational paths that go through the 2-simplicial attention will be more vulnerable to exploding or vanishing gradients. The time complexity of 1-simplicial attention as a function of the number of entities is O(N 2 ) while the time complexity of 2-simplicial attention is O(N 3 ) since we have to calculate the attention for every triple (i, j, k) of entities. For this reason we consider only triples (i, j, k) where the base of the 2-simplex (j, k) is taken from a set of pairs predicted by the ordinary attention, which we view as Published as a conference paper at ICLR 2020 the primary locus of computation. More precisely, we introduce in addition to the N entities (now referred to as standard entities) a set of M virtual entities e N +1 , . . . , e N +M . These virtual entities serve as a "scratch pad" onto which the iterated ordinary attention can write representations, and we restrict j, k to lie in the range N < j, k ≤ N + M so that only value vectors obtained from virtual entities are propagated by the 2-simplicial attention. With virtual entities the update rule is for 1 ≤ i ≤ N The updated representation e i is computed from v i , e i using (12) as before. Observe that the virtual entities are not used to update the standard entities during 1-simplicial attention and the 2-simplicial attention is not used to update the virtual entities; instead the second summand in (14) involves the vector u i = W U e i , which adds recurrence to the update of the virtual entities. After the attention phase the virtual entities are discarded. The method for updating the virtual entities is similar to the role of the memory nodes in the rela- tional recurrent architecture of (Santoro et al., 2018), the master node in (Gilmer et al., 2017, §5.2) and memory slots in the Neural Turing Machine (Graves et al., 2014). The update rule has complex- ity O(N M 2 ) and so if we take M to be of order √ N we get the desired complexity O(N 2 ).

Section Title: RL ENVIRONMENT
  RL ENVIRONMENT The environment in our reinforcement learning problem is a variant of the BoxWorld environment from (Zambaldi et al., 2019). The standard BoxWorld environment is a rectangular grid in which are situated the player (a dark gray tile) and a number of locked boxes represented by a pair of horizontally adjacent tiles with a tile of colour x, the key colour, on the left and a tile of colour y, the lock colour, on the right. There is also one loose key in each episode, which is a coloured tile not initially adjacent to any other coloured tile. All other tiles are blank (light gray) and are traversable by the player. The rightmost column of the screen is the inventory, which fills from the top and contains keys that have been collected by the player. The player can pick up any loose key by walking over it. In order to open a locked box, with key and lock colours x, y, the player must step on the lock while in possession of a copy of y, in which case one copy of this key is removed from the inventory and replaced by a key of colour x. The goal is to attain a white key, referred to as the Gem (represented by a white square) as shown in the sample episode of  Figure 3 . In this episode, there is a loose pink key (marked 1) which can be used to open one of two locked boxes, obtaining in this way either key 5 or key 2 1 . The correct choice is 2, since this leads via the sequence of keys 3, 4 to the Gem. Some locked boxes, if opened, provide keys that are not useful for attaining the Gem. Since each key may only be used once, opening such boxes means the episode is rendered unsolvable. Such boxes are called distractors. An episode ends when the player either obtains the Gem (with a reward of +10) or opens a distractor box (reward −1). Opening any non-distractor box, or picking up a loose key, garners a reward of +1. The solution length is the number of locked boxes (including the one with the Gem) in the episode on the path from the loose key to the Gem. Our variant of the BoxWorld environment, bridge BoxWorld, is shown in  Figure 4 . In each episode two keys are now required to obtain the Gem, and there are therefore two loose keys on the board. To obtain the Gem, the player must step on either of the lock tiles with both keys in the inventory, at which point the episode ends with the usual +10 reward. Graphically, Gems with multiple locks are denoted with two vertical white tiles on the left, and the two lock tiles on the right. Two solution Published as a conference paper at ICLR 2020 1 2 3 4 5 1 2 3 4 1 2 3 4 (2,1,3) bridge (2,1,4) bridge 1 2 3 4 (2,2,3) bridge 1 2 3 4 (2,2,4) bridge bridge Standard BoxWorld is straightforward for an agent to solve using relational reasoning, because leaves on the solution graph can be identified (their key colour appears only once on the board) and by propagating this information backwards along the arrows on the solution graph, an agent can identify distractors. Bridge BoxWorld emphasises reasoning about 3-way relationships (or 2- simplices). The following 2-simplex motifs α * β (a) Source α * β (b) Sink appear in all solution graphs where a pair of boxes (α, β) is a source if they have the same lock colour but distinct key colours, and a sink if they have the same key colour but distinct lock colours (the 2-simplex leading to the Gem being an example). If α, β is a source or a sink then either α is the bridge or β is the bridge. If the agent can observe both a source and a sink then it can locate the bridge. It is less clear how to identify bridges using iterated relational reasoning, because every path in the solution graph eventually reaches the Gem.

Section Title: RL AGENT ARCHITECTURE
  RL AGENT ARCHITECTURE Our baseline relational agent is modeled closely on (Zambaldi et al., 2019) except that we found that a different arrangement of layer normalisations worked better in our experiments, see Remark 4.1. The code for our implementation of both agents is available online (Clift et al., 2019). In the following we describe the network architecture of both the relational and simplicial agent; we will note the differences between the two models as they arise. The input to the agent's network is an RGB image, represented as a tensor of shape [R, C + 1, 3] (i.e. an element of R R ⊗ R C+1 ⊗ R 3 ) where R is the number of rows and C the number of columns (the C + 1 is due to the inventory). This tensor is divided by 255 and then passed through a 2 × 2 convolutional layer with 12 features, and then a 2 × 2 convolutional layer with 24 features. Both activation functions are ReLU and the padding on our convolutional layers is "valid" so that the output has shape [R − 2, C − 1, 24]. We then multiply by a weight matrix of shape 24 × 62 to obtain a tensor of shape [R − 2, C − 1, 62]. Each feature vector has concatenated to it a two- dimensional positional encoding, and then the result is reshaped into a tensor of shape [N, 64] where N = (R − 2)(C − 1) is the number of Transformer entities. This is the list (e 1 , . . . , e N ) of entity representations e i ∈ V = R 64 . In the case of the simplicial agent, a further two learned embedding vectors e N +1 , e N +2 are added to this list; these are the virtual entities. So with M = 0 in the case of the relational agent and M = 2 for the simplicial agent, the entity representations form a tensor of shape [N + M, 64]. This tensor is then passed through two iterations of the Transformer block (either purely 1-simplicial in the case of the relational agent, or including both 1 and 2-simplicial attention in the case of the simplicial agent). In the case of the simplicial agent the virtual entities are then discarded, so that in both cases we have a sequence of entities e 1 , . . . , e N . Inside each block are two feedforward layers separated by a ReLU activation with 64 hidden nodes; the weights are shared between iterations of the Transformer block. In the 2-simplicial Transformer block the input tensor, after layer normalisation, is passed through the 2-simplicial attention and the result (after an additional layer normalisation) is concatenated to the output of the 1-simplicial attention heads before being passed through the feedforward layers. The pseudo-code for the ordinary and 2-simplicial Transformer blocks are: Our implementation of the standard Transformer block is based on an implementation in Keras from (Mavreshko, 2019). In both the relational and simplicial agent, the space V of entity representations has dimension 64 and we denote by H 1 , H 2 the spaces of 1-simplicial and 2-simplicial queries, keys and values. In both the relational and simplicial agent there are two heads of 1-simplicial attention, H 1 = H 1 1 ⊕ H 1 2 with dim(H 1 i ) = 32. In the simplicial agent there is a single head of 2-simplicial attention with dim(H 2 ) = 48 and two virtual entities. The output of the Transformer blocks is a tensor of shape [N, 64]. To this final entity tensor we apply max-pooling over the entity dimension, that is, we compute a vector v ∈ R 64 by the rule v i = max 1≤j≤N (e j ) i for 1 ≤ i ≤ 64. This vector v is then passed through four fully-connected layers with 256 hidden nodes and ReLU activations. The output of the final fully-connected layer is multiplied by one 256 × 4 weight matrix to produce logits for the actions (left, up, right and down) and another 256 × 1 weight matrix to produce the value function. Remark 4.1. There is wide variation in the layer normalisation in Transformer models, compare (Vaswani et al., 2017; Child et al., 2019; Zambaldi et al., 2019). In (Zambaldi et al., 2019) layer normalisation occurs in two places: on the concatenation of the Q, K, V matrices, and on the output of the feedforward network g θ . We keep this second normalisation but move the first from after the linear transformation E of (1) to before this linear transformation, so that it is applied directly to the incoming entity representations. This ordering gave the best performant relational model in our experiments, with our results diverging even further if a direct comparison to the (Zambaldi et al., 2019) architecture was used.

Section Title: EXPERIMENTS AND RESULTS
  EXPERIMENTS AND RESULTS The training of our agents uses the implementation in Ray RLlib (Liang et al., 2018) of the dis- tributed off-policy actor-critic architecture IMPALA of (Espeholt et al., 2018) with optimisation algorithm RMSProp. The hyperparameters for IMPALA and RMSProp are given in Table 1 of Ap- pendix E. Following (Zambaldi et al., 2019) and other recent work in deep reinforcement learning, we use RMSProp with a large value of the hyperparameter ε = 0.1. As we explain in Appendix G, this is effectively RMSProp with smoothed gradient clipping. First we verified that our implementation of the relational agent solves the BoxWorld environment (Zambaldi et al., 2019) with a solution length sampled from [1, 5] and number of distractors sampled from [0, 4] on a 9 × 9 grid. After training for 2.35 × 10 9 timesteps our implementation solved over 93% of puzzles (regarding the discrepancy with the reported sample complexity in (Zambaldi et al., 2019) see Appendix D). Next we trained the relational and simplicial agent on bridge BoxWorld, under the following conditions: half of the episodes contain a bridge, the solution length is uniformly sampled from [1, 3] (both solution paths are of the same length), colours are uniformly sampled from a set of 20 colours and the boxes and loose keys are arranged randomly on a 7 × 9 grid, under the constraint that the box containing the Gem does not occur in the rightmost column or bottom row, and keys appear only in positions (y, x) = (2r, 3c − 1) for 1 ≤ r ≤ 3, 1 ≤ c ≤ 3. The starting and ending point of the bridge are uniformly sampled with no restrictions (e.g. the bridge can involve the colours of the loose keys and locks on the Gem) but the lock colour is always on the top solution path. There is no curriculum and no cap on timesteps per episode. We trained four independent trials of both agents to either 5.5 × 10 9 timesteps or convergence, whichever came first. In  Figure 6  we give the mean and standard deviation of these four trials, showing a clear advantage of the simplicial agent. We make some remarks about performance comparisons taking into account the fact that the relational agent is simpler (and hence faster to execute) than the simplicial agent in Appendix D. The training runs for the relational and simplicial agents are shown in Figure 9 and Figure 10 of Appendix F, together with analysis and visualization of the 1- and 2-simplicial attention in specific examples. In the reported experiments we use only two Transformer blocks; we performed two trials of a relational agent using four Transformer blocks, but after 5.5 × 10 9 timesteps neither trial exceeded the 0.85 plateau in terms of fraction solved. Our overall results therefore suggest that the 2-simplicial Transformer is more powerful than the standard Transformer, with its performance not matched by adding greater depth. This is further supported by the fact on a time-adjusted basis, the 2-simplicial model still converges faster than the ordinary model; see Figure 8 of Appendix D.

Section Title: ANALYSIS
  ANALYSIS We analyse the simplicial agent to establish that it has learned to use the 2-simplicial attention, and to provide some intuition for why 2-simplices are useful; additional details are in Appendix F. The analysis is complicated by the fact that our 2 × 2 convolutional layers (of which there are two) are not padded, so the number of entities processed by the Transformer blocks is (R − 2)(C − 1) where the original game board is R × C and there is an extra column for the inventory (here R is the number of rows). This means there is not a one-to-one correspondence between game board tiles and entities; for example, all the experiments reported in  Figure 6  are on a 7 × 9 board, so that there are N = 40 Transformer entities which can be arranged on a 5 × 8 grid (information about this grid is passed to the Transformer blocks via the positional encoding). Nonetheless we found that for trained agents there is a strong relation between a tile in position (y, x) and the Transformer entity with index x + (C − 1)(y − 1) − 1 for (y, x) ∈ [1, R − 2] × [1, C − 1] ⊆ [0, R − 1] × [0, C]. This correspondence is presumed in the following analysis, and in our visualisations. Displayed in  Figure 7  are attention distributions for simplicial agent A of Figure 10. The four images in the top right show the ordinary attention of the virtual entities in the first iteration of the simplicial Transformer block: in the first head, the first virtual entity attends strongly to a particular lock, while the second head of the second virtual entity attends strongly to the corresponding key. Shown at the bottom of  Figure 7  is the 2-simplicial attention in the second iteration of the simplicial Transformer block. The columns are query entities i and rows are key entity pairs (j, k) in lexicographic order (1, 1), (1, 2), (2, 1), (2, 2). Entity 17 is the top lock on the Gem, 25 is the bottom lock on the Gem, 39 is the player. We may therefore infer, from our earlier description of the ordinary attention of the virtual entities, that the agent "perceives" the 2-simplex with query entity 25 as shown. In general we observe that the top and bottom locks on the Gem, the player, and the entities 7, 15 associated to the inventory often have a non-generic 2-simplicial attention, which strongly suggests that the simplicial agent has learned to use 2-simplices in a meaningful way.

Section Title: DISCUSSION
  DISCUSSION On general grounds one might expect that in the limit of infinite experience, any reinforcement learning agent with a sufficiently deep neural network will be able to solve any environment, in- cluding those like bridge BoxWorld that involve higher-order relations between entities. In practice, however, we do not care about the infinite computation limit. In the regime of bounded computation it is reasonable to introduce biases towards learning representations of structures that are found in a wide range of environments that we consider important. We argue that higher-order relations between entities are an important example of such structures, and that the 2-simplicial Transformer is a natural inductive bias for 3-way interactions between entities. We have given preliminary evidence for the utility of this bias by showing that in the bridge BoxWorld environment the simplicial agent has better performance than a purely relational agent, and that this performance involves in a meaningful way the prediction of 3-way interactions (or 2-simplices). We believe that simplicial Transformers may be useful for any problem in which higher-order relations between entities are important. The long history of interactions between logic and algebra is a natural source of inspiration for the design of inductive biases in deep learning. In this paper we have exhibited one example: Boole's idea, that relationships between entities can be modeled by multiplication in an algebra, may be realised in the context of deep learning as an augmentation to the Transformer architecture using Clifford algebras of spaces of representations.
  The agent sees only the colours of tiles, not the numbers which are added here for exposition.

```
