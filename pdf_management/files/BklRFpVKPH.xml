<article article-type="research-article"><front><article-meta><title-group><article-title>Under review as a conference paper at ICLR 2020 DEMONSTRATION ACTOR CRITIC</article-title></title-group><abstract><p>We study the problem of Reinforcement learning from demonstrations (RLfD), where the learner is provided with both some expert demonstrations and rein- forcement signals from the environment. One approach leverages demonstration data in a supervised manner, which is simple and direct, but can only provide supervision signal over those states seen in the demonstrations. Another approach uses demonstration data for reward shaping. By contrast, the latter approach can provide guidance on how to take actions, even for those states are not seen in the demonstrations. Specifically, such reward shaping approach trains an agent not only to imitate demonstrated actions when it encounters demonstrated states, but also to reach demonstrates states, when it confronts states that are not observed in the demonstration data. However, existing algorithms in the latter one adopt shaping reward which is not directly dependent on current policy, limiting the algorithms to treat demonstrated states the same as other states, and fail to directly exploit supervision signal in demonstration data. In this paper, we propose a novel objective function with policy-dependent shaping reward, so as to get the best of both worlds. We present a convergence proof for policy iteration of the proposed objective, under the tabular setting. Then we develop a new practical algorithm, termed as Demonstration Actor Critic (DAC). Experiments on a range of popular benchmark sparse-reward tasks shows that our DAC method obtains a significant performance gain over five strong and off-the-shelf baselines.</p></abstract></article-meta></front><body><sec><title>INTRODUCTION</title><p>Reinforcement Learning (RL) aims at solving sequential decision-making problems by learning through interacting with environments in a trail-and-error way. In many real scenarios, the existence of expert demonstrations has been well perceived as a critical value to enhance the capability of reinforcement learning algorithms. Recent years have witnessed many studies exploring the paradigm of learning from demonstration (LfD), which provides the learner with some demonstration data generated by expert policies. However, LfD yields a strong dependency on the assumption of demonstration optimality, which is usually inconsistent with the reality. To better integrate LfD with reinforcement learning, increasing efforts turn to reinforcement learning from demonstrations (RLfD), with a relaxation to the demonstration optimality assumption, which can lead to significantly boost sample efficiency of the RL process.</p><p>One major branch of RLfD proposes to leverage demonstration data in a supervised manner, by either using them to directly pretrain the policy (<xref ref-type="bibr" rid="b0">Silver et al., 2016</xref>) or supplement the learning target of the policy with a supervised objective when encountering the states in demonstration data (<xref ref-type="bibr" rid="b0">Rajeswaran et al., 2017a</xref>). Although appealingly simple and direct, such branch of RLfD unfortunately fails to fully exploit demonstration data as it can only provide supervision signal over those states observed in the demonstrations (<xref ref-type="bibr" rid="b2">Brys et al., 2015</xref>; <xref ref-type="bibr" rid="b0">Rajeswaran et al., 2017a</xref>; <xref ref-type="bibr" rid="b0">Reddy et al., 2019</xref>).</p><p>To deal with such problem, another major branch of RLfD takes advantage of the demonstrations in reward shaping, by either designing the demonstration-oriented potential-based reward shaping function (<xref ref-type="bibr" rid="b2">Brys et al., 2015</xref>; <xref ref-type="bibr" rid="b0">Sun et al., 2018</xref>), or inducing implicit dynamic reward shaping through learning a discriminator from demonstrations, which can distinguish between demonstrations and self-generated data (<xref ref-type="bibr" rid="b0">Zhu et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Kang et al., 2018</xref>). These methods can provide guidance on how to take actions, even for those states are not seen in the demonstrations. Particularly, these methods train an RL agent not only to imitate demonstrated actions when it encounters the demonstrated states, but also to reach demonstrated states, when it confronts states that are not observed in the Under review as a conference paper at ICLR 2020 demonstration data 1 (<xref ref-type="bibr" rid="b0">Ho &amp; Ermon, 2016</xref>; <xref ref-type="bibr" rid="b0">Reddy et al., 2019</xref>; <xref ref-type="bibr" rid="b0">Wang et al., 2019</xref>). This is the core idea behind these reshaping reward based approaches. However, since the new adopted shaping reward yields no direct dependence on the current policy, this branch of methods, updating policy over demonstrated states in the same way as others by the reshaped value function, overlook the validity of such direct supervision for demonstrated states when learning the policy.</p><p>In order to provide both guidance for all states as well as direct supervision for demonstrated states, we propose a new objective function with policy-dependent shaping reward. To demonstrate the theoretic soundness of this approach, we first present a convergence proof for policy iteration of the proposed objective, under the tabular setting given the assumption of the existence of an expert policy &#960; E (a|s). Furthermore, to cope with the problem of missing explicit expression of &#960; E (a|s) in reality, we develop a new practical algorithm, called Demonstration Actor Critic (DAC), by making several approximations that can be implemented using deep neural networks. Intuitively, if the current state is not included in the demonstration, the agent will learn to update the policy merely relying on the reshaped Q-value function. Otherwise, the agent will take advantage of both expert information and the reshaped Q-value function to update the policy.</p><p>To demonstrate the effectiveness of our algorithm, we conduct experiments on the continuous physical locomotion tasks based on Mujoco (<xref ref-type="bibr" rid="b0">Todorov et al., 2012</xref>) in sparse-reward environments. In comparison with five strong and off-the-shelf baselines, the empirical results clearly show that our new DAC approach can attain consistent and significant improvements. Considering the recent concerns on reproducibility (<xref ref-type="bibr" rid="b11">Henderson et al., 2017</xref>), all of our reported results are based on experiments run across a large number of seeds.</p><p>The main contributions of this paper are summarized as:</p><p>&#8226; We introduce a novel RLfD objective with policy-dependent shaping reward, which provide both guidance for all states as well as direct supervision signal over demonstrated states.</p><p>&#8226; We derive a Demonstration Policy Iteration method with guaranteed convergence, under the tabular setting, by assuming the existence of the expert policy &#960; E ..</p><p>&#8226; We develop Demonstration Actor Critic (DAC), a new practical algorithm to learn the policy for the continuous setting, given the missing expert policy in reality.</p><p>&#8226; We conduct empirical experiments in a couple of popular continuous tasks in sparse-reward environments to demonstrate the advantage of DAC as it consistently outperforms state-of- the-art baselines.</p></sec><sec><title>RELATED WORK</title><p>There is a growing interest in combining learning from demonstration (LfD) with reinforcement learning (RL). Recently there are three popular approaches under this problem setting: 1) utilizing demonstration data by adopting value-based RL algorithms; 2) leveraging demonstration data in a supervised manner; 3) using the demonstrations to reshape the original reward function. For the first approach, they adopt value-based RL algorithms to utilize the demonstration data. <xref ref-type="bibr" rid="b0">Kim et al. (2013)</xref> proposes Approximate Policy Iteration with demonstrations (APID), which uses expert demonstrations to define linear constraints that guide the optimization of Approximate Policy Iteration (API). <xref ref-type="bibr" rid="b0">Piot et al. (2014)</xref> builds on a similar idea but integrate expert constraint directly into the minimization of the optimal Bellman residual (OBR). Following this line, <xref ref-type="bibr" rid="b4">Chemali &amp; Lazaric (2015)</xref> bases on classification-based policy iteration and proposes Direct Policy Iteration with Demonstrations (DPID). More recently, thanks for the development of deep learning, DQfD (<xref ref-type="bibr" rid="b0">Todd et al., 2018</xref>) introduces LfD into DQN (<xref ref-type="bibr" rid="b0">Mnih et al., 2015</xref>), using the same additional structured classification loss than previous works. Besides, DQfD also adds demonstration data into the replay buffer in the same way as self-generated data. It employs a refined priority replay mechanism (<xref ref-type="bibr" rid="b0">Schaul et al., 2016</xref>) and assigns additional priority to demonstration data. However, these methods are limited by applications with discrete action spaces, due to the usage of max operator over the 1 Although current state-action pair (st, at) encountered by the agent may trigger low immediate reward r(st, at) due to its unexposure in the demonstration data, the long-term reward Q(st, at) is still likely to be high, especially if the agent can confront the demonstrated state-action pairs in later steps, so as to provides more reasonable guidance over state st.</p><p>Under review as a conference paper at ICLR 2020 whole action space. DDPGfD (<xref ref-type="bibr" rid="b0">Vecerik et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Nair et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Vecerik et al., 2019</xref>), which is built upon DDPG (<xref ref-type="bibr" rid="b0">Lillicrap et al., 2015</xref>), extends DQfD to continuous action domain. Moreover, NAC (<xref ref-type="bibr" rid="b6">Gao et al., 2018</xref>) uses a unified loss function to process both off-line demonstrations and on-line experience based on the maximum entropy reinforcement learning framework. Nonetheless, treating demonstration data in the same way as self-generated experience usually requires a tremendous number of high-quality demonstration, which are difficult to collect at scale, as discussed in (<xref ref-type="bibr" rid="b0">Kang et al., 2018</xref>).</p><p>For the second approach, they attempt to leverage the demonstration data in a supervised manner. For instance, <xref ref-type="bibr" rid="b0">Silver et al. (2016)</xref> proposes to pre-train the policy with the demonstration data as a policy initialization step for further reinforcement learning, and <xref ref-type="bibr" rid="b0">Rajeswaran et al. (2017b)</xref> augments the original policy loss with a behavior cloning loss during the policy training. Although appealingly simple and direct, such methods can only provide accurate supervision signal over those states that have been seen in the demonstrations.</p><p>For the third approach, they pursue to reshape the original reward function in order to align with the experience from the demonstrations. Specifically, <xref ref-type="bibr" rid="b2">Brys et al. (2015)</xref> introduces a reward reshaping mechanism by defining a heuristic potential function based on non-normalized multi-variate Gaussian. Besides, <xref ref-type="bibr" rid="b0">Sun et al. (2018)</xref> uses expert's value function as reward shaping, under the assumption of access to a reward-to-go oracle that provides an estimate of expert reward-to-go during training. Fur- thermore, <xref ref-type="bibr" rid="b0">Kang et al. (2018)</xref> introduces an implicit reward shaping via a parameterized discriminator, which aims to distinguish the demonstrated state-action pairs from self-generated pairs, and learn the policy with policy gradient methods. These methods can encourage the agent not only to imitate demonstrated actions, but also to visit demonstrated states. However, since the new adopted shaping reward yields no direct dependence on the current policy, this branch of methods pay rare attention to the validity of such direct supervision with respect to demonstrated states. To address this problem in the following of this paper, we develop an algorithm that can both provide guidance on all states and directly exploit the supervision signal on demonstrated states.</p><p>As one of the most popular IL algorithms, Generative Adversarial Imitation Learning (GAIL) (<xref ref-type="bibr" rid="b0">Ho &amp; Ermon, 2016</xref>) trains a discriminator to distinguish whether a state-action pair is from the expert or the learned policy. Meanwhile, GAIL optimizes the policy by maximizing expected return with respect to the reward function, which is based on that discriminator. Though effective for imitation learning, GAIL cannot leverage the valuable reward signal given by the environment and may suffer from declining performance when the demonstration data is imperfect. By contrast, our algorithm can overcome such inherent limitation by introducing reward signals from the environment into the training process. Regarding the usage of discriminator, GAIL trains a discriminator to distinguish expert state-action pairs from other state-action pairs, while our method uses a discriminator to distinguish expert actions from other actions given expert states, which is totally different.</p><p>Some of previous works (<xref ref-type="bibr" rid="b0">Peters et al., 2010</xref>; <xref ref-type="bibr" rid="b1">Azar et al., 2012</xref>; <xref ref-type="bibr" rid="b5">Schulman et al., 2015</xref>; <xref ref-type="bibr" rid="b9">Haarnoja et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Neu et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Abdolmaleki et al., 2018</xref>; <xref ref-type="bibr" rid="b9">Haarnoja et al., 2018</xref>; <xref ref-type="bibr" rid="b7">Geist et al., 2019</xref>) studied the entropy regularization MDPs. Although there exist some similarities between our method and these works in terms of formulation, these methods are not very suitable for the RLfD problem studied in this paper. Particularly, these methods do not encourage the agent to reach demonstrated states (states visited by the expert strategy) explicitly, but it is a very important unique property of RLfD problem itself (<xref ref-type="bibr" rid="b0">Ho &amp; Ermon, 2016</xref>; <xref ref-type="bibr" rid="b0">Kang et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Reddy et al., 2019</xref>). By contrast, in our work, we delicately design a new policy-dependent shaping reward, in order to not only imitate demonstrated actions over these demonstrated states, but also reach demonstrated states, specifically for the RLfD problem. In addition, most of these works assume that the explicit expression of initial policy is available, but in our case, we can only access to expert demonstrations. To this end, we use the GAN technique to replace the necessary of explicit expression of &#960; E , and take advantage of support estimation techniques to estimate the indicator function of supp &#960; E (s), which also leads to an obvious difference between these entropy regularization works and our work.</p></sec><sec><title>BACKGROUND</title></sec><sec><title>MARKOV DECISION PROCESS</title><p>We consider the standard Markov Decision Process (MDP) (<xref ref-type="bibr" rid="b0">Sutton &amp; Barto, 1998</xref>), defined by the tuple S, A, P, r, &#947; , where S and A are the state space and the action space respectively, P (s |s, a) is the transition distribution, r(s, a) is the reward function, and &#947; &#8712; (0, 1) is the discount factor. Given a stochastic policy &#960;(a|s) that maps states to action probabilities, the performance of &#960; is usually evaluated by its expected discounted return &#951;(&#960;): &#951;(&#960;) = E &#964; &#8764;p0,&#960;,p [ &#8734; t=0 &#947; t r(s t , a t )], (1) where &#964; = (s 0 , a 0 , s 1 , ...) denotes a trajectory generated by policy &#960;. Reinforcement Learning (RL) (<xref ref-type="bibr" rid="b0">Sutton &amp; Barto, 1998</xref>) reflects the learning paradigm trying to infer a policy maximizing &#951;(&#960;). Definition 1. (Occupancy measure). Let &#961; &#960; (s): S &#8594; R denote the unnormalized distribution of state visitation by following policy &#960; in the environment:</p><p>The unnormalized distribution of state-action pairs &#961; &#960; (s, a) = &#961; &#960; (s)&#960;(a|s) is called occupancy measure of policy &#960;. Intuitively, the occupancy measure can be interpreted as the distribution of state-action pairs that an agent encounters when navigating the environment with policy &#960;. An important property of the occupancy measure is the one-to-one correspondence with the policy, as described in the theorem 2 of (<xref ref-type="bibr" rid="b0">Syed et al., 2008</xref>).</p></sec><sec><title>DEMONSTRATION DATA SETTING</title><p>We formalize the demonstration data setting considered in this paper. The agent is provided with a few (and possibly imperfect) demonstrations as follows:</p><p>D E are sampled from executing an unknown expert policy &#960; E in the environment. For the follow-up convergence guarantee, we have the following necessary assumption on the expert policy &#960; E :</p><p>Assumption 1. The expert policy &#960; E is a stochastic policy, and there exists a positive value &#948; satisfying that min a&#8712;A &#960; E (a|s) &#8805; &#948;, &#8704;s &#8712; S.</p><p>The point of this assumption is to ensure that D KL (&#960;, &#960; E ) is bounded by a constant M for any &#960; &#8712; &#928;, under the tabular setting with |A| &lt; &#8734;. 2 Based on this, the augmented reward of our method (as shown later in Eq. 3) is also bounded, which can further lead to the convergence of demonstration policy evaluation (i.e. Lemma 1). In order to provide both guidance over all states and the supervision more directly on demonstrated states, we propose an objective function with policy dependent shaping reward:</p><p>policy-dependent KL augmented reward ], (3) where 1 s&#8712;supp &#961; E (s) stands for the indicator function of supp &#961; &#960; E (s) 3 , andD KL (&#960;(&#183;|s), &#960; E (&#183;|s)) M &#8722; D KL (&#960;(&#183;|s), &#960; E (&#183;|s)) 4 . More concretely, if state s is unseen in the demonstrated states, the Under review as a conference paper at ICLR 2020 augmented reward equals zero; Otherwise, the augmented reward is a positive number, indicating that a current policy &#960; closer to the expert policy &#960; E will give rise to larger augmented reward. In this way, we can encourage the agent to both reach the demonstrated states and take action in a way similar to expert. Besides, we can prove that the optimal policy of our proposed objective is equal to that of the original RL objective, under the assumption that the expert policy &#960; E is the optimal policy. The detailed proof can be found in Appendix B.</p><p>Since our shaping reward depends on the current policy &#960;, optimizing the objective (Eq. 3) w.r.t the policy &#960; enables us to directly optimize the policy-dependent shaping reward itself. In other words, we can directly minimize the KL divergence between &#960; and &#960; E over those demonstrated states. Detailed optimization will be illustrated in the policy improvement part in Eq. 8. Inspired by soft value function in SAC (<xref ref-type="bibr" rid="b9">Haarnoja et al., 2018</xref>), we further introduce demonstration value function V &#960; (s), by including the shaping reward at every time horizon:</p><p>In a similar way, we also define demonstration Q-value function Q &#960; (s, a) by including shaping reward at every time horizon, except the initial time horizon:</p><p>In the remainder of this section, we will first derive the Demonstration Policy Iteration method in Section 4.1, with the convergence guarantee under the tabular setting given the assumption of known &#960; E (a|s). However, the explicit expression of &#960; E is usually missing in reality. To tackle this challenge, we further develop the DAC algorithm in Section 4.2, which is more practical in real scenarios. Finally, we summarize the whole DAC algorithm in Algorithm 1.</p></sec><sec><title>DEMONSTRATION POLICY ITERATION</title><p>Given the assumption that &#960; E (a|s) is known, we derive the demonstration policy iteration method, which alternates between policy evaluation and policy improvement. Our derivation is based on a tabular setting, for the purpose of theoretical analysis and convergence guarantee. The policy evaluation step aims at computing the demonstration Q-value function of a policy &#960;, which includes both the extrinsic reward and the shaping reward from demonstrations. Specifically, the demonstration Q-value function Q &#960; (s, a) can be computed iteratively, starting from any function Q : S &#215; A &#8594; R and repeatedly applying a Bellman backup operator T &#960; given by:</p><p>The detailed evaluation process is formalized below.</p><p>Lemma 1. (Demonstration Policy Evaluation). Consider the demonstration Bellman backup operator T &#960; in Eq. 6 and a initial Q function Q 0 : S &#215; A &#8594; R with |A| &lt; &#8734;, and define Q k+1 = T &#960; Q k . Then the sequence Q k will converge to the demonstration Q-value of &#960; as k &#8594; &#8734;.</p><p>In the policy improvement step, for each state, we update the policy according to:</p><p>This particular choice of update can be guaranteed to result in an improved policy in terms of its demonstration Q-value function. This update rule consists of two different parts: the first one refers to the expectation of Q &#960; old (s, a), which encourages the agent to obtain more cumulative rewards and visit the demonstrated states, and the other part signifies the direct supervision signals over these demonstrated states. The indicator function of supp &#961; E (s) determines whether the current state s belongs to the demonstrated states, and if it is true, the KL divergence term will enforce the matching between the learned policy &#960; and the expert policy &#960; E .</p><p>We formalize the detailed improvement result in Lemma 2.</p><p>Under review as a conference paper at ICLR 2020 Lemma 2. (Demonstration Policy Improvement). Let &#960; old &#8712; &#928; and let &#960; new be the optimizer of the maximization problem defined in Eq. 8. Then</p><p>Overall, the complete demonstration policy iteration algorithm alternates between the policy eval- uation and the policy improvement steps, and it will provably converge to the optimal policy, as demonstrated in Theorem 1. We refer readers to Appendix C for the detailed proof. Theorem 1. (Demonstration Policy Iteration). Repeated application of demonstration policy eval- uation and demonstration policy improvement from any &#960; &#8712; &#928; converges to a policy &#960; * such that</p></sec><sec><title>DEMONSTRATION ACTOR CRITIC</title><p>The derived demonstration policy iteration above is presumed to be under the tabular setting with known explicit expression of the expert policy &#960; E (a|s), which is, however, usually missing in reality. Thus, a critical challenge remains as how to develop a practical DAC algorithm under the common real scenarios where only demonstration data D E exists.</p><p>First, we use function approximators (e.g. deep neural network), including value network V &#981; (s), Q-value network Q &#966; (s, a) and policy network &#960; &#952; (a|s). Computing the ratio between the current policy &#960;(a|s) and the expert policy &#960; E (a|s) is a necessary part of our derived theory, as shown in Eq. 7 and Eq. 8 5 , especially when &#960; E (a|s) is unknown. To tackle this challenge, we borrow the idea of the discriminative modeling in Generative Adversarial Networks (GANs) (<xref ref-type="bibr" rid="b8">Goodfellow et al., 2014</xref>), which is used to differentiate the real data from those created by the generator. In our case, we construct a discriminator network D w (s, a) that can distinguish whether an action is from &#960;(a|s) or &#960; E (a|s) given state s. More formally, Theorem 2. Given the policy &#960; and expert policy &#960; E , we define that</p><p>Based on this theorem, the ratio of &#960;(a|s) to &#960; E (a|s) can be equivalently written as D * (s,a) 1&#8722;D * (s,a) . Then, we parameterize D * (s, a) to the discriminator network D w (s, a), and train the discriminator with the demonstration data. We continue deriving update rules for the value functions and policy. The value function V &#981; (s) is trained to minimize the squared residual error:</p><p>The Q-value function is trained to minimize the bellman residual: J Q (&#966;) = E s,a&#8764;D [ 1 2 (Q &#966; (s, a) &#8722;Q(s, a)) 2 ], (10) whereQ(s, a) = r(s, a) + &#947;E s &#8764;p(&#183;|s,a) [V &#981; (s )]. Finally, the policy parameter can be learned by applying the policy update rule from Eq. 8:</p><p>We can find that the above objective includes both the Q-function Q &#966; (s, a) and discriminator D w (s, a), which are represented by neural networks and can be differentiated. Hence, it is very convenient to apply the reparameterization trick, which can lead to a low-variance estimator. To this end, we reparameterize the policy using a neural network transformation: a = f &#952; ( ; s), (12) where is an input noise vector sampled from some fixed distribution, such as multivariate Gaussian. Then we can rewrite the objective in Eq. 11 as below:</p><p>Similarly, the above learning objective w.r.t the policy network &#960; &#952; also consists of two different parts as Eq. 8. In particular, the gradient from the discriminator D w (s, a), which aims to distinguish whether an action is from the expert &#960; E or the learned policy &#960; &#952; given the current state, will guide the agent to take actions in accordance with the expert when it encounters the demonstrated states. On the other hand, the gradient from the Q-value function Q &#966; (s, a) will encourage the agent to obtain more cumulative rewards and explore the demonstrated region. Overall, our practical algorithm alternates between collecting experience from the environment, and updating the function approximators. We use off-policy data from a replay buffer to train the value and policy networks, and use demonstration data to train the discriminator network.</p></sec><sec><title>Practical Expert Policy Support Estimation</title><p>The indicator function of supp &#961; E is a key compo- nent in our DAC algorithm, which indicates whether current state s belongs to demonstrated states. However, in practice, the expert policy is unknown and only a finite number of trajectories sampled according to &#960; E are available. Consequently, we consider taking advantage of support estimation techniques to estimate this indicator function.</p><p>Recently, <xref ref-type="bibr" rid="b0">Wang et al. (2019)</xref> have established a connection between support estimation ideas and Random Network Distillation (RND) (<xref ref-type="bibr" rid="b3">Burda et al., 2018</xref>) - a method to design intrinsic reward for RL exploration based on the "novelty" of states visited. Their design of intrinsic reward is based on the observation that neural networks tend to have significantly lower prediction errors on examples similar to those on which they have been trained, which also inspires us to use prediction errors of networks trained on the demonstration states to approximate the indicator function of supp &#961; E .</p><p>In particular, we introduce two neural networks: a label network representing the prediction task and a predictor network trained on demonstration states. Note that, the label network is randomly initialized but fixed then, and it takes a state as input with a scalar output, i.e., f : S &#8594; R, and the predictor networkf : S &#8594; R is trained to minimize the expected MSE w.r.t its parameter &#968;, as shown below:</p><p>This process distills a randomly initialized neural network into a trained one. The prediction error is expected to be higher for the states that are outside demonstrated states. Based on that, the approximate indicator function can be eventually defined as follows: 1 s&#8712;supp &#961; E (s) &#8776; exp (&#8722;&#181;||f (s; &#968; * ) &#8722; f (s)|| 2 ), (15) where &#181; stands for the temperature parameter. As the L2 norm is non-negative, the approximate indicator function ranges from 0 to 1. We choose &#181; to make that from demonstrated states are mostly close to 1.</p><p>Overall, the complete DAC algorithm can be summarized in Algorithm 1.</p><p>Algorithm 1 Demonstration Actor Critic (DAC)</p><p>1: Input: Demonstration dataset D E , replay buffer D, policy parameter &#952;, demonstration value function parameter &#981;, demonstration Q-function parameter &#966;, discriminator parameter w, label and predictor parameters &#968; f , &#968;f .</p><p>2: Initialize the label parameter &#968; f , and train the predictor parameter &#968;f with dataset D E via Eq. 14.</p><p>3: for each iteration do 4: Sample trajectories by using the policy network &#960; &#952; and store transitions into D.</p></sec><sec><title>EXPERIMENTS</title><p>For the experiments below, we provide empirical results to answer the following questions:</p><p>1. Can our DAC algorithm achieve better performance than other counterparts, from the same RLfD setting or other settings?</p><p>2. What is the key ingredient in our algorithm that introduces better empirical results? To answer the first question, we evaluate our method against several baselines on five sparse physics- based based control benchmarks. Regarding the second question, we explore ablation analysis of the two major components in our algorithm (namely the KL shaped reward and direct KL policy loss). Due to the space limit, we defer more detailed specifications into the appendix.</p></sec><sec><title>COMPARATIVE EVALUATION</title></sec><sec><title>Experiment Settings</title><p>We conduct experiments on the sparse version of five popular continuous control tasks (Hopper-v1, HalfCheetah-v1, Walker2d-v1, Ant-v1, Humanoid-v1) from OpenAI Gym (<xref ref-type="bibr" rid="b5">Duan et al., 2016</xref>) . Specifically, we use the delayed version of the Mujoco domains 6 as (<xref ref-type="bibr" rid="b0">Zheng et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Oh et al., 2018</xref>) did, where the reward is made sparse by accumulating the reward for N = 10 timesteps before it to the agent. Expert's trajectories were collected from the expert policy released by the authors of the original GAIL 7 . In particular, the maximum number of expert trajectories was chosen as (<xref ref-type="bibr" rid="b0">Ho &amp; Ermon, 2016</xref>; <xref ref-type="bibr" rid="b0">Jeon et al., 2018</xref>), i.e. 240 for Humanoid-v1 and 25 for all other tasks. For all tasks, feedforward neural networks with two hidden layers are used to represent the policy and value functions, where 256 hidden units for each hidden layer and relu activations are used. For the policy, Gaussian policy is used with both mean and variance dependent on the state. During training, we use the Adam optimizer (<xref ref-type="bibr" rid="b0">Kingma &amp; Ba, 2015</xref>), with a learning rate of 3 &#215; 10 &#8722;4 for all networks and set K = 1 to make the algorithm faster in terms of wall clock time. We refer readers to Appendix D for more implementation details.</p><p>For comparative evaluation, We compare our DAC algorithm against five strong and off-the-shelf baselines including:</p><p>1. Policy Optimization with Demonstration (POfD): the algorithm of (<xref ref-type="bibr" rid="b0">Kang et al., 2018</xref>) leveraging demonstration to reshape the reward function.</p><p>2. Policy Optimization with Demonstration with Behavior Cloning (POfDBC): the simple combination of POfD algorithm and an augmented behavior cloning loss.</p><p>3. Deep Deterministic Policy Gradient from Demonstration (DDPGfD): the algorithm of <xref ref-type="bibr" rid="b0">Vecerik et al. (2017)</xref> putting demonstrations into the replay buffer as self-generated data.</p><p>4. Generative Adversarial Imitation Learning (GAIL): the algorithm of (<xref ref-type="bibr" rid="b0">Ho &amp; Ermon, 2016</xref>), a popular imitation learning method, mimicking the expert behaviour by matching the occupancy measure between the expert policy and the learned policy.</p><p>5. Soft Actor Critic (SAC): the algorithm of (<xref ref-type="bibr" rid="b9">Haarnoja et al., 2018</xref>), a state-of-the-art off-policy reinforcement learning method, building upon the maximum entropy reinforcement learning framework.</p><p>We report the average of the score of the agent over 10 episodes for every 10k steps performed in the environment, as shown in <xref ref-type="fig" rid="fig_0">Fig. 1</xref>. The results show that DAC performs consistently across all tasks, and outperforms all strong baselines in terms of both sample efficiency and final performance. Besides, on most benchmarks, DAC displays smaller shaded region than other baselines, which implies that DAC can be more stable and robust across different random seeds. Observing the learning curves of different methods, it is clear that SAC cannot learn very fast without the help of expert demonstrations, especially when the feedback is sparse. On the other hand, GAIL can improve quickly in the early stage of training process of several tasks, e.g. Walker2d-v1, but it tends to be limited by the quality of demonstration later. Under the same RLfD setting, DAC also significantly outperforms other counterparts, such as POfD, DDPGfD, and POfDBC, which is a simple combination of POfD Under review as a conference paper at ICLR 2020 (a) (b) (c) (d) (e) algorithm and an augmented behavior cloning loss, across all the benchmarks. Furthermore, we can see that the more complex benchmarks, e.g. Ant-v1 and Humanoid-v1, are exceptionally difficult to be solved by other baselines. In stark contrast, DAC can learn the policy fast and steadily.</p></sec><sec><title>ABLATION STUDY</title><p>The previous results suggest that our proposed method can outperform other strong baselines on several challenging tasks. Now we will further perform ablation study to investigate the influence of two major components inside our algorithm, i.e., the KL reward shaping and direct KL policy loss, on the overall performance of our DAC.</p><p>We conduct two ablation experiments on HalfCheetah-v1 by removing the KL augmented reward when computing Q-function, and the direct KL policy loss during policy improvement, respectively 8 . The comparative results are shown in <xref ref-type="fig" rid="fig_1">Fig. 2</xref>. We can observe that removing either of the two compo- nents will lead to the obvious degradation in learning per- formance. This suggests that both the KL reward shaping and the direct KL policy loss effectively contribute to the overall performance of our DAC algorithm. Furthermore, we find the degradation of removing the direct KL policy loss is even larger than that of removing the KL reward shaping in this HalfCheetah-v1 task, which well demon- strates that the exploitation of direct supervision signal present in demonstration data may play an important role for better learning performance.</p></sec><sec><title>CONCLUSIONS AND FUTURE WORK</title><p>In this paper, we studied reinforcement learning from demonstration (RLfD) and focused on develop- ing a novel method that can not only provide guidance on all states, but also pass supervision signal more directly on demonstrated states. We propose a novel objective function with policy-dependent shaping reward, and derive both theoretical guarantee (Demonstration Policy Interation) and practical algorithm (Demonstration Actor Critic) for our objective function. Experiments on a range of popular benchmark sparse-reward tasks show that our method consistently achieves much higher performance than several strong and off-the-shelf baselines. For future work, we will explore the direction for improving the robustness of DAC in terms of the demonstration quality, which is not particularly modeled in current algorithm.</p></sec><sec id="figures"><title>Figures</title><fig id="fig_0"><object-id>fig_0</object-id><label>Figure 1:</label><caption><title>Figure 1:</title><p>Learning curves of DAC and five baselines on sparse continuous control benchmarks. Solid curves depict the mean of ten trials and shaded regions correspond to standard deviation among trials. DAC (blue) performs consistently across all tasks and outperforms all strong baselines.</p></caption><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /></fig><fig id="fig_1"><object-id>fig_1</object-id><label>Figure 2:</label><caption><title>Figure 2:</title><p>Ablation curves.</p></caption><graphic /><graphic /></fig></sec></body><back><sec><p>These two components correspond to two different parts in Eq. 8, respectively.</p></sec><ref-list id="ref-list-1"><ref id="b0"><element-citation publication-type="journal"><article-title>Maximum a posteriori policy optimisation</article-title><source>CoRR</source><year>2018</year><person-group person-group-type="author"><name><surname>References Abbas Abdolmaleki</surname><given-names>Jost Tobias</given-names></name><name><surname>Springenberg</surname><given-names>Yuval</given-names></name><name><surname>Tassa</surname><given-names>R&#233;mi</given-names></name><name><surname>Munos</surname><given-names>Nicolas</given-names></name><name><surname>Heess</surname><given-names>Martin A</given-names></name><name><surname>Riedmiller</surname><given-names /></name></person-group></element-citation></ref><ref id="b1"><element-citation publication-type="journal"><article-title>Dynamic policy programming</article-title><source>J. Mach. Learn. Res.</source><year>2012</year><volume>13</volume><issue>1</issue><fpage>3207</fpage><lpage>3245</lpage><person-group person-group-type="author"><name><surname>Mohammad Gheshlaghi Azar</surname><given-names>Vicen&#231;</given-names></name><name><surname>G&#243;mez</surname><given-names>Hilbert J</given-names></name><name><surname>Kappen</surname><given-names /></name></person-group></element-citation></ref><ref id="b2"><element-citation publication-type="journal"><article-title>Reinforcement learning from demonstration through shaping</article-title><source>IJCAI</source><year>2015</year><person-group person-group-type="author"><name><surname>Brys</surname><given-names>Tim</given-names></name><name><surname>Harutyunyan</surname><given-names>Anna</given-names></name><name><surname>Bener Suay</surname><given-names>Halit</given-names></name><name><surname>Chernova</surname><given-names>Sonia</given-names></name><name><surname>Taylor</surname><given-names>Matthew E</given-names></name><name><surname>Now&#233;</surname><given-names>Ann</given-names></name></person-group></element-citation></ref><ref id="b3"><element-citation publication-type="journal"><article-title>Exploration by random network distillation</article-title><source>CoRR, abs/1810.12894</source><year>2018</year><person-group person-group-type="author"><name><surname>Burda</surname><given-names>Yuri</given-names></name><name><surname>Edwards</surname><given-names>Harrison</given-names></name><name><surname>Storkey</surname><given-names>Amos J</given-names></name><name><surname>Klimov</surname><given-names>Oleg</given-names></name></person-group></element-citation></ref><ref id="b4"><element-citation publication-type="journal"><article-title>Direct policy iteration with demonstrations</article-title><year>2015</year><fpage>3380</fpage><lpage>3386</lpage><person-group person-group-type="author"><name><surname>Chemali</surname><given-names>Jessica</given-names></name><name><surname>Lazaric</surname><given-names>Alessandro</given-names></name></person-group></element-citation></ref><ref id="b5"><element-citation publication-type="journal"><article-title>Benchmarking deep reinforcement learning for continuous control</article-title><source>International Conference on Machine Learning</source><year>2016</year><person-group person-group-type="author"><name><surname>Duan</surname><given-names>Yan</given-names></name><name><surname>Chen</surname><given-names>Xi</given-names></name><name><surname>Houthooft</surname><given-names>Rein</given-names></name><name><surname>Schulman</surname><given-names>John</given-names></name><name><surname>Abbeel</surname><given-names>Pieter</given-names></name></person-group></element-citation></ref><ref id="b6"><element-citation publication-type="journal"><article-title>Reinforcement learning from imperfect demonstrations</article-title><source>CoRR</source><year>2018</year><person-group person-group-type="author"><name><surname>Gao</surname><given-names>Yang</given-names></name><name><surname>Xu</surname><given-names>Huazhe</given-names></name><name><surname>Lin</surname><given-names>Ji</given-names></name><name><surname>Yu</surname><given-names>Fisher</given-names></name><name><surname>Levine</surname><given-names>Sergey</given-names></name></person-group></element-citation></ref><ref id="b7"><element-citation publication-type="journal"><article-title>A theory of regularized markov decision processes</article-title><source>CoRR, abs/1901.11275</source><year>2019</year><person-group person-group-type="author"><name><surname>Geist</surname><given-names>Matthieu</given-names></name><name><surname>Scherrer</surname><given-names>Bruno</given-names></name><name><surname>Pietquin</surname><given-names>Olivier</given-names></name></person-group></element-citation></ref><ref id="b8"><element-citation publication-type="journal"><source>Advances in Neural Information Process- ing Systems</source><year>2014</year><volume>27</volume><fpage>2672</fpage><lpage>2680</lpage><person-group person-group-type="author"><name><surname>Goodfellow</surname><given-names>Ian</given-names></name><name><surname>Pouget-Abadie</surname><given-names>Jean</given-names></name><name><surname>Mirza</surname><given-names>Mehdi</given-names></name><name><surname>Xu</surname><given-names>Bing</given-names></name><name><surname>Warde-Farley</surname><given-names>David</given-names></name><name><surname>Ozair</surname><given-names>Sherjil</given-names></name><name><surname>Courville</surname><given-names>Aaron</given-names></name><name><surname>Bengio</surname><given-names>Yoshua</given-names></name></person-group></element-citation></ref><ref id="b9"><element-citation publication-type="journal"><source>Doina Precup and Yee Whye Teh (eds.), Proceedings of the 34th International Conference on Machine Learning, volume 70 of Proceedings of Machine Learning Research</source><fpage>1352</fpage><lpage>1361</lpage><person-group person-group-type="author"><name><surname>Haarnoja</surname><given-names>Tuomas</given-names></name><name><surname>Tang</surname><given-names>Haoran</given-names></name><name><surname>Abbeel</surname><given-names>Pieter</given-names></name><name><surname>Levine</surname><given-names>Sergey</given-names></name></person-group></element-citation></ref><ref id="b10"><element-citation publication-type="journal"><article-title>Soft actor-critic: Off-policy maximum entropy deep reinforcement learning with a stochastic actor</article-title><year>2018</year><fpage>1861</fpage><lpage>1870</lpage><person-group person-group-type="author"><name><surname>Haarnoja</surname><given-names>Tuomas</given-names></name><name><surname>Zhou</surname><given-names>Aurick</given-names></name><name><surname>Abbeel</surname><given-names>Pieter</given-names></name><name><surname>Levine</surname><given-names>Sergey</given-names></name></person-group></element-citation></ref><ref id="b11"><element-citation publication-type="journal"><article-title>Deep reinforcement learning that matters</article-title><source>arXiv preprint arXiv:1709.06560</source><year>2017</year><person-group person-group-type="author"><name><surname>Henderson</surname><given-names>Peter</given-names></name><name><surname>Islam</surname><given-names>Riashat</given-names></name><name><surname>Bachman</surname><given-names>Philip</given-names></name><name><surname>Pineau</surname><given-names>Joelle</given-names></name><name><surname>Precup</surname><given-names>Doina</given-names></name><name><surname>Meger</surname><given-names>David</given-names></name></person-group></element-citation></ref></ref-list></back></article>