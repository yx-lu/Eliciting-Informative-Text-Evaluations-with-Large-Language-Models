Title:
```
Published as a conference paper at ICLR 2020 MODEL BASED REINFORCEMENT LEARNING FOR ATARI
```
Abstract:
```
Model-free reinforcement learning (RL) can be used to learn effective policies for complex tasks, such as Atari games, even from image observations. However, this typically requires very large amounts of interaction - substantially more, in fact, than a human would need to learn the same games. How can people learn so quickly? Part of the answer may be that people can learn how the game works and predict which actions will lead to desirable outcomes. In this paper, we explore how video prediction models can similarly enable agents to solve Atari games with fewer interactions than model-free methods. We describe Simulated Policy Learning (SimPLe), a complete model-based deep RL algorithm based on video prediction models and present a comparison of several model architectures, including a novel architecture that yields the best results in our setting. Our experiments evaluate SimPLe on a range of Atari games in low data regime of 100k interactions between the agent and the environment, which corresponds to two hours of real-time play. In most games SimPLe outperforms state-of-the-art model-free algorithms, in some games by over an order of magnitude. * Equal contribution, authors listed in random order. BO performed the work partially during an internship at Google Brain. Correspondence to: b.osinski@mimuw.edu.pl
```

Figures/Tables Captions:
```
Figure 1: Main loop of SimPLe. 1) the agent starts interacting with the real environment following the latest policy (initialized to random). 2) the collected observations will be used to train (update) the current world model. 3) the agent updates the policy by acting inside the world model. The new policy will be evaluated to measure the performance of the agent as well as collecting more data (back to 1). Note that world model training is self-supervised for the observed states and supervised for the reward.
Figure 2: Architecture of the proposed stochastic model with discrete latent. The input to the model is four stacked frames (as well as the action selected by the agent) while the output is the next predicted frame and expected reward. Input pixels and action are embedded using fully connected layers, and there is per-pixel softmax (256 colors) in the output. This model has two main components. First, the bottom part of the network which consists of a skip-connected convolutional encoder and decoder. To condition the output on the actions of the agent, the output of each layer in the decoder is multiplied with the (learned) embedded action. Second part of the model is a convolutional inference network which approximates the posterior given the next frame, similarly to Babaeizadeh et al. (2017a). At training time, the sampled latent values from the approximated posterior will be discretized into bits. To keep the model differentiable, the backpropagation bypasses the discretization following Kaiser & Bengio (2018). A third LSTM based network is trained to approximate each bit given the previous ones. At inference time, the latent bits are predicted auto-regressively using this network. The deterministic model has the same architecture as this figure but without the inference network.
Figure 3: Comparison with Rainbow and PPO. Each bar illustrates the number of interactions with environment required by Rainbow (left) or PPO (right) to achieve the same score as our method (SimPLe). The red line indicates the 100K interactions threshold which is used by the our method.
Figure 4: Fractions of Rainbow and PPO scores at different numbers of interactions calculated with the formula (SimP Le_score@100K − random_score)/(baseline_score − random_score); if denominator is smaller than 0, both nominator and denominator are increased by 1. From left to right, the baselines are: Rainbow at 100K, Rainbow at 200K, PPO at 100K, PPO at 200K. SimPLe outperforms Rainbow and PPO even when those are given twice as many interactions.
Figure 5: Behaviour with respect to the number of used samples. We report number of frames required by PPO to reach the score of our models. Results are averaged over all games.
Figure 6: Impact of the environment stochasticity. The graphs are in the same format as Figure 3: each bar illustrates the number of interactions with environment required by Rainbow to achieve the same score as SimPLe (with stochastic discrete world model) using 100k steps in an environment with and without sticky actions.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Human players can learn to play Atari games in minutes ( Tsividis et al., 2017 ). However, some of the best model-free reinforcement learning algorithms require tens or hundreds of millions of time steps - the equivalent of several weeks of training in real time. How is it that humans can learn these games so much faster? Perhaps part of the puzzle is that humans possess an intuitive understanding of the physical processes that are represented in the game: we know that planes can fly, balls can roll, and bullets can destroy aliens. We can therefore predict the outcomes of our actions. In this paper, we explore how learned video models can enable learning in the Atari Learning Environment (ALE) benchmark  Bellemare et al. (2015) ;  Machado et al. (2018)  with a budget restricted to 100K time steps - roughly to two hours of a play time. Although prior works have proposed training predictive models for next-frame, future-frame, as well as combined future-frame and reward predictions in Atari games ( Oh et al. (2015) ;  Chiappa et al. (2017) ;  Leibfried et al. (2016) ), no prior work has successfully demonstrated model-based control via predictive models that achieve competitive results with model-free RL. Indeed, in a recent survey (Section 7.2 in  Machado et al. (2018) ) this was formulated as the following challenge: "So far, there has been no clear demonstration of successful planning with a learned model in the ALE". Using models of environments, or informally giving the agent ability to predict its future, has a fundamental appeal for reinforcement learning. The spectrum of possible applications is vast, including learning policies from the model ( Watter et al., 2015 ;  Finn et al., 2016 ;  Finn & Levine, 2017 ;  Ebert et al., 2017 ;  Hafner et al., 2019 ;  Piergiovanni et al., 2018 ;  Rybkin et al., 2018 ;  Sutton & Barto, Published as a conference paper at ICLR 2020  2017, Chapter 8), capturing important details of the scene ( Ha & Schmidhuber, 2018 ), encouraging exploration ( Oh et al., 2015 ), creating intrinsic motivation ( Schmidhuber, 2010 ) or counterfactual reasoning ( Buesing et al., 2019 ). One of the exciting benefits of model-based learning is the promise to substantially improve sample efficiency of deep reinforcement learning (see Chapter 8 in  Sutton & Barto (2017) ). Our work advances the state-of-the-art in model-based reinforcement learning by introducing a system that, to our knowledge, is the first to successfully handle a variety of challenging games in the ALE benchmark. To that end, we experiment with several stochastic video prediction techniques, including a novel model based on discrete latent variables. We present an approach, called Simulated Policy Learning (SimPLe), that utilizes these video prediction techniques and trains a policy to play the game within the learned model. With several iterations of dataset aggregation, where the policy is deployed to collect more data in the original game, we learn a policy that, for many games, successfully plays the game in the real environment (see videos on the project webpage https://goo.gl/itykP8). In our empirical evaluation, we find that SimPLe is significantly more sample-efficient than a highly tuned version of the state-of-the-art Rainbow algorithm ( Hessel et al., 2018 ) on almost all games. In particular, in low data regime of 100k samples, on more than half of the games, our method achieves a score which Rainbow requires at least twice as many samples. In the best case of Freeway, our method is more than 10x more sample-efficient, see  Figure 3 . Since the publication of the first preprint of this work, it has been shown in  van Hasselt et al. (2019) ;  Kielak (2020)  that Rainbow can be tuned to have better results in low data regime. The results are on a par with SimPLe - both of the model-free methods are better in 13 games, while SimPLe is better in the other 13 out of the total 26 games tested (note that in Section 4.2 van  Hasselt et al. (2019)  compares with the results of our first preprint, later improved).

Section Title: RELATED WORK
  RELATED WORK Atari games gained prominence as a benchmark for reinforcement learning with the introduction of the Arcade Learning Environment (ALE)  Bellemare et al. (2015) . The combination of reinforcement learning and deep models then enabled RL algorithms to learn to play Atari games directly from images of the game screen, using variants of the DQN algorithm ( Mnih et al., 2013 ; 2015;  Hessel et al., 2018 ) and actor-critic algorithms ( Mnih et al., 2016 ;  Schulman et al., 2017 ;  Babaeizadeh et al., 2017b ;  Wu et al., 2017 ;  Espeholt et al., 2018 ). The most successful methods in this domain remain model-free algorithms ( Hessel et al., 2018 ;  Espeholt et al., 2018 ). Although the sample complexity of these methods has substantially improved recently, it remains far higher than the amount of experience required for human players to learn each game ( Tsividis et al., 2017 ). In this work, we aim to learn Atari games with a budget of just 100K agent steps (400K frames), corresponding to about two hours of play time. Prior methods are generally not evaluated in this regime, and we therefore optimized Rainbow ( Hessel et al., 2018 ) for optimal performance on 1M steps, see Appendix E for details. Published as a conference paper at ICLR 2020  Oh et al. (2015)  and  Chiappa et al. (2017)  show that learning predictive models of Atari 2600 environments is possible using appropriately chosen deep learning architectures. Impressively, in some cases the predictions maintain low L 2 error over timespans of hundreds of steps. As learned simulators of Atari environments are core ingredients of our approach, in many aspects our work is motivated by  Oh et al. (2015)  and  Chiappa et al. (2017) , however we focus on using video prediction in the context of learning how to play the game well and positively verify that learned simulators can be used to train a policy useful in original environments. An important step in this direction was made by  Leibfried et al. (2016) , which extends the work of  Oh et al. (2015)  by including reward prediction, but does not use the model to learn policies that play the games. Most of these approaches, including ours, encode knowledge of the game in implicit way. Unlike this, there are works in which modeling is more explicit, for example  Ersen & Sariel (2014)  uses testbed of the Incredible Machines to learn objects behaviors and their interactions. Similarly  Guzdial et al. (2017)  learns an engine predicting interactions of predefined set of sprites in the domain of Super Mario Bros. Perhaps surprisingly, there is virtually no work on model-based RL in video games from images. Notable exceptions are the works of  Oh et al. (2017) ,  Sodhani et al. (2019) ,  Ha & Schmidhuber (2018) ,  Holland et al. (2018) ,  Leibfried et al. (2018)  and  Azizzadenesheli et al. (2018) .  Oh et al. (2017)  use a model of rewards to augment model-free learning with good results on a number of Atari games. However, this method does not actually aim to model or predict future frames, and achieves clear but relatively modest gains in efficiency.  Sodhani et al. (2019)  proposes learning a model consistent with RNN policy which helps to train policies that are more powerful than their model-free baseline.  Ha & Schmidhuber (2018)  present a way to compose a variational autoencoder with a recurrent neural network into an architecture that is successfully evaluated in the VizDoom environment and on a 2D racing game. The training procedure is similar to Algorithm 1, but only one iteration of the loop is needed as the environments are simple enough to be fully explored with random exploration.  Similarly, Alaniz (2018)  utilizes a transition model with Monte Carlo tree search to solve a block-placing task in Minecraft.  Holland et al. (2018)  use a variant of Dyna ( Sutton, 1991 ) to learn a model of the environment and generate experience for policy training in the context of Atari games. Using six Atari games as a benchmark  Holland et al. (2018)  measure the impact of planning shapes on performance of the Dyna-DQN algorithm and include ablations comparing scores obtained with perfect and imperfect models. Our method achieves around 330% of the Dyna-DQN score on Asterix, 120% on Q-Bert, 150% on Seaquest and 80% on Ms. Pac-Man.  Azizzadenesheli et al. (2018)  propose an algorithm called Generative Adversarial Tree Search (GATS) and for five Atari games train a GAN-based world model along with a Q-function.  Azizzadenesheli et al. (2018)  primarily discuss various failure modes of the GATS algorithm. Our method achieves around 64 times the score of GATS on Pong and 10 times on Breakout. 1 Outside of games, model-based reinforcement learning has been investigated at length for applications such as robotics ( Deisenroth et al., 2013 ). Though most of such works do not use image observations, several recent works have incorporated images into real-world ( Finn et al., 2016 ;  Finn & Levine, 2017 ;  Babaeizadeh et al., 2017a ;  Ebert et al., 2017 ;  Piergiovanni et al., 2018 ;  Paxton et al., 2019 ;  Rybkin et al., 2018 ;  Ebert et al., 2018 ) and simulated ( Watter et al., 2015 ;  Hafner et al., 2019 ) robotic control. Our video models of Atari environments described in Section 4 are motivated by models developed in the context of robotics. Another source of inspiration are discrete autoencoders proposed by  van den Oord et al. (2017)  and  Kaiser & Bengio (2018) . The structure of the model-based RL algorithm that we employ consists of alternating between learning a model, and then using this model to optimize a policy with model-free reinforcement learning. Variants of this basic algorithm have been proposed in a number of prior works, starting from  Dyna Q Sutton (1991)  to more recent methods that incorporate deep networks  Heess et al. (2015) ;  Feinberg et al. (2018) ;  Kalweit & Boedecker (2017) ;  Kurutach et al. (2018) .

Section Title: SIMULATED POLICY LEARNING (SIMPLE)
  SIMULATED POLICY LEARNING (SIMPLE) Reinforcement learning is formalized in Markov decision processes (MDP). An MDP is defined as a tuple (S, A, P, r, γ), where S is a state space, A is a set of actions available to an agent, P is the unknown transition kernel, r is the reward function and γ ∈ (0, 1) is the discount factor. In this work we refer to MDPs as environments and assume that environments do not provide direct access to the state (i.e., the RAM of Atari 2600 emulator). Instead we use visual observations, typically 210 × 160 RGB images. A single image does not determine the state. In order to reduce environment's partial observability, we stack four consecutive frames and use it as the observation. A reinforcement learning agent interacts with the MDP by issuing actions according to a policy. Formally, policy π is a mapping from states to probability distributions over A. The quality of a policy is measured by the value function E π +∞ t=0 γ t r t+1 |s 0 = s , which for a starting state s estimates the total discounted reward gathered by the agent. In Atari 2600 games our goal is to find a policy which maximizes the value function from the beginning of the game. Crucially, apart from an Atari 2600 emu- lator environment env we will use a neural network simulated environment env which we call a world model and describe in detail in Section 4. The en- vironment env shares the action space and reward space with env and produces visual observations in the same format, as it will be trained to mimic env. Our principal aim is to train a policy π using a sim- ulated environment env so that π achieves good per- formance in the original environment env. In this training process we aim to use as few interactions with env as possible. The initial data to train env comes from random rollouts of env. As this is unlikely to capture all aspects of env, we use the iterative method presented in Algorithm 1.

Section Title: WORLD MODELS
  WORLD MODELS In search for an effective world model we experimented with various architectures, both new and modified versions of existing ones. This search resulted in a novel stochastic video prediction model (visualized in  Figure 2 ) which achieved superior results compared to other previously proposed models. In this section, we describe the details of this architecture and the rationale behind our design decisions. In Section 6 we compare the performance of these models.

Section Title: Deterministic Model
  Deterministic Model Our basic architecture, presented as part of  Figure 2 , resembles the con- volutional feedforward network from  Oh et al. (2015) . The input X consists of four consecutive game frames and an action a. Stacked convolution layers process the visual input. The actions are one-hot-encoded and embedded in a vector which is multiplied channel-wise with the output of the convolutional layers. The network outputs the next frame of the game and the value of the reward. In our experiments, we varied details of the architecture above. In most cases, we use a stack of four convolutional layers with 64 filters followed by three dense layers (the first two have 1024 neurons). The dense layers are concatenated with 64 dimensional vector with a learnable action embedding. Next, three deconvolutional layers of 64 filters follow. An additional deconvolutional layer outputs an image of the original 105 × 80 size. The number of filters is either 3 or 3 × 256. In the first case, the output is a real-valued approximation of pixel's RGB value. In the second case, filters are followed by softmax producing a probability distribution on the color space. The reward is predicted by a softmax attached to the last fully connected layer. We used dropout equal to 0.2 and layer normalization.

Section Title: Loss functions
  Loss functions The visual output of our networks is either one float per pixel/channel or the categorical 256-dimensional softmax. In both cases, we used the clipped loss max(Loss, C) for a constant C. We found that clipping was crucial for improving the models (measured with the correct reward predictions per sequence metric and successful training using Algorithm 1). We conjecture that clipping substantially decreases the magnitude of gradients stemming from fine-tuning of big areas of background consequently letting the optimization process concentrate on small but important areas (e.g. the ball in Pong). In our experiments, we set C = 10 for L 2 loss on pixel values and to C = 0.03 for softmax loss. Note that this means that when the level of confidence about the correct pixel value exceeds 97% (as − ln(0.97) ≈ 0.03) we get no gradients from that pixel any longer.

Section Title: Scheduled sampling
  Scheduled sampling The model env consumes its own predictions from previous steps and due to compounding errors, the model may drift out of the area of its applicability. Following  Bengio et al. (2015) ;  Venkatraman et al. (2016) , we mitigate this problem by randomly replacing in training some frames of the input X by the prediction from the previous step while linearly increasing the mixing probability to 100% around the middle of the first iteration of the training loop.

Section Title: Stochastic Models
  Stochastic Models A stochastic model can be used to deal with limited horizon of past observed frames as well as sprites occlusion and flickering which results to higher quality predictions. Inspired by  Babaeizadeh et al. (2017a) , we tried a variational autoencoder ( Kingma & Welling, 2014 ) to model the stochasticity of the environment. In this model, an additional network receives the input frames as well as the future target frame as input and approximates the distribution of the posterior. At each timestep, a latent value z t is sampled from this distribution and passed as input to the original predictive model. At test time, the latent values are sampled from an assumed prior N (0, I). To match the assumed prior and the approximate, we use the Kullback-Leibler divergence term as an additional loss term ( Babaeizadeh et al., 2017a ). We noticed two major issues with the above model. First, the weight of the KL divergence loss term is game dependent, which is not practical if one wants to deal with a broad portfolio of Atari games. Second, this weight is usually a very small number in the range of [10 −3 , 10 −5 ] which means that the approximated posterior can diverge significantly from the assumed prior. This can result in previously unseen latent values at inference time that lead to poor predictions. We address these issues by utilizing a discrete latent variable similar to  Kaiser & Bengio (2018) . As visualized in  Figure 2 , the proposed stochastic model with discrete latent variables discretizes the latent values into bits (zeros and ones) while training an auxiliary LSTM-based  Hochreiter & Schmidhuber (1997)  recurrent network to predict these bits autoregressively. At inference time, the latent bits will be generated by this auxiliary network in contrast to sampling from a prior. To make the predictive model more robust to unseen latent bits, we add uniform noise to approximated latent Published as a conference paper at ICLR 2020 values before discretization and apply dropout ( Srivastava et al., 2014 ) on bits after discretization. More details about the architecture is in Appendix C.

Section Title: POLICY TRAINING
  POLICY TRAINING We will now describe the details of SimPLe, outlined in Algorithm 1. In step 6 we use the proximal policy optimization (PPO) algorithm ( Schulman et al., 2017 ) with γ = 0.95. The algorithm generates rollouts in the simulated environment env and uses them to improve policy π. The fundamental difficulty lays in imperfections of the model compounding over time. To mitigate this problem we use short rollouts of env . Typically every N = 50 steps we uniformly sample the starting state from the ground-truth buffer D and restart env (for experiments with the value of γ and N see Section 6.4). Using short rollouts may have a degrading effect as the PPO algorithm does not have a way to infer effects longer than the rollout length. To ease this problem, in the last step of a rollout we add to the reward the evaluation of the value function. Training with multiple iterations re-starting from trajectories gathered in the real environment is new to our knowledge. It was inspired by the classical Dyna-Q algorithm and, notably, in the Atari domain no comparable results have been achieved. The main loop in Algorithm 1 is iterated 15 times (cf. Section 6.4). The world model is trained for 45K steps in the first iteration and for 15K steps in each of the following ones. Shorter training in later iterations does not degrade the performance because the world model after first iteration captures already part of the game dynamics and only needs to be extended to novel situations. In each of the iterations, the agent is trained inside the latest world model using PPO. In every PPO epoch we used 16 parallel agents collecting 25, 50 or 100 steps from the simulated environment env (see Section 6.4 for ablations). The number of PPO epochs is z · 1000, where z equals to 1 in all passes except last one (where z = 3) and two passes number 8 and 12 (where z = 2). This gives 800K·z interactions with the simulated environment in each of the loop passes. In the process of training the agent performs 15.2M interactions with the simulated environment env .

Section Title: EXPERIMENTS
  EXPERIMENTS We evaluate SimPLe on a suite of Atari games from Atari Learning Environment (ALE) benchmark. In our experiments, the training loop is repeated for 15 iterations, with 6400 interactions with the environment collected in each iteration. We apply a standard pre-processing for Atari games: a frame skip equal to 4, that is every action is repeated 4 times. The frames are down-scaled by a factor of 2. Because some data is collected before the first iteration of the loop, altogether 6400 · 16 = 102, 400 interactions with the Atari environment are used during training. This is equivalent to 409, 600 frames from the Atari game (114 minutes at 60 FPS). At every iteration, the latest policy trained under the learned model is used to collect data in the real environment env. The data is also directly used to train the policy with PPO. Due to vast difference between number of training data from simulated environment and real environment (15M vs 100K) the impact of the latter on policy is negligible. We evaluate our method on 26 games selected on the basis of being solvable with existing state-of- the-art model-free deep RL algorithms 2 , which in our comparisons are  Rainbow Hessel et al. (2018)  and  PPO Schulman et al. (2017) . For Rainbow, we used the implementation from the Dopamine package and spent considerable time tuning it for sample efficiency (see Appendix E). For visualization of all experiments see https://goo.gl/itykP8 and for a summary see  Figure 3 . It can be seen that our method is more sample-efficient than a highly tuned Rainbow baseline on almost all games, requires less than half of the samples on more than half of the games and, on Freeway, is more than 10x more sample-efficient. Our method outperforms PPO by an even larger margin. We also compare our method with fixed score baselines (for different baselines) rather than counting how many steps are required to match our score, see  Figure 4  for the results. For the qualitative analysis of performance on different games see Appendix B. The source code is available as part of the Tensor2Tensor library and it includes instructions on how to run the experiments 3 .

Section Title: SAMPLE EFFICIENCY
  SAMPLE EFFICIENCY The primary evaluation in our experiments studies the sample efficiency of SimPLe, in comparison with state-of-the-art model-free deep RL methods in the literature. To that end, we compare with Rainbow ( Hessel et al., 2018 ;  Castro et al., 2018 ), which represents the state-of-the-art Q-learning method for Atari games, and PPO ( Schulman et al., 2017 ), a model-free policy gradient algorithm (see Appendix E for details of tuning of Rainbow and PPO). The results of the comparison are presented in  Figure 3 . For each game, we plot the number of time steps needed for either Rainbow or PPO to reach the same score that our method reaches after 100K interaction steps. The red line indicates 100K steps: any bar larger than this indicates a game where the model-free method required more steps. SimPLe outperforms the model-free algorithms in terms of learning speed on nearly all of the games, and in the case of a few games, does so by over an order of magnitude. For some games, it reaches the same performance that our PPO implementation reaches at 10M steps. This indicates that model-based reinforcement learning provides an effective approach to learning Atari games, at a fraction of the sample complexity. The results in these figures are generated by averaging 5 runs for each game. The model-based agent is better than a random policy for all the games except Bank Heist. Interestingly, we observed that the best of the 5 runs was often significantly better. For 6 of the games, it exceeds the average human score (as reported in Table 3 of  Pohlen et al. (2018) ). This suggests that further stabilizing SimPLe should improve its performance, indicating an important direction for future work. In some cases during training we observed high variance of the results during each step of the loop. There are a number of possible reasons, such as mutual interactions of the policy training and the supervised training or domain mismatch between the model and the real environment. We present detailed numerical results, including best scores and standard deviations, in Appendix D.

Section Title: NUMBER OF FRAMES
  NUMBER OF FRAMES We focused our work on learning games with 100K interaction steps with the environment. In this section we present additional results for settings with 20K, 50K, 200K, 500K and 1M interactions; see  Figure 5 (a) . Our results are poor with 20K interactions. For 50K they are already almost as good as with 100K interactions. From there the results improve until 500K samples - it is also the point at which they are on par with model-free PPO. Detailed per game results can be found in Appendix F. This demonstrates that SimPLe excels in a low data regime, but its advantage disappears with a bigger amount of data. Such a behavior, with fast growth at the beginning of training, but lower asymptotic performance is commonly observed when comparing model-based and model-free methods ( Wang et al. (2019) ). As observed in Section 6.4 assigning bigger computational budget helps in 100K setting. We suspect that gains would be even bigger for the settings with more samples. Finally, we verified if a model obtained with SimPLe using 100K is a useful initialization for model- free PPO training. Based on the results depicted in  Figure 5 (b)  we can positively answer this conjecture. Lower asymptotic performance is probably due to worse exploration. A policy pre-trained with SimPLe was meant to obtain the best performance on 100K, at which point its entropy is very low thus hindering further PPO training.

Section Title: ENVIRONMENT STOCHASTICITY
  ENVIRONMENT STOCHASTICITY A crucial decision in the design of world models is the inclusion of stochasticity. Although Atari is known to be a deterministic environment, it is stochastic given only a limited horizon of past observed frames (in our case 4 frames). The level of stochasticity is game dependent; however, it can be observed in many Atari games. An example of such behavior can be observed in the game Kung Fu Master - after eliminating the current set of opponents, the game screen always looks the same (it contains only player's character and the background). The game dispatches diverse sets of new opponents, which cannot be inferred from the visual observation alone (without access to the game's internal state) and thus cannot be predicted by a deterministic model. Similar issues have been reported in  Babaeizadeh et al. (2017a) , where the output of their baseline deterministic model was a blurred superposition of possible random object movements. As can be seen in Figure 11 in the Appendix, the stochastic model learns a reasonable behavior - samples potential opponents and renders them sharply. Given the stochasticity of the proposed model, Sim- PLe can be used with truly stochastic environments. To demonstrate this, we ran an experiment where the full pipeline (both the world model and the policy) was trained in the presence of sticky actions, as rec- ommended in ( Machado et al., 2018 , Section 5). Our world model learned to account for the stickiness of actions and in most cases the end results were very similar to the ones for the deterministic case even without any tuning, see  Figure 6 .

Section Title: ABLATIONS
  ABLATIONS To evaluate the design of our method, we indepen- dently varied a number of the design decisions. Here we present an overview; see Appendix A for detailed results.

Section Title: Model architecture and hyperparameters
  Model architecture and hyperparameters We evaluated a few choices for the world model and our proposed stochastic discrete model performs best by a significant margin. The second most important parameter was the length of world model's training. We verified that a longer training would be beneficial, however we had to restrict it in all other ablation stud- ies due to a high cost of training on all games. As for the length of rollouts from simulated env , we use N = 50 by default. We experimentally shown that N = 25 performs roughly on par, while N = 100 is slightly worse, likely due to compounding model errors. The discount factor was set to γ = 0.99 unless specified otherwise. We see that γ = 0.95 is slightly better than other values, and we hypothe- size that it is due to better tolerance to model imperfections. But overall, all three values of γ perform comparably.

Section Title: Model-based iterations
  Model-based iterations The iterative process of training the model, training the policy, and collect- ing data is crucial for non-trivial tasks where random data collection is insufficient. In a game-by-game analysis, we quantified the number of games where the best results were obtained in later iterations of training. In some games, good policies could be learned very early. While this might have been due to the high variability of training, it does suggest the possibility of much faster training (i.e. in fewer step than 100k) with more directed exploration policies. In Figure 9 in the Appendix we present the cumulative distribution plot for the (first) point during learning when the maximum score for the run was achieved in the main training loop of Algorithm 1.

Section Title: Random starts
  Random starts Using short rollouts is crucial to mitigate the compounding errors in the model. To ensure exploration, SimPLe starts rollouts from randomly selected states taken from the real data buffer D. Figure 9 compares the baseline with an experiment without random starts and rollouts of length 1000 on Seaquest which shows much worse results without random starts.

Section Title: CONCLUSIONS AND FUTURE WORK
  CONCLUSIONS AND FUTURE WORK We presented SimPLe, a model-based reinforcement learning approach that operates directly on raw pixel observations and learns effective policies to play games in the Atari Learning Environment. Our experiments demonstrate that SimPLe learns to play many of the games with just 100K interactions with the environment, corresponding to 2 hours of play time. In many cases, the number of samples required for prior methods to learn to reach the same reward value is several times larger. Our predictive model has stochastic latent variables so it can be applied in highly stochastic environ- ments. Studying such environments is an exciting direction for future work, as is the study of other ways in which the predictive neural network model could be used. Our approach uses the model as a learned simulator and directly applies model-free policy learning to acquire the policy. However, we could use the model for planning. Also, since our model is differentiable, the additional information contained in its gradients could be incorporated into the reinforcement learning process. Finally, the representation learned by the predictive model is likely be more meaningful by itself than the raw pixel observations from the environment. Incorporating this representation into the policy could further accelerate and improve the reinforcement learning process. While SimPLe is able to learn more quickly than model-free methods, it does have limitations. First, the final scores are on the whole lower than the best state-of-the-art model-free methods. This can be improved with better dynamics models and, while generally common with model-based RL algorithms, suggests an important direction for future work. Another, less obvious limitation is that the performance of our method generally varied substantially between different runs on the same game. The complex interactions between the model, policy, and data collection were likely responsible for this. In future work, models that capture uncertainty via Bayesian parameter posteriors or ensembles ( Kurutach et al., 2018 ;  Chua et al., 2018 ) may improve robustness. Finally, the computational and time requirement of training inside world model are substantial (see Appendix C), which makes developing lighter models an important research direction. In this paper our focus was to demonstrate the capability and generality of SimPLe only across a suite of Atari games, however, we believe similar methods can be applied to other environments and tasks which is one of our main directions for future work. As a long-term challenge, we believe that model-based reinforcement learning based on stochastic predictive models represents a promising and highly efficient alternative to model-free RL. Applications of such approaches to both high-fidelity simulated environments and real-world data represent an exciting direction for future work that can enable highly efficient learning of behaviors from raw sensory inputs in domains such as robotics and autonomous driving.

```
