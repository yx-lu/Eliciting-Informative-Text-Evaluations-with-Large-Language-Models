Title:
```
Published as a conference paper at ICLR 2020 DD-PPO: LEARNING NEAR-PERFECT POINTGOAL NAVIGATORS FROM 2.5 BILLION FRAMES
```
Abstract:
```
We present Decentralized Distributed Proximal Policy Optimization (DD-PPO), a method for distributed reinforcement learning in resource-intensive simulated en- vironments. DD-PPO is distributed (uses multiple machines), decentralized (lacks a centralized server), and synchronous (no computation is ever 'stale'), making it conceptually simple and easy to implement. In our experiments on training virtual robots to navigate in Habitat-Sim (Savva et al., 2019), DD-PPO exhibits near-linear scaling - achieving a speedup of 107x on 128 GPUs over a serial im- plementation. We leverage this scaling to train an agent for 2.5 Billion steps of experience (the equivalent of 80 years of human experience) - over 6 months of GPU-time training in under 3 days of wall-clock time with 64 GPUs. This massive-scale training not only sets the state of art on Habitat Autonomous Navigation Challenge 2019, but essentially 'solves' the task - near-perfect au- tonomous navigation in an unseen environment without access to a map, directly from an RGB-D camera and a GPS+Compass sensor. Fortuitously, error vs com- putation exhibits a power-law-like distribution; thus, 90% of peak performance is obtained relatively early (at 100 million steps) and relatively cheaply (under 1 day with 8 GPUs). Finally, we show that the scene understanding and navigation poli- cies learned can be transferred to other navigation tasks - the analog of 'ImageNet pre-training + task-specific fine-tuning' for embodied AI. Our model outperforms ImageNet pre-trained CNNs on these transfer tasks and can serve as a universal resource (all models and code are publicly available). Code: https://github.com/facebookresearch/habitat-api Video: https://www.youtube.com/watch?v=5PBp V5i1v4 * Work done while an intern at Facebook AI Research. Correspondence to etw@gatech.edu. 1 Environments in OpenAI Gym (Brockman et al., 2016) and Atari games can be simulated on solely CPUs.
```

Figures/Tables Captions:
```
Figure 1: Left: In PointGoal Navigation, an agent must navigate from a random starting location (blue) to a target location (red) specified relative to the agent ("Go 5m north, 10m east of you") in a previously unseen environment without access to a map. Right: Performance (SPL; higher is better) of an agent equipped with RGB-D and GPS+Compass sensors on the Habitat Challenge 2019 (Savva et al., 2019) train & val sets. Using DD-PPO, we train agents for over 180 days of GPU-time in under 3 days of wall-clock time with 64 GPUs, achieving state-of-art results and 'solving' the task.
Figure 2: Comparison of asynchronous distribution (left) and synchronous distribution via dis- tributed data parallelism (right) for RL. Left: rollout workers collect experience and asynchronously send it to the parameter-server. Right: a worker alternates between collecting experience, synchro- nizing gradients, and optimization. We find this highly effective in resource-intensive environments.
Figure 3: Our agent for PointGoalNav. At very time-step, the agent receives an egocentric Depth or RGB (shown here) observation, utilizes its GPS+Compass sensor to update the target position to be relative to its current position, and outputs the next action and an estimate of the value function.
Figure 4: Scaling performance (in steps of experience per second relative to 1 GPU) of DD-PPO for various preemption threshold, p%, values. Shading represents a 95% confidence interval.
Figure 5: Performance (higher is better) on Flee (left) and Exploration (right) under five settings. - Flee The agent maximizes its geodesic distance from its starting location. Let s t be the agent's position at time t, and M ax(s 0 ) denote the maximum distance over all reachable points, then the agent maximizes D T = Geo(s T , s 0 )/M ax(s 0 ). The reward is r t = 5(D t − D t−1 ). - Exploration The agent maximizes the number of locations (specified by 1m cubes) visited. Let |Visited t | denote the number of location visited at time t, then the agent maximizes |Visited T |. The reward is r t = 0.25(|Visited t | − |Visited t−1 |). We use a PointGoalNav-trained agent with RGB and GPS+Compass, remove the GPS+Compass, and transfer to these tasks under five different settings: - Scratch. All parameters (visual encoder + policy) are trained from scratch for each new task. Improvements over this baseline demonstrate benefits of transfer learning. - ImageNetEncoder-ScratchPolicy. The visual encoder is initialized with ImageNet pre-trained weights and frozen; the navigation policy is trained from scratch. - PointGoalNavEncoder-ScratchPolicy. The visual encoder is initialized from PointGoalNav and frozen; the navigation policy is trained from scratch. - PointGoalNavEncoder-FinetunePolicy. Both visual encoder and policy parameters are initial- ized from PointGoalNav (critic layers are reinitialized). Encoder is frozen, policy is fine-tuned. 7 - ∇ Neural Controller We treat our agent as a differentiable neural controller, a closed-loop low- level controller than can navigate to a specified coordinate. We utilize this controller in a new task by training a light-weight high-level planner that predicts a goal-coordinate (at each time-step) for the controller to navigate to. Since the controller is fully differentiable, we can backprop through it. We freeze the controller, train the planner+controller system with PPO for the new task. The planner is a 2-layer LSTM and shares the (frozen) visual encoder with the controller.
Table 1: Performance (higher is better) of different architectures for agents with RGB-D and GPS+Compass sensors on the Habitat Challenge 2019 (Savva et al., 2019) validation and test-std splits (checkpoint selected on val). 10 samples taken for each episode on val. Gibson-4+ (2+) refers to the subset of Gibson train scenes (Xia et al., 2018) with a quality rating of 4 (2) or higher. See Tab. 2 for results of the best DD-PPO agent for Blind, RGB, and RGB-D and other baselines.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Recent advances in deep reinforcement learning (RL) have given rise to systems that can outperform human experts at variety of games (Silver et al., 2017; Tian et al., 2019; OpenAI, 2018). These advances, even more-so than those from supervised learning, rely on significant numbers of training samples, making them impractical without large-scale, distributed parallelization. Thus, scaling RL via multi-node distribution is of importance to AI - that is the focus of this work. Several works have proposed systems for distributed RL (Heess et al., 2017; Liang et al., 2018a; Tian et al., 2019; Silver et al., 2016; OpenAI, 2018; Espeholt et al., 2018). These works utilize two core components: 1) workers that collect experience ('rollout workers'), and 2) a parameter server that optimizes the model. The rollout workers are then distributed across, potentially, thousands of CPUs 1 . However, synchronizing thousands of workers introduces significant overhead (the parame- ter server must wait for the slowest worker, which can be costly as the number of workers grows). To combat this, they wait for only a few rollout workers, and then asynchronously optimize the model. However, this paradigm - of a single parameter server and thousands of (typically CPU) workers - appears to be fundamentally incompatible with the needs of modern computer vision and robotics communities. Over the last few years, a large number of works have proposed training virtual robots (or 'embodied agents') in rich 3D simulators before transferring the learned skills to reality (Beattie Published as a conference paper at ICLR 2020

Section Title: Contributions
  Contributions We propose a simple, synchronous, distributed RL method that scales well. We call this method Decentralized Distributed Proximal Policy Optimization (DD-PPO) as it is decentralized (has no parameter server), distributed (runs across many different machines), and we use it to scale Proximal Policy Optimization (Schulman et al., 2017). In DD-PPO, each worker alternates between collecting experience in a resource-intensive and GPU accelerated simulated environment and optimizing the model. This distribution is synchronous - there is an explicit communication stage where workers synchronize their updates to the model (the gradients). To avoid delays due to stragglers, we propose a preemption threshold where the experience collection of stragglers is forced to end early once a pre-specified percentage of the other workers finish collecting experience. All workers then begin optimizing the model. We characterize the scaling of DD-PPO by the steps of experience per second with N workers rela- tive to 1 worker. We consider two different workloads, 1) simulation time is roughly equivalent for all environments, and 2) simulation time can vary dramatically due to large differences in environ- ment complexity. Under both workloads, we find that DD-PPO scales near-linearly. While we only examined our method with PPO, other on-policy RL algorithms can easily be used and we believe the method is general enough to be adapted to off -policy RL algorithms. We leverage these large-scale engineering contributions to answer a key scientific question aris- ing in embodied navigation. Mishkin et al. (2019) benchmarked classical (mapping + planning) and learning-based methods for agents with RGB-D and GPS+Compass sensors on PointGoal Nav- igation (Anderson et al., 2018a) (PointGoalNav), see  Fig. 1 , and showed that classical methods outperform learning-based. However, they trained for 'only' 5 million steps of experience. Savva et al. (2019) then scaled this training to 75 million steps and found that this trend reverses - learning- based outperforms classical, even in unseen environments! However, even with an order of magni- tude more experience (75M vs 5M), they found that learning had not yet saturated. This begs the question - what are the fundamental limits of learnability in PointGoalNav? Is this task entirely learnable? We answer this question affirmatively via an 'existence proof'. Utilizing DD-PPO, we find that agents continue to improve for a long time ( Fig. 1 ) - not only setting the state of art in Habitat Autonomous Navigation Challenge 2019 (Savva et al., 2019), but essen- tially 'solving' PointGoalNav (for agents with GPS+Compass). Specifically, these agents 1) almost Published as a conference paper at ICLR 2020 always reach the goal (failing on 1/1000 val episodes on average), and 2) reach it nearly as effi- ciently as possible - nearly matching (within 3% of) the performance of a shortest-path oracle! It is worth stressing how uncompromising that comparison is - in a new environment, an agent nav- igating without a map traverses a path nearly matching the shortest path on the map. This means there is no scope for mistakes of any kind - no wrong turn at a crossroad, no back-tracking from a dead-end, no exploration or deviation of any kind from the shortest-path. Our hypothesis is that the model learns to exploit the statistical regularities in the floor-plans of indoor environments (apart- ments, offices) in our datasets. The more challenging task of navigating purely from an RGB camera without GPS+Compass demonstrates progress but remains an open frontier. Finally, we show that the scene understanding and navigation policies learned on PointGoalNav can be transferred to other tasks (Flee and Explore (Gordon et al., 2019)) - the analog of 'ImageNet pre-training + task-specific fine-tuning' for Embodied AI. Our models are able to rapidly learn these new tasks (outperforming ImageNet pre-trained CNNs) and can be utilized as near-perfect neural PointGoal controllers, a universal resource for other high-level navigation tasks (Anderson et al., 2018b; Das et al., 2018). We make code and trained models publicly available.

Section Title: PRELIMINARIES: RL AND PPO
  PRELIMINARIES: RL AND PPO Reinforcement learning (RL) is concerned with decision making in Markov decision processes. In a partially observable MDP (POMDP), the agent receives an observation that does not fully specify the state (s t ) of the environment, o t (e.g. an egocentric RGB image), takes an action a t , and is given a reward r t . The objective is to maximize cumulative reward over an episode, Formally, let τ be a sequence of (o t , a t , r t ) where a t ∼ π(· | o t ), and s t+1 ∼ T (s t , a t ). For a discount factor γ, which balances the trade-off between exploration and exploitation, the optimal policy, π * , is specified by One technique to find π * is Proximal Policy Optimization (PPO) (Schulman et al., 2017), an on-policy algorithm in the policy-gradient family. Given a θ-parameterized policy π θ and a set of trajectories collected with it (commonly referred to as a 'rollout'), PPO updates π θ as follows. Let A t = R t − V t , be the estimate of the advantage, where R t = T i=t γ i−t r i , andV t is the expected value of R t , and r t (θ) = π θ (at|ot) π θ t (at|ot) be the ratio of the probability of the action a t under the cur- rent policy and the policy used to collect the rollout. The parameters are then updated by maximizing This clipped objective keeps this ratio within and functions as a trust-region optimization method; allowing for the multiple gradient updates using the rollout, thereby improving sample efficiency.

Section Title: DECENTRALIZED DISTRIBUTED PROXIMAL POLICY OPTIMIZATION
  DECENTRALIZED DISTRIBUTED PROXIMAL POLICY OPTIMIZATION In reinforcement learning, the dominant paradigm for distribution is asynchronous (see  Fig. 2 ). Asynchronous distribution is notoriously difficult - even minor errors can result in opaque crashes - and the parameter server and rollout workers necessitate separate programs. In supervised learning, however, synchronous distributed training via data parallelism (Hillis & Steele Jr, 1986) dominates. As a general abstraction, this method implements the following: at step k, worker n has a copy of the parameters, θ k n , calculates the gradient, ∂θ k n , and updates θ via θ k+1 n = ParamUpdate θ k n , AllReduce ∂θ k 1 , . . . , ∂θ k N = ParamUpdate θ k n , 1 N N i=1 ∂θ k i , (3) where ParamUpdate is any first-order optimization technique (e.g. gradient descent) and AllReduce performs a reduction (e.g. mean) over all copies of a variable and returns the result to all work- ers. Distributed DataParallel scales very well (near-linear scaling up to 32,000 GPUs (Kurth et al., 2018)), and is reasonably simple to implement (all workers synchronously running identical code). We adapt this to on-policy RL as follows: At step k, a worker n has a copy of the parameters θ k n ; it gathers experience (rollout) using π θ k n , calculates the parameter-gradients ∇ θ via any policy-gradient method (e.g. PPO), synchronizes these gradients with other workers, and updates the model: A key challenge to using this method in RL is variability in experience collection run-time. In super- vised learning, all gradient computations take approximately the same time. In RL, some resource- intensive environments can take significantly longer to simulate. This introduces significant syn- chronization overhead as every worker must wait for the slowest to finish collecting experience. To combat this, we introduce a preemption threshold where the rollout collection stage of these strag- glers is preempted (forced to end early) once some percentage, p%, (we find 60% to work well) of the other workers are finished collecting their rollout; thereby dramatically improving scaling. We weigh all worker's contributions to the loss equally and limit the minimum number of steps before preemption to one-fourth the maximum to ensure all environments contribute to learning. While we only examined our method with PPO, other on-policy RL algorithms can easily be used and we believe the method can be adapted to off -policy RL algorithms. Off-policy RL algorithms also alternate between experience collection and optimization, but differ in how experience is col- lected/used and the parameter update rule. Our adaptations simply add synchronization to the opti- mization stage and a preemption to the experience collection stage.

Section Title: Implementation
  Implementation We leverage PyTorch's (Paszke et al., 2017) DistributedDataParallel to syn- chronize gradients, and TCPStore - a simple distributed key-value storage - to track how many workers have finished collecting experience. See Apx. E for a detailed description with code.

Section Title: EXPERIMENTAL SETUP: POINTGOAL NAVIGATION, AGENTS, SIMULATOR
  EXPERIMENTAL SETUP: POINTGOAL NAVIGATION, AGENTS, SIMULATOR PointGoal Navigation (PointGoalNav). An agent is initialized at a random starting position and orientation in a new environment and asked to navigate to target coordinates specified relative to the Published as a conference paper at ICLR 2020 agents position; no map is available and the agent must navigate using only its sensors - in our case RGB-D (or RGB) and GPS+Compass (providing current position and orientation relative to start). The evaluation criteria for an episode is as follows (Anderson et al., 2018a): Let S indicate 'success' (did the agent stop within 0.2 meters of the target?), l be the length of the shortest path between start and target, and p be the length of the agent's path, then Success weighted by (normalized inverse) Path Length SPL = S l max(l,p) . It is worth stressing that SPL is a highly punitive metric - to achieve SPL = 1, the agent (navigating without the map) must match the performance of the shortest-path oracle that has access to the map! There is no scope for any mistake - no wrong turn at a crossroad, no back-tracking from a dead-end, no exploration or deviation from the shortest path. In general, this may not even be possible in a new environment (certainly not if an adversary designs the map). Agent. As in Savva et al. (2019), the agent has 4 actions, stop, which indicates the agent has reached the goal, move forward (0.25m), turn left (10 • ), and turn right (10 • ). It receives 256x256 sized images and uses the GPS+Compass to compute target coordinates relative to its current state. The RGB-D agent is limited to only Depth as Savva et al. (2019) found this to perform best. Our agent architecture ( Fig. 3 ) has two main components - a visual encoder and a policy network. The visual encoder is based on either ResNet (He et al., 2016) or SE (Hu et al., 2018)-ResNeXt (Xie et al., 2017) with the number of output channels at every layer reduced by half. We use a first layer of 2x2-AvgPool to reduce resolution (essentially performing low-pass filtering + down-sampling) - we find this to have no impact on performance while allowing faster training. From our initial experiments, we found it necessary to replace every BatchNorm layer (Ioffe & Szegedy, 2015) with GroupNorm (Wu & He, 2018) to account for highly correlated inputs seen in on-policy RL. The policy is parameterized by a 2-layer LSTM with a 512-dimensional hidden state. It takes three inputs: the previous action, the target relative to the current state, and the output of the visual encoder. The LSTM's output is used to produce a softmax distribution over the action space and an estimate of the value function. See Appendix C for full details.

Section Title: Training
  Training We use PPO with Generalized Advantage Estimation (Schulman et al., 2015). We set the discount factor γ to 0.99 and the GAE parameter τ to 0.95. Each worker collects (up to) 128 frames of experience from 4 agents running in parallel (all in different environments) and then performs 2 epochs of PPO with 2 mini-batches per epoch. We use Adam (Kingma & Ba, 2014) with a learning rate of 2.5 × 10 −4 . Unlike popular implementations of PPO, we do not normalize advantages as we find this leads to instabilities. We use DD-PPO to train with 64 workers on 64 GPUs. The agent receives terminal reward r T = 2.5 SPL, and shaped reward r t (a t , s t ) = −∆ geo dist −0.01, where ∆ geo dist is the change in geodesic distance to the goal by performing action a t in state s t .

Section Title: Simulator+Datasets
  Simulator+Datasets Our experiments are conducted using Habitat, a 3D simulation platform for embodied AI research (Savva et al., 2019). Habitat is a modular framework with a highly performant and stable simulator, making it an ideal framework for simulating billions of steps of experience. We experiment with several different sources of data. First, we utilize the training data released as part of the Habitat Challenge 2019, consisting of 72 scenes from the Gibson dataset (Xia et al., 2018). We then augment this with all 90 scenes in the Matterport3D dataset (Chang et al., 2017) to create a larger training set (note that Matterport3D meshes tend to be larger and of better quality). 2 Furthermore, Savva et al. (2019) curated the Gibson dataset by rating every mesh reconstruction on a quality scale of 0 to 5 and then filtered all splits such that each only contains scenes with a rating of 4 or above (Gibson-4+), leaving all scenes with a lower rating previously unexplored. We examine training on the 332 scenes from the original train split with a rating of 2 or above (Gibson-2+).

Section Title: BENCHMARKING: HOW DOES DD-PPO SCALE?
  BENCHMARKING: HOW DOES DD-PPO SCALE? In this section, we examine how DD-PPO scales under two different workload regimes - homoge- neous (every environment takes approximately the same amount of time to simulate) and heteroge- neous (different environments can take orders of magnitude more/less time to simulate). We examine the number of steps of experience per second with N workers relative to 1 worker. We compare dif- ferent values of the preemption threshold p%. We benchmark training our ResNet50 PointGoalNav agent with Depth on a cluster with Nvidia V100 GPUs and NCCL2.4.7 with Infiniband interconnect. Homogeneous. To create a homogeneous workload, we train on scenes from the Gibson dataset, which require very similar times to simulate agent steps. As shown in  Fig. 4  (left), DD-PPO exhibits near-linear scaling (linear = ideal) for preemption thresholds larger than 50%, achieving a 196x speed up with 256 GPUs relative to 1 GPU and an 7.3x speed up with 8 GPUs relative to 1.

Section Title: Heterogeneous
  Heterogeneous To create a heterogeneous workload, we train on scenes from both Gibson and Matterport3D. Unlike Gibson, MP3D scenes vary significantly in complexity and time to simulate - the largest contains 8GB of data while the smallest is only 135MB. DD-PPO scales poorly at a preemption threshold of 100% (no preemption) due to the substantial straggler effect (one rollout taking substantially longer than the others); see  Fig. 4  (right). However, with a preemption threshold of 80% or 60%, we achieve near-identical scaling to the homogeneous workload! We found no degradation in performance of models trained with any of these values for the preemption threshold despite learning in large scenes occurring at a lower frequency.

Section Title: MASTERING POINTGOAL NAVIGATION WITH GPS+COMPASS
  MASTERING POINTGOAL NAVIGATION WITH GPS+COMPASS In this section, we answer the following questions: 1) What are the fundamental limits of learnability in PointGoalNav navigation? 2) Do more training scenes improve performance? 3) Do better visual encoders improve performance? 4) Is PointGoalNav 'solvable' when navigating from RGB instead of Depth? 5) What are the open/unsolved problems - specifically, how does navigation without GPS+Compass perform? 6) Can agents trained for PointGoalNav be transferred to new tasks? Agents continue to improve for a long time. Using DD-PPO, we train agents for 2.5 Billion steps of experience with 64 Tesla V100 GPUs in 2.75 days - 180 GPU-days of training, the equivalent of 80 years of human experience (assuming 1 human second per step). As a comparison, Savva et al. (2019) reached 75 million steps (an order of magnitude more than prior work) in 2.5 days using 2 GPUs - at that rate, it would take them over a month (wall-clock time) to achieve the scale of our study.  Fig. 1  shows the performance of an agent with RGB-D and GPS+Compass sensors, utilizing an SE-ResNeXt50 visual encoder, trained on Gibson-2+ - it does not saturate before 1 billion steps 3 , suggesting that previous studies were incomplete by 1-2 orders of magnitude. Fortuitously, error vs computation exhibits a power-law-like distribution; 90% of peak performance is obtained relatively early (100M steps) and relatively cheaply (in 0.1 day with 64 GPUs and in 1 day with 8 GPUs 4 ). Also noteworthy in  Fig. 1  is the strong generalization (train to val) and corresponding lack of overfitting. Increasing training data helps.  Tab. 1  presents results with different training datasets and visual encoders for agent with RGB-D and GPS+Compass. Our most basic setting (ResNet50, Gibson-4+ training) already achieves SPL of 0.922 (val), 0.917 (test), which nearly misses (by 0.003) the top of the leaderboard for the Habitat Challenge 2019 RGB-D track 5 . Next, we increase the size of the training data by adding in all Matterport3D scenes and see an improvement of ∼0.03 SPL - to 0.956 (val), 0.941 (test). Next, we compare training on Gibson-4+ and Gibson-2+. Recall that Gibson-{2, 3} corresponds to poorly reconstructed scenes (see Fig. 11). A priori, it is unclear whether the net effect of this addition would be positive or negative; adding them provides diverse experience to the Published as a conference paper at ICLR 2020 agent, however, it is poor quality data. We find a potentially counter-intuitive result - adding poor 3D reconstructions to the train set improves performance on good reconstructions in val/test by ∼0.03 SPL - from 0.922 (val), 0.917 (test) to 0.956 (val), 0.944 (test). Our conjecture is that training on poor (Gibson-{2,3}) and good (4+) reconstructions leads to robustness in representations learned.

Section Title: Better visual encoders and more parameters help
  Better visual encoders and more parameters help Using a better visual encoder, SE (Hu et al., 2018)-ResNeXt50 (Xie et al., 2017) instead of ResNet50, improves performance by 0.003 SPL ( Tab. 1 ). Adding capacity to the visual encoder (SE-ResNeXt101 vs SE-ResNeXt50) and navigation policy (1024-d vs 512-d LSTM) further improves performance by 0.010 SPL.

Section Title: PointGoalNav 'solved' with RGB-D and GPS+Compass
  PointGoalNav 'solved' with RGB-D and GPS+Compass Our best agent - SE-ResNeXt101 + 1024-d LSTM trained on Gibson-2+ - achieves SPL of 0.969 (val), 0.948 (test), which not only sets the state of art on the Habitat Challenge 2019 RGB-D track but is also within 3-5% of the shortest-path oracle 6 . Given the challenges with achieving near-perfect SPL in new environments, it is important to dig deeper. Fig. 13 shows (a) distribution of episode lengths in val and (b) SPL vs episode length. We see that while the dataset is dominated by short episodes (2-12m), the performance of the agent is remarkably stable over long distances and average SPL is not necessarily inflated. Our hypothesis is the agent has learned to exploit the structural regularities in layouts of real indoor environments. One (admittedly imperfect) way to test this is by training a Blind agent with only a GPS+Compass sensor. Fig. 13 shows that this agent is able to handle short-range navigation (which primarily involve turning to face the target and walking straight) but performs very poorly on longer trajectories - SPL of 0.3 (Blind) vs 0.95 (RGB-D) at 20-25m navigation. Thus, structural regularities, in part, explain performance for short-range navigation. For long-range navigation, the RGB-D agent is extracting overwhelming signal from its Depth sensor. We repeat this analysis on two additional navigation datasets proposed by Chaplot et al. (2019) - longer episodes and 'harder' episodes (more navigation around obstacles) - and find similar trends (Fig. 14). This discussion continues in Apx. A. Performance with RGB is also improved. So far we studied RGB-D as this performed best in Savva et al. (2019). We now study RGB (with SE-ResNeXt50 encoder). We found it crucial to train on Gibson-2+ and all of Matterport3D, ensuring diversity in both layouts (Gibson-2+) and appearance (Matterport3D), and to channel-wise normalize RGB (subtract by mean and divide by standard devi- ation) as our networks lack BatchNorm. Performance improves dramatically from 0.57 (val), 0.47 (test) SPL in Savva et al. (2019) to near-perfect success 0.991 (val), 0.977 (test) and high SPL 0.929 (val), 0.920 (test). While SPL is considerably lower than the Depth agent, (0.929 vs 0.959), inter- estingly, the RGB agent still reaches the goal a similar percentage of the time (99.1% vs 99.9%). This agent achieves state-of-art on the Habitat Challenge 2019 RGB track (rank 2 entry has 0.89 SPL).

Section Title: No GPS+Compass remains unsolved
  No GPS+Compass remains unsolved Finally, we examine if we also achieve better performance on the significantly more challenging task of navigation from RGB without GPS+Compass. At 100 million steps (an amount equivalent to Savva et al. (2019)), the agent achieves 0 SPL. By train- ing to 2.5 billion steps, we make some progress and achieve 0.15 SPL. While this is a substantial improvement, the task continues to remain an open frontier for research in embodied AI.

Section Title: Transfer Learning
  Transfer Learning   Fig. 5  shows performance vs. experience results (higher is better). Nearly all methods outperform learning from scratch, establishing the value of transfer learning. PointGoalNav pre-trained visual encoders dramatically outperforms ImageNet pre-trained ones, indicating that the agent has learned generally useful scene understanding. For both tasks, fine-tuning an existing policy allows it to rapidly learn the new task, indicating that the agent has learned general navigation skills. ∇Neural Controller outperforms PointGoalNavEncoder-ScratchPolicy on Flee and is competitive on Explo- ration, indicating that the agent can indeed be 'controlled' or directed to target locations by a planner. Overall, these results demonstrate that our trained model is useful for more than just PointGoalNav.

Section Title: RELATED WORK
  RELATED WORK

Section Title: Visual Navigation
  Visual Navigation In the general case, computation in reinforcement learning (RL) in simulators can be broken down into 4 roles: 1) Simulation: Takes actions performed by the agent as input, simulates the new state, returns observations, reward, etc. 2) Inference: Takes observations as input and utilizes the agent policy to return actions, value estimate, etc. 3) Learner: Takes rollouts as input and computes gradients to update the policy's parameters. 4) Parameter server/master: Holds the source of truth for the policy's parameters and coordinates workers. Synchronous RL systems utilize a single processes to perform all four roles; this design is found in RL libraries like OpenAI Baselines (Dhariwal et al., 2017) and Py- torchRL (Kostrikov, 2018). This method is limited to a single nodes worth of GPUs.

Section Title: Synchronous Distributed RL
  Synchronous Distributed RL The works most closely related to DD-PPO also propose to scale synchronous RL by replicating this simulation/inference/learner process across multiple GPUs and then synchronize gradients with AllReduce. Stooke & Abbeel (2018) experiment with Atari and find it not effective however. We hypothesize that this is due to a subtle difference - this distribu- tion design relies on a single worker collecting experience from multiple environments, stepping through them in lock step. This introduces significant synchronization and communication costs as every step in the rollout must be synchronized across as many as 64 processes (possible because each environment is resource-light, e.g. Atari). For instance, taking 1 step in 8 parallel pong environments takes approximately the same wall-clock time as 1 pong environment, but it takes 10 times longer to take 64 steps in lock-step; thus gains from parallelization are washed out due to the lock-step synchronization. In contrast, we study resource-intensive environments, where only 2 or 4 environ- ments per worker is possible, and find this technique to be effective. Liang et al. (2018b) mirror our findings (this distribution method can be effective for resource intensive simulation) in GPU- accelerated physics simulation, specifically MuJoCo (Todorov et al., 2012) with NVIDIA Flex. In contrast to our work, they examine scaling up to only 32 GPUs and only for homogeneous work- loads. In contrast to both, we propose an adaption to mitigate the straggler effect - preempting the experience collection (rollout) of stragglers and then beginning optimization. This improves scaling for homogeneous workloads and dramatically improves scaling for heterogeneous workloads.

Section Title: Asynchronous Distributed RL
  Asynchronous Distributed RL Existing public frameworks for asynchronous distributed reinforce- ment learning (Heess et al., 2017; Liang et al., 2018a; Espeholt et al., 2018) use a single (CPU-only) process to perform the simulation and inference roles (and then replicate this process to scale). A separate process asynchronously performs the learner and parameter server roles (note its not clear how to use more than one these processes as it holds the source of truth for the parameters). Adapt- ing these methods to the resource-intensive environments studied in this work (e.g. Habtiat (Savva et al., 2019)) encounters the following issues: 1) Limiting the inference/simulation processes to CPU-only is untenable (deep networks and need for GPU-accelerated simulation). While the infer- ence/simulation processes could be moved to the GPU, this would be ineffective for the following: GPUs operate most efficiently with large batch sizes (each inference/simulation process would have a batch size of 1), CUDA runtime requires ∼600MB of GPU memory per process, and only one CUDA kernel (function that runs on the GPU) can executed by the GPU at a time. These issue contribute and lead to low GPU utilization. In contrast, DD-PPO utilizes a single process per GPU and batches observations from multiple environments for inference. 2) The single process learner/- parameter server is limited to a single node's worth of GPUs. While this not a limitation for small networks and low dimensional inputs, our agents take high dimensional inputs (e.g. a Depth sensor) and utilize large neural networks (ResNet50), thereby requiring considerable computation to com- pute gradients. In contrast, DD-PPO has no parameter server and every GPU computes gradients, supporting even very large networks (SE-ResNeXt101).

Section Title: Straggler Effect Mitigation
  Straggler Effect Mitigation In supervised learning, the straggler effect is commonly caused by heterogeneous hardware or hardware failures. Chen et al. (2016) propose a pool of b "back-up" workers (there are N + b workers total) and perform the parameter update once N workers finish. In comparison, their method a) requires a parameter server, and b) discards all work done by the stragglers. Chen et al. (2018) propose to dynamically adjust the batch size of each worker such that all workers perform their forward and backward pass in the same amount of time. Our method aims to reduce variance in experience collection times. DD-PPO dynamically adjusts a worker's batch size as a necessary side-effect of preempting experience collection in on-policy RL.

Section Title: Distributed Synchronous SGD
  Distributed Synchronous SGD Data parallelism is a common paradigm in high performance com- puting (Hillis & Steele Jr, 1986). In this paradigm, parallelism is achieved by workers performing the same work on different data. This paradigm can be naturally adapted to supervised deep learn- ing (Chen et al., 2016). Works have used this to achieve state-of-the-art results in tasks ranging from computer vision (Goyal et al., 2017; He et al., 2017) to natural language processing (Peters et al., 2018; Devlin et al., 2018; Ott et al., 2019). Furthermore, multiple deep learning frameworks provide simple-to-use wrappers supporting this parallelism model (Paszke et al., 2017; Abadi et al., 2015; Sergeev & Balso, 2018). We adapt this framework to reinforcement learning.

Section Title: ACKNOWLEDGEMENTS
  ACKNOWLEDGEMENTS

```
