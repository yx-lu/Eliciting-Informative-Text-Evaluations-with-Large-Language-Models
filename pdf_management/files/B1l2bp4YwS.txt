Title:
```
Published as a conference paper at ICLR 2020 WHAT GRAPH NEURAL NETWORKS CANNOT LEARN: DEPTH VS WIDTH
```
Abstract:
```
This paper studies the expressive power of graph neural networks falling within the message-passing framework (GNN mp ). Two results are presented. First, GNN mp are shown to be Turing universal under sufficient conditions on their depth, width, node attributes, and layer expressiveness. Second, it is discovered that GNN mp can lose a significant portion of their power when their depth and width is restricted. The proposed impossibility statements stem from a new technique that enables the repurposing of seminal results from distributed computing and leads to lower bounds for an array of decision, optimization, and estimation problems involving graphs. Strikingly, several of these problems are deemed impossible unless the product of a GNN mp 's depth and width exceeds a polynomial of the graph size; this dependence remains significant even for tasks that appear simple or when considering approximation.
```

Figures/Tables Captions:
```
Figure 1: Accuracy as a function of GNN mp capacity dw and n. (Best seen in color.) d ∈ (5, 10, 20, 15). To reduce the dependence on the initial conditions and training length, for each hyperparameter combination, I trained 4 networks independently (using Adam and learning rate decay) for 4000 epochs. The GNN mp chosen was that proposed by Xu et al. (2018), with the addition of residual connections-this network outperformed all others that I experimented with.
Figure 2: (a) GNNs are significantly more powerful when given discriminative node attributes. (b) Test accuracy indicated by color as a function of normalized depth and width. Points in highlighted areas correspond to networks with super-critical capacity, whereas the diagonal line separates networks that more deep than wide. (For improved visibility, points are slightly perturbed. Best seen in color.)
Table 1: Summary of main results. Subgraph verification* entails verifying one of the following predicates for a given subgraph: is connected, contains a cycle, forms a spanning tree, is bipartite, is a cut, is an s-t cut. All problems are defined in Appendix A.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION A fundamental question in machine learning is to determine what a model can and cannot learn. In deep learning, there has been significant research effort in establishing expressivity results for feed- forward (Cybenko, 1989; Hornik et al., 1989; Lu et al., 2017) and recurrent neural networks (Neto et al., 1997), as well as more recently for Transformers and Neural GPUs (Pérez et al., 2019). We have also seen the first results studying the universality of graph neural networks, i.e., neural networks that take graphs as input. Maron et al. (2019b) derived a universal approximation theorem over invariant functions targeted towards deep networks whose layers are linear and equivariant to permutation of their input. Universality was also shown for equivariant functions and a particular shallow architecture (Keriven & Peyré, 2019). Universality statements allow us to grasp the expressive power of models in the limit. In theory, given enough data and the right training procedure, a universal network will be able to solve any task that it is presented with. Nevertheless, the insight brought by such results can also be limited. Knowing that a sufficiently large network can be used to solve any problem does not reveal much about how neural networks should be designed in practice. It also cannot guarantee that said network will be able to solve a given task given a particular training procedure, such as stochastic gradient descent. On the other hand, it might be easier to obtain insights about models by studying their limitations. After all, the knowledge of what cannot be computed (and thus learned) by a network of specific characteristics applies independently of the training procedure. Further, by helping us comprehend the difficulty of a task in relation to a model, impossibility results can yield practical advice on how to select model hyperparameters. Take, for instance, the problem of graph classification. Training a graph classifier entails identifying what constitutes a class, i.e., finding properties shared by graphs in one class but not the other, and then deciding whether new graphs abide to said learned properties. However, if the aforementioned decision problem is shown to be impossible by a graph neural network of certain depth then we can be certain that the same network will not learn how to classify a sufficiently diverse test set correctly, independently of which learning algorithm is employed. We should, therefore, focus on networks deeper that the lower bound when performing experiments.

Section Title: MAIN RESULTS
  MAIN RESULTS This paper studies the expressive power of message-passing graph neural networks (GNN mp ) (Gilmer et al., 2017). This model encompasses several state-of-the-art networks, including GCN (Kipf & Welling, 2016), gated graph neural networks (Li et al., 2015), molecular fingerprints (Duvenaud et al., 2015), interaction networks (Battaglia et al., 2016), molecular convolutions (Kearnes et al., 2016), among many others. Networks using a global state (Battaglia et al., 2018) or looking at multiple hops per layer (Morris et al., 2019; Liao et al., 2019; Isufi et al., 2020) are not directly GNN mp , but they can often be re-expressed as such. The provided contributions are two-fold: I. What GNN mp can compute. Section 3 derives sufficient conditions such that a GNN mp can compute any function on its input that is computable by a Turing machine. This result compliments recent universality results (Maron et al., 2019b; Keriven & Peyré, 2019) that considered approximation (rather than computability) over specific classes of functions (permutation invariant and equivariant) and particular architectures. The claim follows in a straightforward manner by establishing the equivalence of GNN mp with LOCAL (Angluin, 1980; Linial, 1992; Naor & Stockmeyer, 1993), a classical model in distributed computing that is itself Turing universal. In a nutshell, GNN mp are shown to be universal if four strong conditions are met: there are enough layers of sufficient expressiveness and width, and nodes can uniquely distinguish each other. Since Turing universality is a strictly stronger property than universal approximation, Chen et al. (2019)'s argument further implies that a Turing universal GNN mp can solve the graph isomorphism problem (a sufficiently deep and wide network can compute the isomorphism class of its input). II. What GNN mp cannot compute (and thus learn). Section 4 analyses the implications of restrict- ing the depth d and width w of GNN mp that do not use a readout function. Specifically, it is proven that GNN mp lose a significant portion of their power when the product dw, which I call capacity, is restricted. The analysis relies on a new technique that enables repurposing impossibility results from the context of distributed computing to the graph neural network setting. Specifically, lower bounds for the following problems are presented: (i) detecting whether a graph contains a cycle of specific length; (ii) verifying whether a given subgraph is connected, contains a cycle, is a spanning tree, is bipartite, is a simple path, corresponds to a cut or Hamiltonial cycle; (iii) approximating the shortest path between two nodes, the minimum cut, and the minimum spanning tree; (iv) finding a maximum independent set, a minimum vertex cover, or a perfect coloring; (v) computing or approximating the diameter and girth. The bounds are summarized in  Table 1  and the problem definitions can be found in Appendix A. Section 5 presents some empirical evidence of the theory. Though formulated in a graph-theoretic sense, the above problems are intimately linked to machine learning on graphs. Detection, verification, and computation problems are relevant to classification: knowing what properties of a graph a GNN mp cannot see informs us also about which features of a graph can it extract. Further, there have been attempts to use GNN mp to devise heuristics for graph-based optimization problems (Khalil et al., 2017; Battaglia et al., 2018; Li et al., 2018; Joshi et al., 2019; Bianchi et al., 2019), such as the ones discussed above. The presented results can then be taken as a worst-case analysis for the efficiency of GNN mp in such endeavors.

Section Title: DISCUSSION
  DISCUSSION The results of this paper carry several intriguing implications. To start with, it is shown that the capacity dw of a GNN mp plays a significant role in determining its power. Solving many problems Published as a conference paper at ICLR 2020 is shown to be impossible unless dw =Ω(n δ ), where δ ∈ [ 1 /2, 2], n is the number of nodes of the graph, and f (n) =Ω(g(n)) is interpreted as f (n) being, up to logarithmic factors, larger than g(n) as n grows. This reveals a direct trade-off between the depth and width of a graph neural network. Counter-intuitively, the dependence on n can be significant even if the problem appears local in nature or one only looks for approximate solutions. For example, detecting whether G contains a short cycle of odd length cannot be done unless dw =Ω(n). Approximation helps, but only to a limited extent; computing the graph diameter requires dw =Ω(n) and this reduces to dw =Ω( √ n) for any 3 /2-factor approximation. Further, it is impossible to approximate within any constant factor the shortest path, the minimum cut, and the minimum spanning tree, all three of which have polynomial-time solutions, unless d √ w =Ω( √ n). Finally, for truly hard problems, the capacity may even need to be super-linear on n. Specifically, it is shown that, even if the layers of the GNN mp are allowed to take exponential time, solving certain NP-hard problems necessitates d =Ω(n 2 ) depth for any constant-width network.

Section Title: Relation to previous impossibility results
  Relation to previous impossibility results In contrast to universality (Maron et al., 2019b; Keriven & Peyré, 2019), the limitations of GNN mp have been much less studied. In particular, the bounds presented here are the first impossibility results that (i) explicitly connect GNN mp properties (depth and width) with graph properties and that (ii) go beyond isomorphism by addressing decision, opti- mization, and estimation graph problems. Three main directions of related work can be distinguished. First, Dehmamy et al. (2019) bounded the ability of graph convolutional networks (i.e., GNN mp w/o messaging functions) to compute specific polynomial functions of the adjacency matrix, referred to as graph moments by the authors. Second, Xu et al. (2018) and Morris et al. (2019) established the equiv- alence of anonymous GNN mp (those that do not rely on node identification) to the Weisfeiler-Lehman (WL) graph isomorphism test. The equivalence implies that anonymous networks are blind to the many graph properties that WL cannot see: e.g., any two regular graphs with the same number of nodes are identical from the perspective of the WL test (Arvind et al., 2015; Kiefer et al., 2015). Third, in parallel to this work, Sato et al. (2019) utilized a connection to LOCAL to derive impossibility results for the ability of a class of novel partially-labeled GNN mp to find good approximations for three NP-hard optimization problems. Almost all of the above negative results occur due to nodes being unable to distinguish between neighbors at multiple hops (see Appendix D). With discriminative attributes GNN mp become significantly more powerful (without necessarily sacrificing permutation in/equivariance). Still, as this work shows, even in this setting certain problems remain impossible when the depth and width of the GNN mp is restricted. For instance, though cycles can be detected (something impossible in anonymous networks (Xu et al., 2018; Morris et al., 2019)), even for short cycles one now needs dw =Ω(n). Further, in contrast to Sato et al. (2019), an approximation ratio below 2 for the minimum vertex cover is not impossible, but necessitates dw =Ω(n 2 ).

Section Title: Limitations
  Limitations First, all lower bounds are of a worst-case nature: a problem is deemed impossible if there exists a graph for which it cannot be solved. The discovery of non worst-case capacity bounds remains an open problem. Second, rather than taking into account specific parametric functions, each layer is assumed to be sufficiently powerful to compute any function of its input. This strong assumption does not significantly limit the applicability of the results, simply because all lower bounds that hold with universal layers also apply to those that are limited computationally. Lastly, it will be assumed that nodes can uniquely identify each other. Node identification is compatible with permutation invariance/equivariance as long as the network output is asked to be invariant to the particular way the ids have been assigned. In the literature, one-hot encoded node ids are occasionally useful (Kipf & Welling, 2016; Berg et al., 2017). When attempting to learn functions across multiple graphs, ids should be ideally substituted by sufficiently discriminative node attributes (attributes that uniquely identify each node within each receptive field it belongs to can serve as ids). Nevertheless, similar to the unbounded computation assumption, if a problem cannot be solved by a graph neural network in the studied setting, it also cannot be solved without identifiers and discriminative attributes. Thus, the presented lower bounds also apply to partially and fully anonymous networks.

Section Title: Notation
  Notation I consider connected graphs G = (V, E) consisting of n = |V| nodes. The edge going from v j to v i is written as e i←j and it is asserted that if e i←j ∈ E then also e j←i ∈ E. The neighborhood N i of a node v i ∈ V consists of all nodes v j for which e i←j ∈ E. The degree of v i is denoted by deg i , ∆ is the maximum degree of all nodes and the graph diameter δ G is the length of the longest Published as a conference paper at ICLR 2020 shortest path between any two nodes. In the self-loop graph G * = (V, E * ), the neighborhood set of v i is given by N * i = N i ∪ v i .

Section Title: THE GRAPH NEURAL NETWORK COMPUTATIONAL MODEL
  THE GRAPH NEURAL NETWORK COMPUTATIONAL MODEL Graph neural networks are parametric and differentiable learning machines. Their input is usually an attributed graph G a = (G, (a i : v i ∈ V), (a i←j : e i←j ∈ E)), where vectors a 1 , . . . , a n encode relevant node attributes and a i←j are edge attributes, e.g., encoding edge direction. Model 1 formalizes the graph neural network operation by placing it in the message passing model (Gilmer et al., 2017). The computation proceeds in layers, within which a message m i←j is passed along each directed edge e i←j ∈ E going from v j to v i and each node updates its internal representation by aggregating its state with the messages sent by its incoming neighbors v j ∈ N i . The network output can be either of two things: a vector x i for each node v i or a single vector x G obtained by combining the representations of all nodes using a readout function. Vectors x i /x G could be scalars (node/graph regression), binary variables (node/graph classification) or multi-dimensional (node/graph embedding). I use the symbols GNN n mp and GNN g mp to distinguish between models that return a vector per node and one per graph, respectively.

Section Title: Computational model 1 Message passing graph neural network (GNN mp )
  Computational model 1 Message passing graph neural network (GNN mp ) The operation of a GNN mp is primarily determined by the messaging, update, and readout functions. I assume that MSG and UP are general functions that act on intermediate node representations and node ids (the notation is overloaded such that v i refers to both the i-th node as well as its unique id). As is common in the literature (Lu et al., 2017; Battaglia et al., 2018), these functions are instantiated by feed-forward neural networks. Thus, by the universal approximation theorem and its variants (Cybenko, 1989; Hornik et al., 1989), they can approximate any general function that maps vectors onto vectors, given sufficient depth and/or width. Function READ is useful when one needs to retrieve a representation that is invariant of the number of nodes. The function takes as an input a multiset, i.e., a set with possibly repeating elements, and returns a vector. Commonly, READ is chosen to be a dimension squashing operator, such as a sum or a histogram, followed by a feed-forward neural network (Xu et al., 2018; Seo et al., 2019).

Section Title: Depth and width
  Depth and width The depth d is equal to the number of layers of the network. Larger depth means that each node has the opportunity to learn more about the rest of the graph (i.e., it has a larger receptive field). The width w of a GNN mp is equal to the largest dimension of state x (l) i over all layers l and nodes v i ∈ V. Since nodes need to be able to store their own unique ids, in the following it is assumed that each variable manipulated by the network is represented in finite-precision using p = Θ(log n) bits (though this is not strictly necessary for the analysis).

Section Title: SUFFICIENT CONDITIONS FOR TURING UNIVERSALITY
  SUFFICIENT CONDITIONS FOR TURING UNIVERSALITY This section studies what graph neural networks can compute. It is demonstrated that, even without readout function, a network is computationally universal 1 if it has enough layers of sufficient 1 It can compute anything that a Turing machine can compute when given an attributed graph as input. Published as a conference paper at ICLR 2020 width, nodes can uniquely distinguish each other, and the functions computed within each layer are sufficiently expressive. The derivation entails establishing that GNN n mp is equivalent to LOCAL, a classical model used in the study the distributed algorithms that is itself Turing universal.

Section Title: THE LOCAL COMPUTATIONAL MODEL
  THE LOCAL COMPUTATIONAL MODEL A fundamental question in theoretical computer science is determining what can and cannot be computed efficiently by a distributed algorithm. The LOCAL model, initially studied by Angluin (1980), Linial (1992), and Naor & Stockmeyer (1993), provides a common framework for analyzing the effect of local decision. Akin to GNN mp , in LOCAL a graph plays a double role: it is both the input of the system and captures the network topology of the distributed system that solves the problem. In this spirit, the nodes of the graph are here both the machines where computation takes place as well as the variables of the graph-theoretic problem we wish to solve-similarly, edges model communication links between machines as well as relations between nodes. Each node v i ∈ V is given a problem-specific local input and has to produce a local output. The input contains necessary the information that specifies the problem instance. All nodes execute the same algorithm, they are fault-free, and they are provided with unique identifiers. A pseudo-code description is given in Model 2. Variables s (l) i and s (l) i←j refer respectively to the state of v i in round l and to the message sent by v j to v i in the same round. Both are represented as strings. The computation starts simultaneously and unfolds in synchronous rounds l = 1, . . . , d. Three things can occur within each round: each node receives a string of unbounded size from its incoming neighbors; each node updates its internal state by performing some local computation; and each node sends a string to every one of its outgoing neighbors. Functions ALG 1 l and ALG 2 l are algorithms computed locally by a Turing machine running on node v i . Before any computation is done, each node v i is aware of its own attribute a i as well as of all edge attributes {a i←j : v j ∈ N * i }. Computational model 2 LOCAL (computed distributedly by each node v i ∈ V). In LOCAL, there are no restrictions on how much information a node can send at every round. Asserting that each message s ( ) i←j is at most b bits yields the CONGEST model (Peleg, 2000).

Section Title: TURING UNIVERSALITY
  TURING UNIVERSALITY The reader might have observed that LOCAL resembles closely GNN n mp in its structure, with only a few minor differences: firstly, whereas a LOCAL algorithm A may utilize messages in any way it chooses, a GNN n mp network N always sums received messages before any local computation. The two models also differ in the arguments of the messaging function and the choice of information representation (string versus vector). Yet, as the following theorem shows, the differences between GNN n mp and LOCAL are inconsequential when seen from the perspective of their expressive power: Theorem 3.1 (Equivalence). Let N (G a ) be the binary representation of the state (x ( ) 1 , . . . , x ( ) n ) of a GNN n mp network N and A (G a ) = (s ( ) 1 , . . . , s ( ) n ) that of a LOCAL algorithm A. If MSG and UP are Turing complete functions, then, for any algorithm A there exists N (resp. for any N there exists A) such that A (G a ) = N (G a ) for every layer and G a ∈ G a , where G a is the set of all attributed graphs.

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 This equivalence enables us to reason about the power of GNN n mp by building on the well-studied properties of LOCAL. In particular, it is well known in distributed computing that, as long as the number of rounds d of a distributed algorithm is larger than the graph diameter δ G , every node in a LOCAL can effectively make decisions based on the entire graph (Linial, 1992). Together with Theorem 3.1, the above imply that, if computation and memory are not an issue, one may construct a GNN n mp that effectively computes any computable function w.r.t. its input. Corollary 3.1. GNN n mp can compute any Turing computable function over connected attributed graphs if the following conditions are jointly met: each node is uniquely identified; MSG l and UP l are Turing-complete for every layer ; the depth is at least d ≥ δ G layers; and the width is unbounded. Why is this result relevant? From a cursory review, it might seem that universality is an abstract result with little implication to machine learning architects. After all, the utility of a learning machine is usually determined not with regards to its expressive power but with its ability to generalize to unseen examples. Nevertheless, it can be argued that universality is an essential property of a good learning model. This is for two main reasons: First, universality guarantees that the learner does not have blind-spots in its hypothesis space. No matter how good the optimization algorithm is, how rich the dataset, and how overparameterized the network is, there will always be functions which a non universal learner cannot learn. Second, a universality result provides a glimpse on how the size of the learner's hypothesis space is affected by different design choices. For instance, Corollary 3.1 puts forth four necessary conditions for universality: the GNN n mp should be sufficiently deep and wide, nodes should be able to uniquely and consistently identify each other, and finally, the functions utilized in each layer should be sufficiently complex. The following section delves further into the importance of two of these universality conditions. It will be shown that GNN n mp lose a significant portion of their power when the depth and width conditions are relaxed. The universality of GNN g mp . Though a universality result could also be easily derived for networks with a readout function, the latter is not included as it deviates from how graph neural networks are meant to function: given a sufficiently powerful readout function, a GNN g mp of d = 1 depth and O(∆) width can be used to compute any Turing computable function. The nodes should simply gather one hop information about their neighbors; the readout function can then reconstruct the problem input based on the collective knowledge and apply any computation needed.

Section Title: IMPOSSIBILITY RESULTS AS A FUNCTION OF DEPTH AND WIDTH
  IMPOSSIBILITY RESULTS AS A FUNCTION OF DEPTH AND WIDTH This section analyzes the effect of depth and width in the expressive power of GNN n mp . Specifically, I will consider problems that cannot be solved by a network of a given depth and width. To be able to reason in terms of width, it will be useful to also enforce that the message size in LOCAL at each round is at most b bits. This model goes by the name CONGEST in the distributed computing literature (Peleg, 2000). In addition, it will be assumed that nodes do not have access to a random generator. With this in place, the following theorem shows us how to translate impossibility results from CONGEST to GNN n mp : Theorem 4.1. If a problem P cannot be solved in less than d rounds in CONGEST using messages of at most b bits, then P cannot be solved by a GNN n mp of width w ≤ (b − log 2 n)/p = O(b/ log n) and depth d. The p = Θ(log n) factor corresponds to the length of the binary representation of every variable-the precision needs to depend logarithmically on n for the node ids to be unique. With this result in place, the following sections re-state several known lower bounds in terms of a GNN n mp 's depth and width.

Section Title: IMPOSSIBILITY RESULTS FOR DECISION PROBLEMS
  IMPOSSIBILITY RESULTS FOR DECISION PROBLEMS I first consider problems where one needs to decide whether a given graph satisfies a certain prop- erty (Feuilloley & Fraigniaud, 2016). Concretely, given a decision problem P and a graph G, the GNN n mp should output x i ∈ {true, false} for all v i ∈ V. The network then accepts the premise if the logical conjunction of {x 1 , . . . , x n } is true and rejects it otherwise. Such problems are intimately connected to graph classification: classifying a graph entails identifying what constitutes a class from some training set and using said learned definition to decide the label of graphs sampled from Published as a conference paper at ICLR 2020 the test set. Instead, I will suppose that the class definition is available to the classifier and I will focus on the corresponding decision problem. As a consequence, every lower bound presented below for a decision problem must also be respected by a GNN n mp classifier that attains zero error on the corresponding graph classification problem.

Section Title: Subgraph detection
  Subgraph detection In this type of problems, the objective is to decide whether G contains a subgraph belonging to a given family. I focus specifically on detecting whether G contains a cycle C k , i.e., a simple undirected graph of k nodes each having exactly two neighbors. As the following result shows, even with ids, cycle detection remains relatively hard: Corollary 4.1 (Repurposed from (Drucker et al., 2014; Korhonen & Rybicki, 2018)). There exists graph G on which every GNN n mp of width w requires depth at least d = Ω( √ n/(w log n)) and d = Ω(n/(w log n)) to detect if G contains a cycle C k for even k ≥ 4 and odd k ≥ 5, respectively. Whereas an anonymous GNN mp cannot detect cycles (e.g., distinguish between two C 3 vs one C 6 (Maron et al., 2019a)), it seems that with ids the product of depth and width should exhibit an (at least) linear dependence on n. The intuition behind this bound can be found in Appendix C and empirical evidence in support of the theory are presented in Section 5.

Section Title: Subgraph verification
  Subgraph verification Suppose that the network is given a subgraph H = (V H , E H ) of G in its input. This could, for instance, be achieved by selecting the attributes of each node and edge to be a one-hot encoding of their membership on V H and E H , respectively. The question considered is whether the neural network can verify a certain property of H. More concretely, does a graph neural network exist that can successfully verify H as belonging to a specific family of graphs w.r.t. G? In contrast to the standard decision paradigm, here every node should reach the same decision-either accepting or rejecting the hypothesis. The following result is a direct consequence of the seminal work by Sarma et al. (2012): Corollary 4.2 (Repurposed from (Sarma et al., 2012)). There exists a graph G on which every GNN n mp of width w requires depth at least d = Ω( n w log 2 n + δ G ) to verify if some subgraph H of G is connected, contains a cycle, forms a spanning tree of G, is bipartite, is a cut of G, or is an s-t cut of G. Furthermore, the depth should be at least d = Ω n w log n γ + δ G with γ = 1 2 − 1 2(δ G −1) to verify if H is a Hamiltonian cycle or a simple path. Therefore, even if one knows where to look in G, verifying whether a given subgraph meets a given property can be non-trivial, and this holds for several standard graph-theoretic properties. For instance, if we constrain ourselves to networks of constant width, detecting whether a subgraph is connected can, up to logarithmic factors, require Ω( √ n) depth in the worst case.

Section Title: IMPOSSIBILITY RESULTS FOR OPTIMIZATION PROBLEMS
  IMPOSSIBILITY RESULTS FOR OPTIMIZATION PROBLEMS I turn my attention to the problems involving the exact or approximate optimization of some graph- theoretic objective function. From a machine learning perspective, the considered problems can be interpreted as node/edge classification problems: each node/edge is tasked with deciding whether it belongs to the optimal set or not. Take, for instance, the maximum independent set, where one needs to find the largest cardinality node set, such that no two of them are adjacent. Given only information identifying nodes, GNN n mp will be asked to classify each node as being part of the maximum independent set or not.

Section Title: Polynomial-time problems
  Polynomial-time problems Let me first consider three problems that possess known polynomial- time solutions. To make things easier for the GNN n mp , I relax the objective and ask for an approximate solution rather than optimal. An algorithm (or neural network) is said to attain an α-approximation if it produces a feasible output whose utility is within a factor α of the optimal. Let OPT be the utility of the optimal solution and ALG that of the α-approximation algorithm. Depending on whether the problem entails minimization or maximization, the ratio ALG/OPT is at most α and at least 1/α, respectively. According to the following corollary, it is non-trivial to find good approximate solutions: Corollary 4.3 (Repurposed from (Sarma et al., 2012; Ghaffari & Kuhn, 2013)). There exists graphs G and G of diameter δ G = Θ(log n) and δ G = O(1) on which every GNN n mp of width w requires Published as a conference paper at ICLR 2020 depth at least d = Ω( n w log 2 n ) and d = Ω(( n w log n ) γ ) with γ = 1 2 − 1 2(δ G −1) , respectively, to approximate within any constant factor: the minimum cut problem, the shortest s-t path problem, or the minimum spanning tree problem. Thus, even for simple problems (complexity-wise), in the worst case a constant width GNN n mp should be almost Ω( √ n) deep even if the graph diameter is exponentially smaller than n. NP-hard problems. So what about truly hard problems? Clearly, one cannot expect a GNN mp to solve an NP-hard time in polynomial time 2 . However, it might be interesting as a thought experiment to consider a network whose layers take exponential time on the input size-e.g., by selecting the MSG l and UP l functions to be feed-forward networks of exponential depth and width. Could one ever expect such a GNN n mp to arrive at the optimal solution? The following corollary provides necessary conditions for three well-known NP-hard problems: Corollary 4.4 (Repurposed from (Censor-Hillel et al., 2017)). There exists a graph G on which every GNN n mp of width w = O(1) requires depth at least d = Ω(n 2 /log 2 n) to solve: the minimum vertex cover problem; the maximum independent set problem; the perfect coloring problem. Thus, even if each layer is allowed to take exponential time, the depth should be quadratically larger than the graph diameter δ G = O(n) to have a chance of finding the optimal solution. Perhaps disappointingly, the above result suggests that it may not be always possible to exploit the distributed decision making performed by GNN mp architectures to find solutions faster than classical (centralized) computational paradigms.

Section Title: IMPOSSIBILITY RESULTS FOR ESTIMATION PROBLEMS
  IMPOSSIBILITY RESULTS FOR ESTIMATION PROBLEMS Finally, I will consider problems that involve the computation or estimation of some real function that takes as an input the graph and attributes. The following corollary concerns the computation of two well-known graph invariants: the diameter δ G and the girth. The latter is defined as the length of the shortest cycle and is infinity if the graph has no cycles. Corollary 4.5 (Repurposed from (Frischknecht et al., 2012)). There exists a graph G on which every GNN n mp of width w requires depth at least d = Ω(n/(w log n) + δ G ) to compute the graph diameter δ G and d = Ω( √ n/(w log n) + δ G ) to approximate the graph diameter and girth within a factor of 3 /2 and 2, respectively. Term δ G appears in the lower bounds because both estimation problems require global information. Further, approximating the diameter within a 3 /2 factor seems to be simpler than computing it. Yet, in both cases, one cannot achieve this using a GNN n mp whose capacity is constant. As a final remark, the graphs giving rise to the lower bounds of Corollary 4.5 have constant diameter and Θ(n 2 ) edges. However, similar bounds can be derived also for graphs with O(n log n) edges (Abboud et al., 2016). For the case of exact computation, the lower bound is explained in Appendix C.

Section Title: EMPIRICAL EVIDENCE
  EMPIRICAL EVIDENCE This section aims to empirically test the connection between the capacity dw of a GNN mp , the number of nodes n of its input, and its ability to solve a given task. In particular, I considered the problem of 4-cycle classification and tasked the neural network with classifying graphs based on whether they contained a cycle of length four. Following the lower bound construction described in Appendix A, I generated five distributions over graphs with n ∈ (8, 16, 24, 32, 44) nodes and an average diameter of (4, 6, 8, 9, 11), respectively (this was achieved by setting p ∈ (6, 8, 10, 12, 14), see Figure 3a). For each such distribution, I generated a training and test set consisting respectively of 1000 and 200 examples. Both sets were exactly balanced, i.e., any example graph from the training and test set had exactly 50% chance of containing a 4-cycle. The experiment aimed to evaluate how able were GNN mp of different capacities to attain high accuracy on the test set. To this end, I performed grid search over the hyperparameters w ∈ (2, 10, 20) and 2 Unless P=NP. It is important to stress that empirically verifying lower bounds for neural networks is challenging, because it involves searching over the space of all possible networks in order to find the ones that perform the best. For this reason, an experiment such as the one described above cannot be used to verify 3 the tightness of the bounds: we can never be certain whether the results obtained are the best possible or whether the optimization resulted in a local minimum. In that view, the following results should be interpreted in a qualitative sense. The question that I will ask is: to which extend do the trends uncovered match those predicted by the theory? More specifically, does the ability of a network to detect 4-cycles depend on the relation between dw and n? To answer this question,  Figure 1  depicts the training and test accuracy as a function of the capacity dw for all the 240 networks trained (5 distributions × 3 widths × 4 depths × 4 iterations). The accuracy of the best performing networks with the smallest capacity is shown in Figures 1c and 1d. It is important to stress that, based on Weisfeiler-Lehman analyses, anonymous GNN mp cannot solve the considered task. However, as it seen in the figures, the impossibility is annulled when using node ids 4 . Indeed, even small neural networks could consistently classify all test examples perfectly (i.e., achieving 100% test accuracy) when n ≤ 16. Moreover, as the theoretical results predicted, there is a strong correlation between the test accuracy, dw and n (recall that Corollary 4.1 predicts dw =Ω( √ n)). Figure 1d shows that networks of the same capacity were consistently less accurate on the test set as n increased (even though the cycle length remained 4 in all experiments). It is also Published as a conference paper at ICLR 2020 striking to observe that even the most powerful networks considered could not achieve a test accuracy above 95% for n > 16; for n = 40 their best accuracy was below 80%. Effect of anonymity. Figure 2a plots example training and test curves for GNN mp trained with four different node attributes: no attributes (anonymous), a one-hot encoding of the node degrees (degree), a one-hot encoding of node ids (unique id), and a one-hot encoding of node ids that changed across graphs (random unique id). It can be clearly observed that there is a direct correlation between accuracy and the type of attributes used. With non- or partially-discriminative attributes, the network could not detect cycles even in the training set. The cycle detection problem was solved exactly with unique ids, but when the latter were inconsistently assigned, the network could not learn to generalize. Exchangeability of depth and width. Figure 2b examines further the relationship between depth, width, and test accuracy. This time, networks were separated depending on their depth and width normalized by the square root of the "critical capacity". For each n, the critical capacity is the minimum dw of a network that was able to solve the task on a graph of n nodes-here, solving amounts to a test accuracy above 95%. In this way, a network of depth d and width w tested on n nodes corresponds to a point positioned at x = d/ √ critical, y = w/ √ critical and no network positioned at xy < 1 can solve the task (non-highlighted region in the bottom left corner). As seen, there is a crisp phase transition between the regime of under- and super-critical capacity: almost every network meeting the condition dw ≥ critical was able to solve the task, irrespective of whether the depth or width was larger. Note that, the exchangeability of depth and width cannot be guaranteed by the proposed theory which asserts that the condition dw =Ω( √ n) is necessary-but not sufficient. The empirical results however do agree with the hypothesis that, for 4-cycle classification, depth and width are indeed exchangeable.

Section Title: CONCLUSION
  CONCLUSION This work studied the expressive power of graph neural networks falling within the message-passing framework. Two results were derived. First, sufficient conditions were provided such that GNN mp can compute any function computable by a Turing machine with the same connected graph as input. Second, it was discovered that the product of a GNN mp 's depth and width plays a prominent role in determining whether the network can solve various graph-theoretic problems. Specifically, it was shown that GNN n mp with dw =Ω(n δ ) and δ ∈ [0.5, 2] cannot solve a range of decision, optimization, and estimation problems involving graphs. Overall, the proposed results demonstrate that the power of graph neural networks depends critically on their capacity and illustrate the importance of using discriminative node attributes.
  The considered graphs featured the same node set (with different edges) and a one-hot encoding of the node-ids was used as input features.

```
