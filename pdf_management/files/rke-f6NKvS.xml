<article article-type="research-article"><front><article-meta><title-group><article-title>Published as a conference paper at ICLR 2020 LEARNING SELF-CORRECTABLE POLICIES AND VALUE FUNCTIONS FROM DEMONSTRATIONS WITH NEGATIVE SAMPLING</article-title></title-group><contrib-group content-type="author"><contrib contrib-type="person"><name><surname>Luo</surname><given-names>Yuping</given-names></name></contrib><contrib contrib-type="person"><name><surname>Xu</surname><given-names>Huazhe</given-names></name></contrib><contrib contrib-type="person"><name><surname>Ma</surname><given-names>Tengyu</given-names></name></contrib><contrib contrib-type="person"><xref ref-type="aff" rid="aff0" /></contrib></contrib-group><aff id="aff0"><institution content-type="orgname">Princeton University yupingl</institution></aff><aff id="aff1"><institution content-type="orgname">University of California, Berkeley huazhe_xu@eecs.berkeley.edu</institution></aff><abstract><p>Imitation learning, followed by reinforcement learning algorithms, is a promising paradigm to solve complex control tasks sample-efficiently. However, learning from demonstrations often suffers from the covariate shift problem, which results in cascading errors of the learned policy. We introduce a notion of conservatively- extrapolated value functions, which provably lead to policies with self-correction. We design an algorithm Value Iteration with Negative Sampling (VINS) that practically learns such value functions with conservative extrapolation. We show that VINS can correct mistakes of the behavioral cloning policy on simulated robotics benchmark tasks. We also propose the algorithm of using VINS to initialize a reinforcement learning algorithm, which is shown to outperform prior works in sample efficiency.</p></abstract></article-meta></front><body><sec><title>INTRODUCTION</title><p>Reinforcement learning (RL) algorithms, especially with sparse rewards, often require a large amount of trial-and-errors. Imitation learning from a small number of demonstrations followed by RL fine- tuning is a promising paradigm to improve the sample efficiency (<xref ref-type="bibr" rid="b0">Rajeswaran et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Ve&#269;er&#237;k et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Hester et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Nair et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Gao et al., 2018</xref>). The key technical challenge of learning from demonstrations is the covariate shift: the distribution of the states visited by the demonstrations often has a low-dimensional support; however, knowledge learned from this distribution may not necessarily transfer to other distributions of interests. This phenomenon applies to both learning the policy and the value function. The policy learned from behavioral cloning has compounding errors after we execute the policy for multiple steps and reach unseen states (Bagnell, 2015; <xref ref-type="bibr" rid="b0">Ross &amp; Bagnell, 2010</xref>). The value function learned from the demonstrations can also extrapolate falsely to unseen states. See Figure 1a for an illustration of the false extrapolation in a toy environment.</p><p>We develop an algorithm that learns a value function that extrapolates to unseen states more con- servatively, as an approach to attack the optimistic extrapolation problem (<xref ref-type="bibr" rid="b0">Fujimoto et al., 2018a</xref>). Consider a state s in the demonstration and its nearby states that is not in the demonstration. The key intuition is thats should have a lower value than s, because otherwises likely should have been visited by the demonstrations in the first place. If a value function has this property for most of the pair (s,s) of this type, the corresponding policy will tend to correct its errors by driving back to the demonstration states because the demonstration states have locally higher values. We formalize the intuition in Section 4 by defining the so-called conservatively-extrapolated value function, which is guaranteed to induce a policy that stays close to the demonstrations states (Theorem 4.4).</p><p>In Section 5, we design a practical algorithm for learning the conservatively-extrapolated value function by a negative sampling technique inspired by work on learning embeddings <xref ref-type="bibr" rid="b0">Mikolov et al. (2013)</xref>; <xref ref-type="bibr" rid="b0">Gutmann &amp; Hyv&#228;rinen (2012)</xref>. We also learn a dynamical model by standard supervised learning so that we compute actions by maximizing the values of the predicted next states. This algorithm does not use any additional environment interactions, and we show that it empirically helps correct errors of the behavioral cloning policy.</p></sec><sec><title>Published as a conference paper at ICLR 2020</title><p>(a) The value function learned from the stan- dard Bellman equation (or supervised learning) on the demonstration states. The value function falsely extrapolates to the unseen states. For example, the top left corner has erroneously the largest value. As a result, once the policy induced by the value function makes a mistake, the error will compound.</p><p>(b) The conservatively-extrapolated value func- tion (defined in equation (4.2)) learned with negative sampling (VINS, Algorithm 2 in Sec- tion 5). The values at unseen states tend to be lower than their nearby states in the demonstra- tions, and therefore the corresponding policy tend to correct itself towards the demonstration trajectories. When additional environment interactions are available, we use the learned value function and the dynamical model to initialize an RL algorithm. This approach relieves the inefficiency in the prior work (<xref ref-type="bibr" rid="b0">Hester et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Nair et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Rajeswaran et al., 2017</xref>) that the randomly-initialized Q functions require a significant amount of time and samples to be warmed up, even though the initial policy already has a non-trivial success rate. Empirically, the proposed algorithm outperforms the prior work in the number of environment interactions needed to achieve near-optimal success rate. In summary, our main contributions are: 1) we formalize the notion of values functions with conservative extrapolation which are proved to induce policies that stay close to demonstration states and achieve near-optimal performances, 2) we propose the algorithm Value Iteration with Negative Sampling (VINS) that outperforms behavioral cloning on three simulated robotics benchmark tasks with sparse rewards, and 3) we show that initializing an RL algorithm from VINS outperforms prior work in sample efficiency on the same set of benchmark tasks.</p></sec><sec><title>RELATED WORK</title></sec><sec><title>Imitation learning.</title><p>Imitation learning is commonly adopted as a standard approach in robotics (<xref ref-type="bibr" rid="b0">Pomerleau, 1989</xref>; <xref ref-type="bibr" rid="b0">Schaal, 1997</xref>; <xref ref-type="bibr" rid="b3">Argall et al., 2009</xref>; <xref ref-type="bibr" rid="b0">Osa et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Ye &amp; Alterovitz, 2017</xref>; <xref ref-type="bibr" rid="b1">Aleotti &amp; Caselli, 2006</xref>; <xref ref-type="bibr" rid="b0">Lawitzky et al., 2012</xref>; <xref ref-type="bibr" rid="b0">Torabi et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Le et al., 2017</xref>; 2018) and many other areas such as playing games (<xref ref-type="bibr" rid="b0">Mnih et al., 2013</xref>). Behavioral cloning (<xref ref-type="bibr" rid="b5">Bain &amp; Sommut, 1999</xref>) is one of the underlying central approaches. See <xref ref-type="bibr" rid="b0">Osa et al. (2018)</xref> for a thorough survey and more references therein. If we are allowed to access an expert policy (instead of trajectories) or an approximate value function, in the training time or in the phase of collecting demonstrations, then, stronger algorithms can be designed, such as DAgger (<xref ref-type="bibr" rid="b0">Ross et al., 2011</xref>), AggreVaTe (<xref ref-type="bibr" rid="b0">Ross &amp; Bagnell, 2014</xref>), AggreVaTeD (<xref ref-type="bibr" rid="b0">Sun et al., 2017</xref>), DART (<xref ref-type="bibr" rid="b0">Laskey et al., 2017</xref>), THOR <xref ref-type="bibr" rid="b0">Sun et al. (2018a)</xref>. Our setting is that we have only clean demonstrations trajectories and a sparse reward (but we still hope to learn the self-correctable policy.) <xref ref-type="bibr" rid="b0">Ho &amp; Ermon (2016)</xref>; <xref ref-type="bibr" rid="b0">Wang et al. (2017)</xref>; <xref ref-type="bibr" rid="b0">Schroecker et al. (2018)</xref> successfully combine generative models in the setting where a large amount of environment interaction without rewards are allowed. The sample efficiency of (<xref ref-type="bibr" rid="b0">Ho &amp; Ermon, 2016</xref>) has been improved in various ways, including maximum mean discrepancy minimization (<xref ref-type="bibr" rid="b0">Kim &amp; Park, 2018</xref>), a Bayesian formulation of GAIL (<xref ref-type="bibr" rid="b0">Jeon et al., 2018</xref>), using an off-policy RL algorithm and solving reward bias problem (<xref ref-type="bibr" rid="b0">Kostrikov et al., 2018</xref>), and bypassing the learning of reward function (<xref ref-type="bibr" rid="b0">Sasaki et al., 2018</xref>). By contrast, we would like to minimize the amount of environment interactions needed, but are allowed to access a sparse reward. The work (<xref ref-type="bibr" rid="b0">Schroecker &amp; Isbell, 2017</xref>) also aims to learn policies that can stay close to the demonstration sets, but through a quite different approach of estimating the true MAP estimate of the Published as a conference paper at ICLR 2020 policy. The algorithm also requires environment interactions, whereas one of our main goals is to improve upon behavioral cloning without any environment interactions.</p><p>Inverse reinforcement learning (e.g., see (<xref ref-type="bibr" rid="b0">Abbeel &amp; Ng, 2004</xref>; <xref ref-type="bibr" rid="b0">Ng et al., 2000</xref>; <xref ref-type="bibr" rid="b0">Ziebart et al., 2008</xref>; <xref ref-type="bibr" rid="b0">Finn et al., 2016a</xref>;b; <xref ref-type="bibr" rid="b0">Fu et al., 2017</xref>)) is another important and successful line of ideas for imitation learning. It relates to our approach in the sense that it aims to learn a reward function that the expert is optimizing. In contrast, we construct a model to learn the value function (of the trivial sparse reward R(s, a) = &#8722;1), rather than the reward function. Some of these works (e.g., (<xref ref-type="bibr" rid="b0">Finn et al., 2016a</xref>;b; <xref ref-type="bibr" rid="b0">Fu et al., 2017</xref>)) use techniques that are reminiscent of negative sampling or contrastive learning, although unlike our methods, they use "negative samples" that are sampled from the environments.</p></sec><sec><title>Leveraging demonstrations for sample-efficient reinforcement learning</title><p>Demonstrations have been widely used to improve the efficiency of RL (<xref ref-type="bibr" rid="b0">Kim et al., 2013</xref>; <xref ref-type="bibr" rid="b7">Chemali &amp; Lazaric, 2015</xref>; <xref ref-type="bibr" rid="b0">Piot et al., 2014</xref>; <xref ref-type="bibr" rid="b0">Sasaki et al., 2018</xref>), and a common paradigm for continuous state and action space is to initialize with RL algorithms with a good policy or Q function (<xref ref-type="bibr" rid="b0">Rajeswaran et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Nair et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Ve&#269;er&#237;k et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Hester et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Gao et al., 2018</xref>). We experimentally compare with the previous state-of-the-art algorithm in <xref ref-type="bibr" rid="b0">Nair et al. (2018)</xref> on the same type of tasks. <xref ref-type="bibr" rid="b0">Gao et al. (2018)</xref> has introduced soft version of actor-critic to tackle the false extrapolation of Q in the argument of a when the action space is discrete. In contrast, we deal with the extrapolation of the states in a continuous state and action space.</p></sec><sec><title>Model-based reinforcement learning</title><p>Even though we will learn a dynamical model in our algo- rithms, we do not use it to generate fictitious samples for planning. Instead, the learned dynamics are only used in combination with the value function to get a Q function. Therefore, we do not consider our algorithm as model-based techniques. We refer to (<xref ref-type="bibr" rid="b0">Kurutach et al., 2018</xref>; <xref ref-type="bibr" rid="b9">Clavera et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Sun et al., 2018b</xref>; <xref ref-type="bibr" rid="b8">Chua et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Sanchez-Gonzalez et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Pascanu et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Khansari-Zadeh &amp; Billard, 2011</xref>; <xref ref-type="bibr" rid="b0">Luo et al., 2018</xref>) and the reference therein for recent work on model-based RL.</p></sec><sec><title>Off-policy reinforcement learning</title><p>There is a large body of prior works in the domain of off-policy RL, including extensions of policy gradient (<xref ref-type="bibr" rid="b0">Gu et al., 2016</xref>; <xref ref-type="bibr" rid="b10">Degris et al., 2012</xref>; <xref ref-type="bibr" rid="b0">Wang et al., 2016</xref>) or Q-learning (<xref ref-type="bibr" rid="b0">Watkins &amp; Dayan, 1992</xref>; <xref ref-type="bibr" rid="b0">Haarnoja et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Munos et al., 2016</xref>). <xref ref-type="bibr" rid="b0">Fujimoto et al. (2018a)</xref> propose to solve off-policy reinforcement learning by constraining the action space, and <xref ref-type="bibr" rid="b0">Fujimoto et al. (2018c)</xref> use double Q-learning (<xref ref-type="bibr" rid="b0">Van Hasselt et al., 2016</xref>) to alleviate the optimistic extrapolation issue. In contrast, our method adjusts the erroneously extrapolated value function by explicitly penalizing the unseen states (which is customized to the particular demonstration off- policy data). For most of the off-policy methods, their convergence are based on the assumption of visiting each state-action pair sufficiently many times. In the learning from demonstration setting, the demonstrations states are highly biased or structured; thus off-policy method may not be able to learn much from the demonstrations.</p></sec><sec><title>PROBLEM SETUP AND CHALLENGES</title><p>We consider a setting with a deterministic MDP with continuous state and action space, and sparse rewards. Let S = R d be the state space and A = R k be the action space, and let M : R d &#215;R k &#8594; R d be the deterministic dynamics. At test time, a random initial state s 0 is generated from some distribution D s0 . We assume D s0 has a low-dimensional bounded support because typically initial states have special structures. We aim to find a policy &#960; such that executing &#960; from state s 0 will lead to a set of goal states G. All the goal states are terminal states, and we run the policy for at most T steps if none of the goal states is reached.</p><p>Let &#964; = (s 0 , a 1 , s 1 , . . . , ) be the trajectory obtained by executing a deterministic policy &#960; from s 0 , where a t = &#960;(s t ), and s t+1 = M (s t , a t ). The success rate of the policy &#960; is defined as succ(&#960;) = E [1{&#8707;t &#8804; T, s t &#8712; G}] (3.1) where the expectation is taken over the randomness of s 0 . Note that the problem comes with a natural sparse reward: R(s, a) = &#8722;1 for every s and a. This will encourage reaching the goal with as small number of steps as possible: the total payoff of a trajectory is equal to negative the number of steps if the trajectory succeeds, or &#8722;T otherwise.</p></sec><sec><title>Published as a conference paper at ICLR 2020</title><p>Let &#960; e be an expert policy 1 from which a set of n demonstrations are sampled. Concretely, n independent initial states {s (i) 0 } n i=1 from D s0 are generated, and the expert executes &#960; e to collect a set of n trajectories {&#964; (i) } n i=1 . We only have the access to the trajectories but not the expert policy itself. We will design algorithms for two different settings:</p></sec><sec><title>Imitation learning without environment interactions</title><p>The goal is to learn a policy &#960; from the demonstration trajectories {&#964; (i) } n i=1 without having any additional interactions with the environment. Leveraging demonstrations in reinforcement learning: Here, in addition to the demonstrations, we can also interact with the environment (by sampling s 0 &#8764; D s0 and executing a policy) and observe if the trajectory reaches the goal. We aim is to minimize the amount of environment interactions by efficiently leveraging the demonstrations.</p><p>Let U be the set of states that can be visited by the demonstration policy from a random state s 0 with positive probability. Throughout this paper, we consider the situation where the set U is only a small subset or a low-dimensional manifold of the entire state space. This is typical for continuous state space control problems in robotics, because the expert policy may only visit a very special kind of states that are the most efficient for reaching the goal. For example, in the toy example in <xref ref-type="fig" rid="fig_0">Figure 1</xref>, the set U only contains those entries with black edges. To put our theoretical motivation in Section 4 into context, next we summarize a few challenges of imitation learning that are particularly caused by that U is only a small subset of the state space.</p></sec><sec><title>Cascading errors for behavioral cloning</title><p>As pointed out by <xref ref-type="bibr" rid="b4">Bagnell (2015)</xref>; <xref ref-type="bibr" rid="b0">Ross &amp; Bagnell (2010)</xref>, the errors of the policy can compound into a long sequence of mistakes and in the worst case cascade quadratically in the number of time steps T . From a statistical point of view, the fundamental issue is that the distribution of the states that a learned policy may encounter is different from the demonstration state distribution. Concretely, the behavioral cloning &#960; BC performs well on the states in U but not on those states far away from U. However, small errors of the learned policy can drive the state to leave U, and then the errors compound as we move further and further away from U. As shown in Section 4, our key idea is to design policies that correct themselves to stay close to the set U.</p></sec><sec><title>Degeneracy in learning value or Q functions from only demonstrations</title><p>When U is a small subset or a low-dimensional manifold of the state space, off-policy evaluation of V &#960;e and Q &#960;e is fundamentally problematic in the following sense. The expert policy &#960; e is not uniquely defined outside U because any arbitrary extension of &#960; e outside U would not affect the performance of the expert policy (because those states outside U will never be visited by &#960; e from s 0 &#8764; D s0 ). As a result, the value function V &#960;e and Q &#960;e is not uniquely defined outside U. In Section 4, we will propose a conservative extrapolation of the value function that encourages the policy to stay close to U. Fitting Q &#960;e is in fact even more problematic. We refer to Section A for detailed discussions and why our approach can alleviate the problem.</p></sec><sec><title>Success and challenges of initializing RL with imitation learning</title><p>A successful paradigm for sample-efficient RL is to initialize the RL policy by some coarse imitation learning algorithm such as BC (<xref ref-type="bibr" rid="b0">Rajeswaran et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Ve&#269;er&#237;k et al., 2017</xref>; <xref ref-type="bibr" rid="b0">Hester et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Nair et al., 2018</xref>; <xref ref-type="bibr" rid="b0">Gao et al., 2018</xref>). However, the authors suspect that the method can still be improved, because the value function or the Q function are only randomly initialized so that many samples are burned to warm them up. As alluded before and shown in Section 4, we will propose a way to learn a value function from the demonstrations so that the following RL algorithm can be initialized by a policy, value function, and Q function (which is a composition of value and dynamical model) and thus converge faster.</p></sec><sec><title>THEORETICAL MOTIVATIONS</title><p>In this section, we formalize our key intuition that the ideal extrapolation of the value function V &#960;e should be that the values should decrease as we get further and further from the demonstrations. Recall that we use U to denote the set of states reachable by the expert policy from any initial state s 0 Published as a conference paper at ICLR 2020 Goal drawn with positive probability from D s0 . 3 We use &#183; to denote a norm in Euclidean space R d . Let &#928; U (s) be the projection of s &#8712; R d to a set U &#8834; R d (according to the norm &#183; ) 4 . We introduce the notion of value functions with conservative extrapolation which matches V &#960;e on the demonstration states U and has smaller values outside U. As formally defined in equation (4.1) and (4.2) in Alg. 1, we extrapolate V &#960;e in a way that the value at s &#8712; U is decided by the value of its nearest neighbor in U (that is V &#960;e (&#928; U (s)), and its distance to the nearest neighbor (that is, s &#8722; &#928; U (s) ). We allow a &#948; V &gt; 0 error because exact fitting inside or outside U would be impossible.</p></sec><sec><title>Algorithm 1 Self-correctable policy induced from a value function with conservative extrapolation</title><p>and a locally approximately correct dynamics M and BC policy &#960; BC satisfying Assumption (4.1). Besides a conservatively-extrapolated value function V , our Alg. 1 relies on a learned dynamical model M and a behavioral cloning policy &#960; BC . With these, the policy returns the action with the maximum value of the predicted next state in around the action of the BC policy. In other words, the policy &#960; attempts to re-adjust the BC policy locally by maximizing the value of the next state. Towards analyzing Alg. 1, we will make a few assumptions. We first assume that the BC policy is correct in the set U, and the dynamical model M is locally correct around the set U and the BC actions. Note that these are significantly weaker than assuming that the BC policy is globally correct (which is impossible to ensure) and that the model M is globally correct. Assumption 4.1 (Local errors in learned dynamics and BC policy). We assume the BC policy &#960; BC makes at most &#948; &#960; error in U: for all s &#8712; U, we have &#960; BC (s) &#8722; &#960; e (s) &#8804; &#948; &#960; . We also assume that the learned dynamics M has &#948; M error locally around U and the BC actions in the sense that for all s that is &#949;-close to U, and any action that is &#950;-close to &#960; BC (s), we have M (s, a) &#8722; M (s, a) &#8804; &#948; M .</p><p>We make another crucial assumption on the stability/correctability of the true dynamics. The following assumption essentially says that if we are at a state that is near the demonstration set, then there exists an action that can drive us closer to the demonstration set. This assumption rules out certain dynamics that does not allow corrections even after the policy making a small error. For example, if Published as a conference paper at ICLR 2020 a robot, unfortunately, falls off a cliff, then fundamentally it cannot recover itself - our algorithm cannot deal with such pathological situations.</p><p>Assumption 4.2 (Locally-correctable dynamics). For some &#947; &#8712; (0, 1) and &#949; &gt; 0, L c &gt; 0, we assume that the dynamics M is (&#947;, L c , &#949;)-locally-correctable w.r.t to the set U in the sense that for all &#949; 0 &#8712; (0, &#949;] and any tuple (s,&#257;,s ) satisfyings,s &#8712; U ands = M (s,&#257;), and any &#949; 0 -perturbation s ofs (that is, s &#8712; N &#949;0 (s)), there exists an action a cx that is L c &#949; 0 close to&#257;, such that it makes a correction in the sense that the resulting state s is &#947;&#949; 0 -close to the set U: s = M (s, a cx ) &#8712; N &#947;&#949;0 (U). Here N &#948; (K) denotes the set of points that are &#948;-close to K.</p><p>Finally, we will assume the BC policy, the value function, and the dynamics are all Lipschitz in their arguments. 5 We also assume the projection operator to the set U is locally Lipschitz. These are regularity conditions that provide loose local extrapolation of these functions, and they are satisfied by parameterized neural networks that are used to model these functions.</p><p>Assumption 4.3 (Lipschitz-ness of policy, value function, and dynamics). We assume that the policy &#960; BC is L &#960; -Lipschitz. That is, &#960; BC (s) &#8722; &#960; BC (s) &#8804; L &#960; s &#8722;s for all s,s. We assume the value function V &#960;e and the learned value function V are L V -Lipschitz, the model M is L M,a - Lipschitz w.r.t to the action and L M,s -Lipschitz w.r.t to the state s. We also assume that the set U has L &#928; -Lipschitz projection locally: for all s,&#349; that is &#949;-close to U, &#928; U (s) &#8722; &#928; U (&#349;) &#8804; L &#928; s &#8722;&#349; . Under these assumptions, now we are ready to state our main theorem. It claims that 1) the induced policy &#960; in Alg. 1 stays close to the demonstration set and performs similarly to the expert policy &#960; e , and 2) following the induced policy &#960;, we will arrive at a state with a near-optimal value.</p><p>. Then, the policy &#960; from equation (4.3) satisfies the following:</p><p>1. Starting from s 0 &#8712; U and executing policy &#960; for T 0 &#8804; T steps, the resulting states s 1 , . . . , s T0 are all &#949;-close to the demonstrate states set U.</p><p>2. In addition, suppose the expert policy makes at least &#961; improvement every step in the sense that for every s &#8712; U, either V &#960;e (M (s, &#960; e (s))) &#8805; V &#960;e (s) + &#961; or M (s, &#960; e (s)) reaches the goal. 6 Assume &#949; and &#948; M , &#948; V , &#948; &#960; are small enough so that they satisfy &#961; &#949; + &#948; &#960; . Then, the policy &#960; will achieve a state s T with T &#8804; 2|V &#960;e (s 0 )|/&#961; steps which is &#949;-close to a states T with value at least V &#960;e (s T ) &#8722;(&#949; + &#948; &#960; ). 7</p><p>The proof is deferred to Section B. The first bullet follows inductively invoking the following lemma which states that if the current state is &#949;-close to U, then so is the next state. The proof of the Lemma is the most mathematically involved part of the paper and is deferred to the Section B. We demonstrate the key idea of the proof in <xref ref-type="fig" rid="fig_1">Figure 2</xref> and its caption.</p><p>Lemma 4.5. In the setting of Theorem 4.4, suppose s is &#949;-close to the demonstration states set U. Suppose U, and let a = &#960;(s) and s = M (s, a). Then, s is also &#949;-close to the set U.</p><p>We effectively represent the Q function by V (M (s, a)) in Alg. 1. We argue in Section A.1 that this helps address the degeneracy issue when there are random goal states (which is the case in our experiments.)</p></sec><sec><title>Discussion: can we learn conservatively-extrapolated Q-function?</title><p>We remark that we do not expect a conservative-extrapolated Q-functions would be helpful. The fundamental idea here is to penalize the value of unseen states so that the policy can self-correct. However, to learn a Q function that induces self-correctable policies, we should encourage unseen actions that can correct the trajectory, instead of penalize them just because they are not seen before. Therefore, it is crucial that the penalization is done on the unseen states (or V ) but not the unseen actions (or Q).</p></sec><sec><title>MAIN APPROACH</title><p>Learning value functions with negative sampling from demonstration trajectories. As moti- vated in Section 4 by Algorithm 1 and Theorem 4.4, we first develop a practical method that can learn a value function with conservative extrapolation, without environment interaction. Let V &#966; be a value function parameterized by &#966;. Using the standard TD learning loss, we can ensure the value function to be accurate on the demonstration states U (i.e., to satisfy equation (4.1)). Let&#966; be the target value function, 8 the TD learning loss is defined as L td (&#966;) = E (s,a,s )&#8764;&#961; &#960;e r(s, a) + V&#966;(s ) &#8722; V &#966; (s) 2 where r(s, a) is the (sparse) reward,&#966; is the parameter of the target network, &#961; &#960;e is the distribution of the states-action-states tuples of the demonstrations. The crux of the ideas in this paper is to use a negative sampling technique to enforce the value function to satisfy conservative extrapolation requirement (4.2). It would be infeasible to enforce condition (4.2) for every s &#8712; U. Instead, we draw random "negative samples"s from the neighborhood of U, and enforce the condition (4.2). This is in- spired by the negative sampling approach widely used in NLP for training word embeddings <xref ref-type="bibr" rid="b0">Mikolov et al. (2013)</xref>; <xref ref-type="bibr" rid="b0">Gutmann &amp; Hyv&#228;rinen (2012)</xref>. Concretely, we draw a sample s &#8764; &#961; &#960;e , create a random perturbation of s to get a points &#8712; U. and construct the following loss function: 9</p><p>The rationale of the loss function can be best seen in the situation when U is assumed to be a low- dimensional manifold in a high-dimensional state space. In this case,s will be outside the manifold U with probability 1. Moreover, the random directions &#8722; s is likely to be almost orthogonal to the tangent space of the manifold U, and thus s is a reasonable approximation of the projection ofs back to the U, and s &#8722;s is an approximation of &#928; Us &#8722;s . If U is not a manifold but a small subset of the state space, these properties may still likely to hold for a good fraction of s.</p><p>We only attempt to enforce condition (4.2) for states near U. This likely suffices because the induced policy is shown to always stay close to U. Empirically, we perturb s by adding a Gaussian noise. The loss function to learn V &#966; is defined as L(&#966;) = L td (&#966;) + &#181;L ns (&#966;) for some constant &#181; &gt; 0. For a mini-batch B of data, we define the corresponding empirical loss by L(&#966;; B) (similarly we define L td (&#966;; B) and L ns (&#966;; B)). The concrete iterative learning algorithm is described in line 1-7 of Algorithm 2 (except line 6 is for learning the dynamical model, described below.)</p></sec><sec><title>Learning the dynamical model</title></sec><sec><title>Optimization for policy</title><p>We don't maintain an explicit policy but use an induced policy from V &#966; and M &#952; by optimizing equation (4.3). A natural choice would be using projected gradient ascent to Published as a conference paper at ICLR 2020 optimize equation (4.3). It's also possible to use cross-entropy methods in (<xref ref-type="bibr" rid="b0">Kalashnikov et al., 2018</xref>) to optimize it. However, we found the random shooting suffices because the action space is relatively low-dimensional in our experiments. Moreover, the randomness introduced appears to reduce the overfitting of the model and value function slightly. As shown in line 10-13 of Alg. 2, we sample k actions in the feasible set and choose the one with maximum V &#966; (M &#952; (s, a)).</p></sec><sec><title>Value iteration with environment interaction</title><p>As alluded before, when more environment interac- tions are allowed, we initialize an RL algorithm by the value function, dynamics learned from VINS. Given that we have V and M in hand, we alternate between fitted value iterations for updating the value function and supervised learning for updating the models. (See Algorithm 3 in Section C.) We do not use negative sampling here since the RL algorithms already collect bad trajectories automatically. We also do not hallucinate any goals as in HER (<xref ref-type="bibr" rid="b2">Andrychowicz et al., 2017</xref>).</p></sec><sec><title>EXPERIMENTS</title></sec><sec><title>Environments</title><p>We evaluate our algorithms in three simulated robotics environments 10 designed by (<xref ref-type="bibr" rid="b0">Plappert et al., 2018</xref>) based on OpenAI Gym (<xref ref-type="bibr" rid="b6">Brockman et al., 2016</xref>) and MuJoCo (<xref ref-type="bibr" rid="b0">Todorov et al., 2012</xref>): Reach, Pick-And-Place, and Push. A detailed description can be found in Section D.1.</p></sec><sec><title>Demonstrations</title><p>For each task, we use Hindsight Experience Replay (HER) (<xref ref-type="bibr" rid="b2">Andrychowicz et al., 2017</xref>) to train a policy until convergence. The policy rolls out to collect 100/200 successful trajectories as demonstrations except for Reach environment where 100 successful trajectories are sufficient for most of the algorithms to achieve optimal policy. We filtered out unsuccessful trajectories during data collection.</p><p>We consider two settings: imitation learning from only demonstrations data, and leveraging demon- stration in RL with a limited amount of interactions. We compare our algorithm with Behavioral Cloning and multiple variants of our algorithms in the first setting. We compare with the previous state-of-the-art by <xref ref-type="bibr" rid="b0">Nair et al. (2018)</xref>, and GAIL <xref ref-type="bibr" rid="b0">Ho &amp; Ermon (2016)</xref> in the second setting. We do not compare with (<xref ref-type="bibr" rid="b0">Gao et al., 2018</xref>) because it cannot be applied to the case with continuous actions.</p><p>Behavioral Cloning (<xref ref-type="bibr" rid="b5">Bain &amp; Sommut, 1999</xref>). Behavioral Cloning (BC) learns a mapping from a state to an action on demonstration data using supervised learning. We use MSE loss for predicting the actions.</p><p>Nair et al.'18 (<xref ref-type="bibr" rid="b0">Nair et al., 2018</xref>). The previous state-of-the-art algorithm from <xref ref-type="bibr" rid="b0">Nair et al. (2018)</xref> combines HER (<xref ref-type="bibr" rid="b2">Andrychowicz et al., 2017</xref>) with BC and a few techniques: 1) an additional replay buffer filled with demonstrations, 2) an additional behavioral cloning loss for the policy, 3) a Q-filter for non-optimal demonstrations, 4) resets to states in the demonstrations to deal with long horizon tasks. We note that reseting to an arbitrary state may not be realistic for real-world applications in robotics. In contrast, our algorithm does not require resetting to a demonstration state.</p><p>GAIL (<xref ref-type="bibr" rid="b0">Ho &amp; Ermon, 2016</xref>) Generative Adversarial Imitation Learning (GAIL) imitates the expert by matching the state-action distribution with a GAN-like framework.</p><p>HER (<xref ref-type="bibr" rid="b2">Andrychowicz et al., 2017</xref>) Hindsight Experience Replay (HER) is the one of the best techniques that deal with sparse-reward environments with multiple goals and can be combined with any off-policy RL algorithm. The key idea is that HER extends the replay buffer by changing the goals. With reasonable chosen goals, the underlying off-policy RL algorihtm can receive more signals from the generated experience, making policy optimization more complete.</p><p>DAC (<xref ref-type="bibr" rid="b0">Kostrikov et al., 2018</xref>) Discriminator-Actor-Critic (DAC) is a sample-efficient imitation learning algorihtm built on the top of GAIL. It addresses the reward bias problem by adapting AIRL reward function and introducing an absorbing state. Furthermore, it replaces the underlying RL algorithm in GAIL by TD3 (<xref ref-type="bibr" rid="b0">Fujimoto et al., 2018b</xref>) to make it more sample efficient.</p></sec><sec><title>VINS</title><p>As described in Section 5, in the setting without environment interaction, we use Algorithm 2; otherwise we use it to initialize an RL algorithm (see Algorithm 3). We use neural networks to param- eterize the value function and the dynamics model. The granularity of the HER demonstration policy is very coarse, and we argument the data with additional linear interpolation between consecutive states. We also use only a subset of the states as inputs to the value function and the dynamics model, Published as a conference paper at ICLR 2020 which apparently helps improve the training and generalization of them. Implementation details can be found in Section D.2.</p><p>Our main results are reported in <xref ref-type="table" rid="tab_0">Table 1</xref> 11 for the setting with no environment interaction and <xref ref-type="fig" rid="fig_2">Figure 3</xref> for the setting with environment interactions. <xref ref-type="table" rid="tab_0">Table 1</xref> shows that the Reach environment is too simple so that we do not need to run the RL algorithm. On the harder environments Pick-And-Place and Push, our algorithm VINS outperforms BC. We believe this is because our conservatively-extrapolated value function helps correct the mistakes in the policy. Here we use 2k trials to estimate the success rate (so that the errors in the estimation is negligible), and we run the algorithms with 10 different seeds. The error bars are for 1 standard error. <xref ref-type="fig" rid="fig_2">Figure 3</xref> shows that VINS initialized RL algorithm outperforms prior state-of-the-art in sample efficiency. We believe the main reason is that due to the initialization of value and model, we pay less samples for warming up the value function. We note that our initial success rate in RL is slightly lower than the final result of VINS in <xref ref-type="table" rid="tab_0">Table 1</xref>. This is because in RL we implemented a slightly worse variant of the policy induced by VINS: in the policy of Algorithm 2, we use option 2 to search the action uniformly. This suffices because the additional interactions quickly allows us to learn a good model and the BC constraint is no longer needed.</p></sec><sec><title>Ablation studies</title><p>Towards understanding the effect of each component of VINS, we perform three ablative experiments to show the importance of negative sampling, searching in the neighborhood of Behavioral Cloned actions (option 1 in line 10 or Algorithm 2), and a good dynamics model. The results are shown in <xref ref-type="table" rid="tab_1">Table 2</xref>. We study three settings: (1) VINS without negative sampling (VINS w/o NS), where the loss L ns is removed; (2) VINS without BC (VINS w/o BC), where option 2 in line 10 or Algorithm 2 is used; (3) VINS with oracle model without BC (VINS w/ oracle w/o BC), where we use the true dynamics model to replace line 12 of Algorithm 2. Note that the last setting is only synthetic for ablation study because in the real-world we don't have access to the true dynamics model. Please see the caption of <xref ref-type="table" rid="tab_1">Table 2</xref> for more interpretations. We use the same set of hyperparameters for the same environment, which may not be optimal: for example, with more expert trajectories, the negative sampling loss L ns , which can be seen as a regularziation, should be assigned a smaller coefficient &#181;.</p></sec><sec><title>CONCLUSION</title><p>We devise a new algorithm, VINS, that can learn self-correctable by learning value function and dynamical model from demonstrations. The key idea is a theoretical formulation of conservatively- extrapolated value functions that provably leads to self-correction. The empirical results show a promising performance of VINS and an algorithm that initializes RL with VINS. It's a fascinating direction to study other algorithms that may learn conservatively-extrapolated value functions in Published as a conference paper at ICLR 2020 other real-world applications beyond the proof-of-concepts experiments in this paper. For example, the negative sampling by Gaussian perturbation technique in this paper may not make sense for high-dimensional pixel observation. The negative sampling can perhaps be done in the representation space (which might be learned by unsupervised learning algorithms) so that we can capture the geometry of the state space better.</p></sec><sec id="figures"><title>Figures</title><fig id="fig_0"><object-id>fig_0</object-id><label>Figure 1:</label><caption><title>Figure 1:</title><p>A toy environment where the agent aims to walk from a starting state (the yellow entry) to a goal state (the green entry). The reward is sparse: R(s, a) = &#8722;1 unless s is at the goal (which is also the terminal state.) The colors of the entries show the learned value functions. Entries in black edges are states in demonstrations. The cyan arrows show the best actions according to the value functions.</p></caption><graphic /><graphic /><graphic /><graphic /></fig><fig id="fig_1"><object-id>fig_1</object-id><label>Figure 2:</label><caption><title>Figure 2:</title><p>Illustration of the correction effect. A conservatively-extrapolated value function V , as shown in the figure, has lower values further away from U, and therefore the gradients of V point to- wards U. With such a value function, suppose we are at state s which is &#949;-close to U. The locally- correctable assumption of the dynamics assumes the existence of acx that will drive us to state scx that is closer to U than s. Since scx has a relatively higher value compared to other possible future states that are further away from U (e.g., s shown in the figure), scx will be preferred by the optimiza- tion (4.3). In other words, if an action a leads to state s with large distance to U, the action won't be picked by (4.3) because it cannot beat acx.</p></caption><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /><graphic /></fig><table-wrap id="tab_0"><label>Table 1:</label><caption><title>Table 1:</title><p>The success rates of achieving the goals for VINS and BC in the setting with- out any environment interactions. A random policy has about 5% success rate at Pick and Push.</p></caption><table><tbody><tr><td /></tr></tbody></table></table-wrap><fig id="fig_2"><object-id>fig_2</object-id><label>Figure 3:</label><caption><title>Figure 3:</title><p>The learning curves of VINS+RL (Algo- rithm 3) vs the prior state-of-the-art Nair et al.'18 on Pick-And-Place and Push. Shaded areas indicates one standard error estimated from 10 random seeds. 12</p></caption><graphic /></fig><table-wrap id="tab_1"><label>Table 2:</label><caption><title>Table 2:</title><p>Ablation study of components of VINS in the setting without environment interactions. We reported the average performance of 10 runs (with different random seeds) and the empirical standard error of the estimator of the average performance. The success rate of VINS w/o NS is consistently worse than VINS, which suggests that NS is crucial for tackling the false extrapolation. From comparisons between VINS w/o BC and VINS w/ oracle w/o BC, and between VINS and VINS w/ oracle, we observe that if the learning of the dynamics can be improved (potentially by e.g., by collecting data with random actions), then VINS or VINS w/o BC can be improved significantly. We also suspect that the reason why we need to search over the neighborhood of BC actions is that the dynamics is not accurate at state-action pairs far away from the demonstration set (because the dynamics is only learned on the demonstration set.)</p></caption><table><tbody><tr><td /></tr></tbody></table></table-wrap></sec></body><back><sec><p>//github.com/jangirrishabh/Overcoming-exploration-from-demos only evaluates after the first epoch.</p></sec><ref-list id="ref-list-1"><ref id="b0"><element-citation publication-type="journal"><article-title>Apprenticeship learning via inverse reinforcement learning</article-title><source>Proceedings of the twenty-first international conference on Machine learning</source><year>2004</year><fpage>1</fpage><lpage>1</lpage><person-group person-group-type="author"><name><surname>Abbeel</surname><given-names>Pieter</given-names></name><name><surname>Andrew</surname><given-names>Y</given-names></name><name><surname>Ng</surname><given-names /></name></person-group></element-citation></ref><ref id="b1"><element-citation publication-type="journal"><article-title>Grasp recognition in virtual reality for robot pregrasp planning by demon- stration</article-title><source>Proceedings 2006 IEEE International Conference on Robotics and Automation, 2006. ICRA 2006</source><fpage>2801</fpage><lpage>2806</lpage><person-group person-group-type="author"><name><surname>Aleotti</surname><given-names>Jacopo</given-names></name><name><surname>Caselli</surname><given-names>Stefano</given-names></name></person-group></element-citation></ref><ref id="b2"><element-citation publication-type="journal"><article-title>Hindsight experience replay</article-title><source>Advances in Neural Information Processing Systems</source><year>2017</year><fpage>5048</fpage><lpage>5058</lpage><person-group person-group-type="author"><name><surname>Andrychowicz</surname><given-names>Marcin</given-names></name><name><surname>Wolski</surname><given-names>Filip</given-names></name><name><surname>Ray</surname><given-names>Alex</given-names></name><name><surname>Schneider</surname><given-names>Jonas</given-names></name><name><surname>Fong</surname><given-names>Rachel</given-names></name><name><surname>Welinder</surname><given-names>Peter</given-names></name><name><surname>Mcgrew</surname><given-names>Bob</given-names></name><name><surname>Tobin</surname><given-names>Josh</given-names></name><name><surname>Pieter Abbeel</surname><given-names>Openai</given-names></name><name><surname>Zaremba</surname><given-names>Wojciech</given-names></name></person-group></element-citation></ref><ref id="b3"><element-citation publication-type="journal"><article-title>A survey of robot learning from demonstration</article-title><source>Robotics and autonomous systems</source><year>2009</year><volume>57</volume><issue>5</issue><fpage>469</fpage><lpage>483</lpage><person-group person-group-type="author"><name><surname>Brenna D Argall</surname><given-names>Sonia</given-names></name><name><surname>Chernova</surname><given-names>Manuela</given-names></name><name><surname>Veloso</surname><given-names>Brett</given-names></name><name><surname>Browning</surname><given-names /></name></person-group></element-citation></ref><ref id="b4"><element-citation publication-type="journal"><article-title>An invitation to imitation</article-title><source>Technical report, CARNEGIE-MELLON UNIV PITTSBURGH PA ROBOTICS INST</source><year>2015</year><person-group person-group-type="author"><name><surname>Andrew Bagnell</surname><given-names>J</given-names></name></person-group></element-citation></ref><ref id="b5"><element-citation publication-type="journal"><article-title>A framework for behavioural claning</article-title><source>Machine intelligence</source><year>1999</year><volume>15</volume><issue>15</issue><fpage>103</fpage><lpage>103</lpage><person-group person-group-type="author"><name><surname>Bain</surname><given-names>Michael</given-names></name><name><surname>Sommut</surname><given-names>Claude</given-names></name></person-group></element-citation></ref><ref id="b6"><element-citation publication-type="journal"><source>Openai gym</source><year>2016</year><person-group person-group-type="author"><name><surname>Brockman</surname><given-names>Greg</given-names></name><name><surname>Cheung</surname><given-names>Vicki</given-names></name><name><surname>Pettersson</surname><given-names>Ludwig</given-names></name><name><surname>Schneider</surname><given-names>Jonas</given-names></name><name><surname>Schulman</surname><given-names>John</given-names></name><name><surname>Tang</surname><given-names>Jie</given-names></name><name><surname>Zaremba</surname><given-names>Wojciech</given-names></name></person-group></element-citation></ref><ref id="b7"><element-citation publication-type="journal"><article-title>Direct policy iteration with demonstrations</article-title><source>Twenty-Fourth International Joint Conference on Artificial Intelligence</source><year>2015</year><person-group person-group-type="author"><name><surname>Chemali</surname><given-names>Jessica</given-names></name><name><surname>Lazaric</surname><given-names>Alessandro</given-names></name></person-group></element-citation></ref><ref id="b8"><element-citation publication-type="journal"><article-title>Deep reinforcement learning in a handful of trials using probabilistic dynamics models</article-title><source>Advances in Neural Information Processing Systems</source><year>2018</year><fpage>4754</fpage><lpage>4765</lpage><person-group person-group-type="author"><name><surname>Chua</surname><given-names>Kurtland</given-names></name><name><surname>Calandra</surname><given-names>Roberto</given-names></name><name><surname>Mcallister</surname><given-names>Rowan</given-names></name><name><surname>Levine</surname><given-names>Sergey</given-names></name></person-group></element-citation></ref><ref id="b9"><element-citation publication-type="journal"><article-title>Model-based reinforcement learning via meta-policy optimization</article-title><source>arXiv preprint arXiv:1809.05214</source><year>2018</year><person-group person-group-type="author"><name><surname>Clavera</surname><given-names>Ignasi</given-names></name><name><surname>Rothfuss</surname><given-names>Jonas</given-names></name><name><surname>Schulman</surname><given-names>John</given-names></name><name><surname>Fujita</surname><given-names>Yasuhiro</given-names></name><name><surname>Asfour</surname><given-names>Tamim</given-names></name><name><surname>Abbeel</surname><given-names>Pieter</given-names></name></person-group></element-citation></ref><ref id="b10"><element-citation publication-type="journal"><article-title>Off-policy actor-critic</article-title><source>arXiv preprint arXiv:1205.4839</source><year>2012</year><person-group person-group-type="author"><name><surname>Degris</surname><given-names>Thomas</given-names></name><name><surname>White</surname><given-names>Martha</given-names></name><name><surname>Sutton</surname><given-names>Richard S</given-names></name></person-group></element-citation></ref></ref-list></back></article>