Title:
```
Published as a conference paper at ICLR 2020 REINFORCED ACTIVE LEARNING FOR IMAGE SEGMENTATION
```
Abstract:
```
Learning-based approaches for semantic segmentation have two inherent chal- lenges. First, acquiring pixel-wise labels is expensive and time-consuming. Second, realistic segmentation datasets are highly unbalanced: some categories are much more abundant than others, biasing the performance to the most represented ones. In this paper, we are interested in focusing human labelling effort on a small subset of a larger pool of data, minimizing this effort while maximizing performance of a segmentation model on a hold-out set. We present a new active learning strategy for semantic segmentation based on deep reinforcement learning (RL). An agent learns a policy to select a subset of small informative image regions - opposed to entire images - to be labeled, from a pool of unlabeled data. The region selection decision is made based on predictions and uncertainties of the segmentation model being trained. Our method proposes a new modification of the deep Q-network (DQN) formulation for active learning, adapting it to the large-scale nature of semantic segmentation problems. We test the proof of concept in CamVid and provide results in the large-scale dataset Cityscapes. On Cityscapes, our deep RL region-based DQN approach requires roughly 30% less additional labeled data than our most competitive baseline to reach the same performance. Moreover, we find that our method asks for more labels of under-represented categories compared to the baselines, improving their performance and helping to mitigate class imbalance.
```

Figures/Tables Captions:
```
Figure 1: (Left) Input image from Cityscapes dataset (Cordts et al., 2016), with selected regions by our method to be labeled. (Right) Retrieved ground truth annotation for the selected regions. Our method focuses on small objects and under-represented classes, such as bicycles, pedestrians and poles. Best viewed in color.
Figure 2: The query network π is trained during several episodes e with MDP transitions {(st, at, rt+1, st+1)}. 1) The state st is computed as a function of segmentation network f and state set DS. 2) K unlabeled pools P k t are sampled uniformly from the unlabeled set Ut. The representation of their possible sub-actions are computed using f , labeled set Lt and unlabeled set Ut. 3) Query network π selects action at, composed of K sub-actions a k t . Each of them is chosen from its corresponding pool. 4) Selected regions are labeled and added to Lt (and removed from Ut). 5) Segmentation network f is trained with those new labeled samples. 6) Reward rt+1 is obtained from DR. This loop continues until a budget B of labeled regions is achieved.
Figure 4: Performance of several methods with increasing active learning budget, expressed as the number of 128×128 pixel regions labeled and the % of additional labeled data. All methods have been pretrained with GTAV and a small subset of their target datasets. Budget indicates additional number of regions labeled (and the percentage of unlabeled data used). The dashed line represents the 96% of the total performance achieved by the segmentation network with fully-supervised training (having access to all labels). We report the mean and standard deviation of 5 runs.
Figure 3: En- tropy of class distributions ob- tained from pix- els of selected re- gions.
Table 1: Per category IoU and mean IoU [%] on Cityscapes validation set, for a budget of 12k regions. For clarity, only the mean of 5 runs is reported. Results with standard deviations in Table C.1.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Semantic segmentation, the task of labelling an image pixel-by-pixel with the category it belongs to, is critical for a variety of applications such as autonomous driving ( Müller et al., 2018 ;  Wang & Pan, 2018 ), robot manipulation ( Schwarz et al., 2018 ), embodied question answering ( Yu et al., 2019 ) and biomedical image analysis ( Ronneberger et al., 2015 ). Convolutional neural networks ( Lecun et al., 1998 )-based methods have achieved excellent results on large-scale supervised semantic segmentation, in which we assume pixel-level annotations are available ( Farabet et al., 2013 ;  Pinheiro & Collobert, 2014 ;  Long et al., 2015 ). For such models to work, however, they need a large amount of pixel-level annotations that may require costly human labor ( Cordts et al., 2016 ;  Bearman et al., 2016 ). Current semantic segmentation datasets have pixel-wise annotations for each image. This standard approach has two important issues: (i) pixel-level labelling is extremely time consuming. For example, annotation and quality control required more than 1.5h per image (on average) on Cityscapes ( Cordts et al., 2016 ), a popular dataset used for benchmarking semantic segmentation methods. (ii) Class imbalance in the data is typically extreme. Certain categories (such as 'building' or 'sky') can appear with two orders of magnitude more frequently than others (e.g. 'pedestrian' or 'bicycle'). This can lead to undesired biases and performance properties for learned models. This is specially relevant when we want to collect annotated data with a human in the loop to create a new dataset or to add more labeled data to an existing one. We can tackle the aforementioned problems by selecting, in an efficient and effective way, which regions of the images should be labeled next. Active learning (AL) is a well-established field that studies precisely this: selecting the most informative samples to label so that a learning algorithm will perform better with less data than a non-selective approach, such as labelling the entire collection of data. Active learning methods can be roughly divided in two groups: (i) methods that combine different manually-designed AL strategies ( Roy & McCallum, 2001 ;  Osugi et al., 2005 ;  Gal et al., 2017 ;  Baram et al., 2004 ;  Chu & Lin, 2016 ;  Hsu & Lin, 2015 ;  Ebert et al., 2012 ;  Long & Hua, 2015 ) and (ii) data-driven AL approaches ( Bachman et al., 2017 ;  Fang et al., 2017 ;  Konyushkova et al., 2017 ;  Woodward & Finn, 2016 ;  Ravi & Larochelle, 2018 ; Konyushkova et al., 2018), that learn which samples are most informative to train a model using information of the model itself. Although label acquisition for semantic segmentation is more costly and time consuming than image classification, there has been considerably less work in active learning for semantic segmentation (Dutt Jain & Grauman, 2016;  Mackowiak et al., 2018 ;  Vezhnevets et al., 2012 ;  Konyushkova et al., 2015 ;  Gorriz et al., 2017 ;  Yang et al., 2017 ), and they focus on hand-crafted strategies. Current AL techniques that use reinforcement learning (Konyushkova et al., 2018;  Fang et al., 2017 ;  Woodward & Finn, 2016 ;  Pang et al., 2018 ;  Padmakumar et al., 2018 ;  Bachman et al., 2017 ) focus on labelling one sample per step until a budget of labels is met. In semantic segmentation, this would translate into labelling a single region per step. This is highly inefficient, since each step involves updating the segmentation network and computing the rewards. In this work, we propose an end-to-end method to learn an active learning strategy for semantic segmentation with reinforcement learning by directly maximizing the performance metric we care about, Intersection over Union (IoU). We aim at learning a policy from the data that finds the most informative regions on a set of unlabeled images and asks for its labels, such that a segmentation network can achieve high-quality performance with a minimum number of labeled pixels. Selecting regions, instead of entire images, allows the algorithm to focus on the most relevant parts of the images, as shown in  Figure 1 . Although class imbalance in segmentation datasets has been previously addressed in ( Badrinarayanan et al., 2017 ;  Chan et al., 2019 ;  Sudre et al., 2017 ), among others, they try to solve a problem that arises from the data collection process. We show that our proposed method can help mitigate the problem at its source, i.e. in the data annotation itself. Because our method maximizes the mean IoU per class, it indirectly learns to ask for more labels of regions with under-represented classes, compared to the baselines. Moreover, we propose and explore a batch-mode active learning approach that uses an adapted DQN to efficiently chose batches of regions for labelling at each step. To the best of our knowledge, all current approaches for active learning in semantic segmentation rely on hand-crafted active learning heuristics. However, learning a labelling policy from the data could allow the query agent to ask for labeled data as a function of the data characteristics and class imbalances, that may vary between datasets. Our main contributions can be summarized as follows: (i) we learn a RL-based acquisition function for region-based active learning for segmentation, (ii) we formulate our active learning framework with a batch-mode DQN, which labels multiple regions in parallel at each active learning iteration (a more efficient strategy for large-scale datasets that is compatible with standard mini-batch gradient descent), and (iii) we test the proof of concept Published as a conference paper at ICLR 2020 in CamVid ( Brostow et al., 2008 ) dataset and provide results in Cityscapes ( Cordts et al., 2016 ) dataset, beating a recent state-of-the-art technique known as BALD ( Gal et al., 2017 ), a widely used entropy-based selection criterion and uniform sampling baselines.

Section Title: RELATED WORK
  RELATED WORK

Section Title: Active learning
  Active learning Traditional active learning techniques focus on estimating the sample informative- ness using hand-crafted heuristics derived from sample uncertainty: employing entropy ( Shannon, 1948 ), query-by-committee ( Dagan & Engelson, 1995 ;  Shannon, 1948 ;  Freund et al., 1993 ), max- imizing the error reduction ( Roy & McCallum, 2001 ), disagreement between experts ( Dagan & Engelson, 1995 ;  Freund et al., 1993 ) or Bayesian methods that need to estimate the posterior distri- bution ( Houlsby et al., 2011a ;  Gal et al., 2017 ). Some approaches combine different techniques to improve AL performance. For instance, relying on exploration-exploitation trade-offs ( Osugi et al., 2005 ), on a bandit formulation ( Baram et al., 2004 ;  Chu & Lin, 2016 ;  Hsu & Lin, 2015 ) and on reinforcement learning ( Ebert et al., 2012 ;  Long & Hua, 2015 ). However, these methods are still limited in the sense that they combine hand-crafted strategies instead of learning new ones. More recent active learning methods rely on an acquisition function that estimates the sample informa- tiveness with a learned metric.  Konyushkova et al. (2017)  estimate the error reduction of labelling a particular sample, choosing the ones that maximize the error reduction.  Wang et al. (2017)  introduce a cost-effective approach that also uses confident predictions as pseudo ground truth labels.

Section Title: AL with reinforcement learning
  AL with reinforcement learning Recently, reinforcement learning has gained attention as a method to learn a labelling policy that directly maximizes the learning algorithm performance. For in- stance,  Liu et al. (2018) ;  Bachman et al. (2017)  leverage expert knowledge from oracle policies to learn a labelling policy, and  Pang et al. (2018) ;  Padmakumar et al. (2018)  rely on policy gradient methods to learn the acquisition function. In a different approach, some methods gather all labeled data in one big step. In  Contardo et al. (2017) , all samples are chosen in one step with a bi-directional RNN for the task of one-shot learning. In  Sener & Savarese (2018) , they propose to select a batch of representative samples that maximize the coverage of the entire unlabeled set. However, the bounded core-set loss used tends to perform worse when the number of classes grows. More similar to our approach, some prior works propose to learn the acquisition function with a Deep Q-Network (DQN) ( Mnih et al., 2013 ) formulation. These works have examined both stream-based active learning ( Fang et al., 2017 ;  Woodward & Finn, 2016 ), where unlabeled samples are provided one by one, and the decision is to label it or not, and pool-based active learning (Konyushkova et al., 2018), where all the unlabeled data is provided beforehand, and the decision is later taken on which samples to choose. The work of Konyushkova et al. (2018) is the closest to ours. Similar to them, our method also leverages the benefits of Q-learning ( Watkins & Dayan, 1992 ) to tackle pool-based AL. Contrary to them, we deal with a much more complex problem: semantic segmentation versus simple classification on UCI repository ( Dua & Graff, 2017 ). The large-scale nature of the problem requires us to use a very different definition of actions, states and rewards. Moreover, we need to adapt the DQN formulation to allow the problem to be computationally feasible.

Section Title: AL for semantic segmentation
  AL for semantic segmentation Active learning for semantic segmentation has been relatively less explored than other tasks, potentially due to its large-scale nature. For instance,  Dutt Jain & Grauman (2016)  combine metrics (defined on hand-crafted heuristics) that encourage the diversity and representativeness of labeled samples. Some rely on unsupervised superpixel-based over- segmentation ( Vezhnevets et al., 2012 ;  Konyushkova et al., 2015 ) - and highly depend on the quality of the super-pixel segmentation. Others focus on foreground-background segmentation of biomedical images ( Gorriz et al., 2017 ;  Yang et al., 2017 ), also using hand-crafted heuristics.  Settles et al. (2008) ;  Vijayanarasimhan & Grauman (2009) ;  Mackowiak et al. (2018)  focus on cost-effective approaches, proposing manually-designed acquisition functions based on the cost of labeling images or regions of images. However, this information is not always given, restricting their applicability.  Mackowiak et al. (2018)  focus on cost-effective approaches, where the cost of labeling an image is not considered equal for all images. Similar to our work, they use a region-based approach to cope with the large number of samples on a segmentation dataset. Contrary to us, their labelling strategy is based on manually defined heuristics, limiting the representability of the acquisition function. To the best of our knowledge, our work is the first to apply data-driven RL-based approach to the problem of active learning for semantic segmentation.

Section Title: METHOD
  METHOD We are interested in selecting a small number of regions 1 (cropped from images in the original dataset) from a large unlabeled set to maximize the performance of a segmentation network f , parameterized by θ. This process is done iteratively until a given budget B of labeled samples is achieved. At each iteration t, a query network π, parameterized by φ, selects K regions to be labeled by an oracle from a large unlabeled set U t . These samples are added to the labeled set L t , that is used to train the segmentation network f . The performance is measured with a standard semantic segmentation metric, Intersection-over-Union (IoU). We cast the AL problem within a Markov decision process (MDP) formulation, inspired by other work such as ( Padmakumar et al., 2018 ;  Fang et al., 2017 ;  Bachman et al., 2017 ;  Pang et al., 2018 ; Konyushkova et al., 2018). We model the query network π as a reinforcement learning agent, specifically a deep Q-network ( Mnih et al., 2013 ). This data-driven approach allows the model to learn selection strategies based solely on prior AL experience. Our formulation differs from other approaches by the task we address, the definitions of states, actions and rewards, and the reinforcement learning algorithm we use to find the optimal policy.

Section Title: ACTIVE LEARNING WITH REINFORCEMENT LEARNING FOR SEGMENTATION
  ACTIVE LEARNING WITH REINFORCEMENT LEARNING FOR SEGMENTATION In our setting, we use four different data splits. To train π, we define a subset of labeled data D T to play the active learning game for several episodes and learn a good acquisition function that maximizes performance with a budget of B regions. The query network is evaluated on a different split D V . We use a separate subset D R to obtain the reward signal by evaluating the segmentation network on it. The set D S (|D S | |D T |) is used to construct the state representation. The MDP is defined with the sequence of transitions {(s t , a t , r t+1 , s t+1 )}. For every state s t ∈ S (function of the segmentation network at timestep t), the agent can perform actions a t ∈ A to choose which samples from U t to annotate. The action a t = {a k t } K k=1 , composed of K sub-actions, is a function of the segmentation network, the labeled and the unlabeled set. Each sub-action asks for a specific region to be labeled. Then, it receives a reward r t+1 based on the improvement in mean IoU per class after training the segmentation network with the selected samples. Note that states and actions do not depend on the specific architecture of the segmentation network. We are interested in finding a policy to select samples that maximize the segmentation performance. We use deep Q-network ( Mnih et al., 2013 ) and samples from an experience buffer E to train the query network π. Each episode e elapses a total of T steps. We start by setting the segmentation network f to a set of initial weights θ 0 and with no annotated data, i.e., L 0 = ∅ and U 0 = D T . At each iteration t, the following steps are done: 1. The state s t is computed as function of f t and D S . 2. A restricted action space is built with K pools P k t with N regions, sampled uniformly from the unlabeled set U t . For each region in each pool, we compute its sub-action representation a k,n t . 3. The query agent selects K sub-actions {a k t } K k=1 with -greedy policy. Each sub-action a k t is defined as selecting one region x k (out of N ) to annotate from a pool P k t . 4. An oracle labels the regions and the sets are updated: 5. The segmentation network f t+1 is trained one iteration on the recently added regions {x k } K k=1 . 6. The agent receives the reward r t+1 as the difference of performance between f t+1 and f t on D R .  Figure 2  depicts this training algorithm. We consider the termination of each episode when the budget B of labeled regions is met, i.e., |L t | = B. Once the episode is terminated, we restart the weights of the segmentation network f to the initial weights θ 0 , set L 0 = ∅ and U 0 = D T , and restart the episode. We train the query policy π by simulating several episodes and updating its weights at each Published as a conference paper at ICLR 2020 timestep by sampling transitions {(s t , a t , r t+1 , s t+1 )} from the experience replay buffer E. More details in Section 3.2.

Section Title: State representation
  State representation We would like to use the state of the segmentation network f as the MDP state. Unfortunately, it is not straightforward to embed f into a state representation. Follow- ing  Konyushkova et al. (2017) , we represent the state space S with the help of a set-aside set D S . We use a small subset of data from the train set, making sure it contains a significant representation of all classes. We consider it to be a representative set of the dataset, and that any improvement in the segmentation performance on subset D S will translate into an improvement over the full dataset 2 . We use the predictions of the segmentation network f t on D S to create a global representation of state s t (step 1 in  Figure 2 ). We need a compact representation to avoid intensive memory usage due to the pixel-wise predictions. The samples in D S are split in patches, and compact feature vectors are computed for all of them. Then, each region is encoded by the concatenation of two sets of features: one is based on class predictions of f t and the other on its prediction uncertainty, represented as the Shannon entropy ( Shannon, 1948 ). The first set of features (i) is a (normalized) count of the number of pixels that are predicted to each category. This feature encodes the segmentation prediction on a given patch while dismissing the spatial information, less important for small patches. Moreover, we measure the uncertainty of the predictor with the entropy over the probability of predicted classes. For each region, we compute the entropy of each pixel location to obtain a spatial entropy map. To compress this representation, we apply min, average and max-poolings to the entropy map to obtain downsampled feature maps. The second set of features (ii) is thus obtained by flattening these entropy features and concatenating them. Finally, the state s t is represented by an ensemble of the feature representation of each region in D S . Figure A.1a illustrates how s t is computed from each region.

Section Title: Action representation
  Action representation In our setting, taking an action means asking for the pixel-wise annota- tion of an unlabeled region. Due to the large-scale nature of semantic segmentation, it would be prohibitively expensive to compute features for each region in the unlabeled set at each step. For this reason, instead, at each step t, we approximate the whole unlabeled set by sampling K pools of unlabeled regions P k t , each containing N (uniformly) sampled regions. For each region, we compute its sub-action representation a k,n t (step 2 in  Figure 2 ). 2 In practice, we found that the state set needs to have a similar class distribution as that of the train set. t is a concatenation of four different features: the entropy and class distribution features (as in the state representation), a measure of similarity between the region x k and the labeled set and another between the region and the unlabeled set. The intuition is that the query network could learn to build a more class-balanced labeled set while still taking representative samples from the unlabeled set. This could help mitigate the hard imbalance of the segmentation datasets and improve overall performance. For each candidate region, x in a pool P k t , we compute the KL divergence between the class distributions of the prediction map of region x (estimated as normalized counts of predicted pixels in each category) and the class distributions of each labeled and unlabeled regions (using the ground- truth annotations and network predictions, respectively). For the labeled set, we compute a KL divergence score between each of the labeled regions' class distribution and the one of region x. Summarizing all these KL divergences could be done by taking the maximum or summing them. However, to obtain more informative features, we compute a normalized histogram of KL divergence scores, resulting in a distribution of similarities. As an example, if we were to sum all the scores, having half of the labeled regions with a KL divergence of zero and the other half with a value c, would be equivalent to have all labeled regions with a KL divergence of c/2. The latter could be more interesting, since it means there are no labeled regions with the same class distribution as x. For the unlabeled set we follow the same procedure, resulting in another distribution of KL divergences. Both of them are concatenated and added to the action representation. Figure A.1b illustrates how we represent each possible action in a pool. Based on early experimentation, learning the state and action representations directly with a CNN does not provide strong enough features for the reinforcement learning framework to converge to a good solution. An ablation study on the state and action components can be found in Appendix E.1.

Section Title: BATCH MODE DQN
  BATCH MODE DQN The desired query agent should follow an optimal policy. This policy maps each state to an action that maximizes the expected sum of future rewards. We rely on a DQN ( Mnih et al., 2013 ), parameterized by φ, to find an optimal policy. We train our DQN with a labeled set D T and compute the rewards in a held-out split D R . As mentioned above, the query agent in our method selects K regions before transitioning to the next state. We assume that each region is selected independently, as in the case where K annotators label one region in parallel. In this case, the action a t is composed of K independent sub-actions {a k t } K k=1 , each with a restricted action space, avoiding the combinatorial explosion of the action space. To ease computation and avoid selecting repeated regions in the same time-step, we restrict each sub-action a k t to select a region x k in P k t defined as: a k t = argmax a k,n t ∈P k t Q(s t , a k,n t ; φ) , (1) for each k ∈ {1, ..., K} action take in timestep t. The network is trained by optimizing a loss based on temporal difference (TD) error ( Sutton, 1988 ). The loss is defined as the expectation over decomposed transitions T k = {(s t , a k t , r k t+1 , s t+1 )}, obtained from the standard transitions {(s t , a t , r t+1 , s t+1 )}, by approximating r k t+1 ≈ r t+1 : E T k ∼E (y k t − Q(s t , a k t ; φ)) 2 , (2) where E is the experience replay buffer and y k t the TD target for each sub-action. To stabilize the training, we used a target network with weights φ and the double DQN ( Van Hasselt et al., 2016 ) formulation. The action selection and evaluation is decoupled; the action is selected with the target network and is evaluated with the query network. The TD target for each sub-action is represented as: This formulation is valid under the approximation that the sub-actions are independent of each other, conditioned on the state. We observed that increasing the number of sub-actions K per step eases computation and does not hinder segmentation performance. We provide an ablation study on the effect of K in Appendix E.3.

Section Title: EXPERIMENTS
  EXPERIMENTS We start this section by describing the datasets that we use to evaluate our method, the experimental setup, and the baselines. We evaluate the algorithm in Camvid as a proof of concept and we show large-scale results on Cityscapes.

Section Title: EXPERIMENTAL SETUP
  EXPERIMENTAL SETUP Although we can apply active learning in a setting with unlabeled data with a human in the loop that labels selected regions, we test our approach in fully labeled datasets, where it is easier to mask out the labels of a part of the data and reveal them when the active learning algorithm selects them. CamVid ( Brostow et al., 2008 ). This dataset consists of street scene view images, with the reso- lution of 360×480 and 11 categories. It has 370, 104 and 234 images for train, validation and test set, respectively. We split the train set with uniform sampling in 110 labeled images (from where we get 10 images to represent the state set D S and the rest for D T ), and 260 images to build D V , where we evaluate and compare our acquisition function to the baselines. The state set is chosen to be representative of D T , by restricting the sampling of D S to have a similar class distribution to the one of D T . Each image is split into 24 regions of dimension 80×90. We use the dataset's validation set for D R . We report the final segmentation results on the test set. In our experiments, we chose K = 24 regions per step. Our model is quite robust to the number of regions selected at each time step (see Appendix E.3). Cityscapes ( Cordts et al., 2016 ). It is also composed of real street scene views, with image resolution of 2048×1024 and 19 semantic categories. The train set with fine-grained segmentation labels has 2975 images and the validation dataset of 500 images. We uniformly sampled 360 labeled images from the train set. Out of these, 10 images represent D S , 150 build D T and 200, D R , where we get our rewards. The remaining 2615 images of train set are used for D V , as if they were unlabeled. We report the results in the validation set (test set not available). Each image is split in 128 regions of dimension 128×128. We chose K = 256 regions per step.

Section Title: Implementation details
  Implementation details The split D R is used to get the rewards for the DQN and also for hyper- parameter selection, that are chosen according to the best setup for both baselines and our method. We report the average and standard deviation of the 5 different runs (5 random seeds). As data augmentation, we use random horizontal flips and random crops of 224 × 224. For more details, please refer to Appendix B on supplementary material.

Section Title: Evaluation
  Evaluation The query network π is trained on D T with a small, fixed budget (0.5k regions for Camvid and 4k regions for Cityscapes) to encourage picking regions that will boost the performance in an heavily scarce data regime. The learned acquisition function, as well as the baselines, is evaluated on D V , where we ask for labels until the budget is met, for different budgets. Note that the baselines do not have any learnable component. Once the budget is reached, we train the segmentation network f with L T until convergence (with early stopping in D R ). For a fair comparison, all methods' segmentation network has been pre-trained (initial f weights θ 0 ) on GTA dataset ( Richter et al., 2016 ), a synthetic dataset where high amounts of labeled data can be obtained without human effort, and D T (where we had labels to train the DQN). We evaluate the final segmentation performance (measured in mean IoU) on the test set of CamVid and on the validation set of Cityscapes.

Section Title: RESULTS
  RESULTS

Section Title: Results in CamVid
  Results in CamVid We compare our results against three distinct baselines: (i) U is the uniform random sampling of the regions to label at each step out of all possible regions in the pool, (ii) H is an uncertainty sampling method that selects the regions with maximum cumulative pixel-wise Shannon entropy, (iii) B picks regions with maximum cumulative pixel-wise BALD ( Houlsby et al., 2011b ;  Gal et al., 2017 ) metric. We use 20 iterations of MC-Dropout ( Gal & Ghahramani, 2016 ) (instead of 100, as in ( Gal et al., 2017 )) for computational reasons. In preliminary experiments, we did not observe any improvement using over 20 iterations. In Camvid, we use a pool size of 10 for our method, H, B and 50 for U. In Cityscapes, we have access to more data so we use pool sizes of 500, 200, 200 and 100 respectively for U, H, B and our method. Pool sizes were selected according to the best validation mean IoU. Figure 4a shows results on CamVid for different budget sizes. Our method out- performs the baselines for every fixed budget, except for 1.5k regions, where we achieve similar performance as H. We argue that the dataset has a small number of images and selecting 1.5k regions already reaches past 98% of maximum performance, where differences be- tween our method and H are negligible. Surprisingly, B is worse than U, specially for small budgets, where training with the newly acquired labels does not provide any additional information. It overfits quickly to the training, getting a worst result that with the initial weights. In general, all results have a high variance due to the low regime of data we are working in. In Appendix E.2 we show the advantages of labeling small regions instead of full images. Results in Cityscapes. Figure 4b shows results on Cityscapes for different budgets. Here, we also observe that our method outperforms the baselines for all budgets points. Labelling 20k regions, corresponding to only 6% of the total pixels (additional to the labeled data in D T ), we obtain a performance of 64.5% mean IoU. This is 96% of the performance of the segmentation network if it had access to all labeled pixels. To reach the same performance, H requires an additional 6k labeled regions (around 30% more pixels, equivalent to an extra 45 images). In this larger dataset, B performs better than random, showing that for the task of segmentation, B might start to show its benefits only for considerably large budgets.  Table 1  shows the per-class IoU for the evaluated methods (with a fixed budget). Our method works specially well for under-represented classes, such as Person, Motorcycle or Bicycle, among others. Indeed, our method selects more pixels belonging to under-represented classes than baselines. Note that this is a side effect of directly optimizing for the mean IoU and defining class-aware representations for states and actions.  Figure 3  shows the entropy of the distribution of selected pixels of the final labeled set (for a budget of 12k regions) for Cityscapes. The higher the entropy means closer to uniform distribution over classes, and our method Published as a conference paper at ICLR 2020 has the highest entropy. Appendix C shows the distribution from which the entropy is computed and Appendix D presents some qualitative results, showing what each method decides to label for some images.

Section Title: CONCLUSION
  CONCLUSION We propose a data-driven, region-based method for active learning for semantic segmentation, based on reinforcement learning. The goal is to alleviate the costly process of obtaining pixel-wise labels with a human in the loop. We propose a new modification of DQN formulation to learn the acquisition function, adapted to the large-scale nature of semantic segmentation. This provides a computationally efficient solution that uses less labeled data than competitive baselines, while achieving the same performance. Moreover, by directly optimizing for the per-class mean IoU and defining class-aware representations for states and actions, our method asks for more labels of under-represented classes compared to baselines. This improves the performance and helps to mitigate class imbalance. As future work, we highlight the possibility of designing a better region definition, that could help improve the overall results, and adding domain adaptation for the learnt policy, to transfer it between datasets.
  We chose non-overlapping squares as regions (similar to ( Mackowiak et al., 2018 )). Other choices of regions could also be valid, but we consider region design choice selection to be out of the scope of this work.

```
