Title:
```
Published as a conference paper at ICLR 2020
```
Abstract:
```
This paper introduces Meta-Q-Learning (MQL), a new off-policy algorithm for meta-Reinforcement Learning (meta-RL). MQL builds upon three simple ideas. First, we show that Q-learning is competitive with state-of-the-art meta-RL algo- rithms if given access to a context variable that is a representation of the past trajectory. Second, a multi-task objective to maximize the average reward across the training tasks is an effective method to meta-train RL policies. Third, past data from the meta-training replay buffer can be recycled to adapt the policy on a new task using off-policy updates. MQL draws upon ideas in propensity estimation to do so and thereby amplifies the amount of available data for adaptation. Experi- ments on standard continuous-control benchmarks suggest that MQL compares favorably with the state of the art in meta-RL.
```

Figures/Tables Captions:
```
Figure 1: How well does meta-RL work? Aver- age returns on validation tasks compared for two prototypical meta-RL algorithms, MAML (Finn et al., 2017) and PEARL (Rakelly et al., 2019), with those of a vanilla Q-learning algorithm named TD3 (Fujimoto et al., 2018b) that was modified to incorporate a context variable that is a represen- tation of the trajectory from a task (TD3-context). Even without any meta-training and adaptation on a new task, TD3-context is competitive with these sophisticated algorithms.
Figure 2: Average undiscounted return of TD3 and TD3-context compared with PEARL for validation tasks from four meta-RL environments. The agent fails to learn if the policy is conditioned only on the state. In contrast, everything else remaining same, if TD3 is provided access to context, the rewards are much higher. In spite of not adaptating on the validation tasks, TD3- context is comparable to PEARL.
Figure 3: Comparison of the average undiscounted return of MQL (orange) against existing meta-RL al- gorithms on continuous-control environments. We compare against four existing algorithms, namely MAML (green), RL2 (red), PROMP (purple) and PEARL (blue). In all environments except Walker-2D-Params and Ant-Goal-2D, MQL is better or comparable to existing algorithms in terms of both sample complexity and final returns.
Figure 4: Ablation studies to examine various components of MQL.
Figure 5: Evolution of λ and β(z) during meta-training.
```

Main Content:
```
  Reinforcement Learning (RL) algorithms have demonstrated good performance on simulated data. There are however two main challenges in translat- ing this performance to real robots: (i) robots are complex and fragile which precludes extensive data collection, and (ii) a real robot may face an environ- ment that is different than the simulated environment it was trained in. This has fueled research into Meta- Reinforcement Learning (meta-RL) which develops algorithms that "meta-train" on a large number of dif- ferent environments, e.g., simulated ones, and aim to adapt to a new environment with few data. How well does meta-RL work today?  Fig. 1  shows the performance of two prototypical meta-RL algo- rithms on four standard continuous-control bench- marks. 1 We compared them to the following simple baseline: an off-policy RL algorithm (TD3 by  Fuji- moto et al. (2018b) ) and which was trained to max- imize the average reward over all training tasks and modified to use a "context variable" that represents the trajectory. All algorithms in this figure use the same evaluation protocol. It is surprising that this simple non-meta-learning-based method is competitive with state-of-the-art meta-RL algorithms. This is the first contribution of our paper: we demonstrate that it is not necessary to meta-train policies to do well on existing benchmarks. Our second contribution is an off-policy meta-RL algorithm named Meta-Q-Learning (MQL) that builds upon the above result. MQL uses a simple meta-training procedure: it maximizes the average Published as a conference paper at ICLR 2020 rewards across all meta-training tasks using off-policy updates to obtain θ meta = arg max θ 1 n n k=1 E τ ∼D k k (θ) (1) where k (θ) is the objective evaluated on the transition τ obtained from the task D k (θ), e.g., 1-step temporal-difference (TD) error would set k (θ) = TD 2 (θ; τ ). This objective, which we call the multi-task objective, is the simplest form of meta-training. For adapting the policy to a new task, MQL samples transitions from the meta-training replay buffer that are similar to those from the new task. This amplifies the amount of data available for adaptation but it is difficult to do because of the large potential bias. We use techniques from the propensity estimation literature for performing this adaptation and the off-policy updates of MQL are crucial to doing so. The adaptation phase of MQL solves arg max θ E τ ∼D new new (θ) + E τ ∼Dmeta β(τ ; D new , D meta ) new (θ) − 1 − ESS θ − θ meta 2 2 (2) where D meta is the meta-training replay buffer, the propensity score β(τ ; D new , D meta ) is the odds of a transition τ belonging to D new versus D meta , and ESS is the Effective Sample Size between D new and D meta that is a measure of the similarly of the new task with the meta-training tasks. The first term computes off-policy updates on the new task, the second term performs β(·)-weighted off-policy updates on old data, while the third term is an automatically adapting proximal term that prevents degradation of the policy during adaptation. We perform extensive experiments in Sec. 4.2 including ablation studies using standard meta-RL benchmarks that demonstrate that MQL policies obtain higher average returns on new tasks even if they are meta-trained for fewer time-steps than state-of-the-art algorithms. where x t ∈ X ⊂ R d are the states and u t ∈ U ⊂ R p are the actions. The dynamics f k is parameterized by k ∈ {1, . . . , n} where each k corresponds to a different task. The domain of all these tasks, X for the states and U for the actions, is the same. The distribution p k 0 denotes the initial state distribution and ξ t is the noise in the dynamics. Given a deterministic policy u θ (x t ), the action- value function for γ-discounted future rewards r k t := r k (x t , u θ (x t )) over an infinite time-horizon is Note that we have assumed that different tasks have the same state and action space and may only differ in their dynamics f k and reward function r k . Given one task k ∈ {1, . . . , n}, the standard Reinforcement Learning (RL) formalism solves for Let us denote the dataset of all states, actions and rewards pertaining to a task k and policy u θ (x) by we will often refer to D k as the "task" itself. The Deterministic Policy Gradient (DPG) algorithm ( Sil- ver et al., 2014 ) for solving (5) learns a ϕ-parameterized approximation q ϕ to the optimal value func- Published as a conference paper at ICLR 2020 tion q k by minimizing the Bellman error and the optimal policy u θ that maximizes this approximation by solving the coupled optimization problem The 1-step temporal difference error (TD error) is defined as TD 2 (θ) = q ϕ (x, u) − r k − γ q ϕ (x , u θ (x )) 2 (7) where we keep the dependence of TD(·) on ϕ implicit. DPG, or its deep network-based variant DDPG ( Lillicrap et al., 2015 ), is an off-policy algorithm. This means that the expectations in (6) are computed using data that need not be generated by the policy being optimized (u θ ), this data can come from some other policy. In the sequel, we will focus on the parameters θ parameterizing the policy. The parameters ϕ of the value function are always updated to minimize the TD-error and are omitted for clarity.

Section Title: . 1 M E TA - R E I N F O R C E M E N T L E A R N I N G ( M E TA - R L )
  . 1 M E TA - R E I N F O R C E M E N T L E A R N I N G ( M E TA - R L ) Meta-RL is a technique to learn an inductive bias that accelerates the learning of a new task by training on a large of number of training tasks. Formally, meta-training on tasks from the meta-training set D meta = D k k=1,...,n involves learning a policy θ meta = arg max θ 1 n n k=1 k meta (θ) (8) where k meta (θ) is a meta-training loss that depends on the particular method. Gradient-based meta-RL, let us take MAML by  Finn et al. (2017)  as a concrete example, sets k meta (θ) = k (θ + α∇ θ k (θ)) (9) for a step-size α > 0; k (θ) is the objective of non-meta-RL (5). In this case k meta is the objective obtained on the task D k after one (or in general, more) updates of the policy on the task. The idea behind this is that even if the policy θ meta does not perform well on all tasks in D meta it may be updated quickly on a new task D new to obtain a well-performing policy. This can either be done using the same procedure as that of meta-training time, i.e., by maximizing new meta (θ) with the policy θ meta as the initialization, or by some other adaptation procedure. The meta-training method and the adaptation method in meta-RL, and meta-learning in general, can be different from each other.

Section Title: . 2 L O G I S T I C R E G R E S S I O N F O R E S T I M AT I N G T H E P R O P E N S I T Y S C O R E
  . 2 L O G I S T I C R E G R E S S I O N F O R E S T I M AT I N G T H E P R O P E N S I T Y S C O R E Consider standard supervised learning: given two distributions q(x) (say, train) and p(x) (say, test), we would like to estimate how a model's predictionsŷ(x) change across them. This is formally done using importance sampling: E x∼p(x) E y|x (y,ŷ(x)) = E x∼q(x) E y|x β(x) (y,ŷ(x)) ; (10) where y|x are the true labels of data, the predictions of the model areŷ(x) and (y,ŷ(x)) is the loss for each datum (x, y). The importance ratio β(x) = dp dq (x), also known as the propensity score, is the Radon-Nikodym derivative ( Resnick, 2013 ) of the two data densities and measures the odds of a sample x coming from the distribution p versus the distribution q. In practice, we do not know the densities q(x) and p(x) and therefore need to estimate β(x) using some finite data X q = {x 1 , . . . , x m } drawn from q and X p = {x 1 , . . . , x m } drawn from p. As  Agarwal et al. (2011)  show, this is easy to do using logistic regression. Set z k = 1 to be the labels for the data in X q and z k = −1 to be the labels of the data in X p for k ≤ m and fit a logistic classifier on the combined 2m Published as a conference paper at ICLR 2020 samples by solving Normalized Effective Sample Size ( ESS): A related quantity to β(x) is the normalized Effective Sample Size ( ESS) which we define as the relative number of samples from the target distribution p(x) required to obtain an estimator with performance (say, variance) equal to that of the importance sampling estimator (10). It is not possible to compute the ESS without knowing both densities q(x) and p(x) but there are many heuristics for estimating it. A popular one in the Monte Carlo literature ( Kong, 1992 ;  Smith, 2013 ;  Elvira et al., 2018 ) is where X = {x 1 , . . . , x m } is some finite batch of data. Observe that if two distributions q and p are close then the ESS is close to one; if they are far apart the ESS is close to zero. This section describes the MQL algorithm. We begin by describing the meta-training procedure of MQL including a discussion of multi-task training in Sec. 3.1. The adaptation procedure is described in Sec. 3.2.

Section Title: . 1 M E TA - T R A I N I N G
  . 1 M E TA - T R A I N I N G MQL performs meta-training using the multi-task objective. Note that if one sets k meta (θ) k (θ) = E x∼p k 0 q k (x, u θ (x)) (14) in (8) then the parameters θ meta are such that they maximize the average returns over all tasks from the meta-training set. We use an off-policy algorithm named TD3 ( Fujimoto et al., 2018b ) as the building block and solve for θ meta = arg min θ 1 n n k=1 E τ ∼D k TD 2 (θ) ; (15) where TD(·) is defined in (7). As is standard in TD3, we use two action-value functions parameterized by ϕ 1 and ϕ 2 and take their minimum to compute the target in (7). This trick known as "double- Q-learning" reduces the over-estimation bias. Let us emphasize that (14) is a special case of the procedure outlined in (8). The following remark explains why MQL uses the multi-task objective as opposed to the meta-training objective used, for instance, in existing gradient-based meta-RL algorithms. Remark 1. Let us compare the critical points of the m-step MAML objective (9) to those of the multi-task objective which uses (14). As is done by the authors in  Nichol et al. (2018) , we can perform a Taylor series expansion around the parameters θ to obtain Further, note that ∇ k meta in (16) is also the gradient of the loss Published as a conference paper at ICLR 2020 up to first order. This lends a new interpretation that MAML is attracted towards regions in the loss landscape that under-fit on individual tasks: parameters with large ∇ k 2 will be far from the local maxima of k (θ). The parameters α and m control this under-fitting. Larger the number of gradient steps, larger the under-fitting effect. This remark suggests that the adaptation speed of gradient-based meta-learning comes at the cost of under-fitting on the tasks.

Section Title: . 1 . 1 D E S I G N I N G C O N T E X T
  . 1 . 1 D E S I G N I N G C O N T E X T As discussed in Sec. 1 and 4.4, the identity of the task in meta-RL can be thought of as the hidden variable of an underlying partially-observable MDP. The optimal policy on the entire trajectory of the states, actions and the rewards. We therefore design a recurrent context variable z t that depends on {(x i , u i , r i )} i≤t . We set z t to the hidden state at time t of a Gated Recurrent Unit (GRU by  Cho et al. (2014) ) model. All the policies u θ (x) and value functions q ϕ (x, u) in MQL are conditioned on the context and implemented as u θ (x, z) and q ϕ (x, u, z). Any other recurrent model can be used to design the context; we used a GRU because it offers a good trade-off between a rich representation and computational complexity. Remark 2 (MQL uses a deterministic context that is not permutation invariant). We have aimed for simplicity while designing the context. The context in MQL is built using an off-the-shelf model like GRU and is not permutation invariant. Indeed, the direction of time affords crucial in- formation about the dynamics of a task to the agent, e.g., a Half-Cheetah running forward versus backward has arguably the same state trajectory but in a different order. Further, the context in MQL is a deterministic function of the trajectory. Both these aspects are different than the context used by  Rakelly et al. (2019)  who design an inference network and sample a probabilistic context condi- tioned on a moving window. RL algorithms are quite complex and challenging to reproduce. Current meta-RL techniques which build upon them further exacerbate this complexity. Our demonstration that a simple context variable is enough is an important contribution.

Section Title: . 2 A D A P TAT I O N T O A N E W TA S K
  . 2 A D A P TAT I O N T O A N E W TA S K We next discuss the adaptation procedure which adapts the meta-trained policy θ meta to a new task D new with few data. MQL optimizes the adaptation objective introduced in (2) into two steps. 1. Vanilla off-policy adaptation: The first step is to update the policy using the new data as arg max The quadratic penalty θ − θ meta 2 keeps the parameters close to θ meta . This is crucial to reducing the variance of the model that is adapted using few data from the new task ( Reddi et al., 2015 ). Off-policy learning is critical in this step because of its sample efficiency. We initialize θ to θ meta while solving (18).

Section Title: Importance-ratio corrected off-policy updates
  Importance-ratio corrected off-policy updates The second step of MQL exploits the meta- training replay buffer. Meta-training tasks D meta are disjoint from D new but because they are expected to come from the same task distribution, transitions collected during meta-training can potentially be exploited to adapt the policy. This is difficult to do on two counts. First, the meta-training transitions do not come from D new . Second, even for transitions from the same task, it is non-trivial to update the policy because of extrapolation error ( Fujimoto et al., 2018a ): the value function has high error on states it has not seen before. Our use of the propensity score to reweigh transitions is a simpler version of the conditional generative model used by  Fujimoto et al. (2018a)  in this context. MQL fits a logistic classifier on a mini-batch of transitions from the meta-training replay buffer and the transitions collected from the new task in step 1. The context variable z t is the feature for this classifier. The logistic classifier estimates the importance ratio β(τ ; D new , D meta ) and can be used to reweigh data from the meta-training replay buffer for taking updates as We have again included a quadratic penalty θ − θ meta 2 that keeps the new parameters close to θ meta . Estimating the importance ratio involves solving a convex optimization problem on few samples (typically, 200 from the new task and 200-400 from the meta-training tasks). This classifier allows MQL to exploit the large amount of past data. In practice, we perform as many as 100× more weight updates using (19) than (18). MQL requires having access to the meta-training replay buffer during adaptation. This is not a debilitating requirement and there are a number of clustering techniques that can pick important transitions from the replay-buffer if a robotic agent is limited by available hard-disk space. The meta-training replay buffer is at most 3 GB for the experiments in Sec. 4.

Section Title: E X P E R I M E N T S
  E X P E R I M E N T S This section presents the experimental results of MQL. We first discuss the setup and provide details the benchmark in Sec. 4.1. This is followed by empirical results and ablation experiments in Sec. 4.2.

Section Title: Tasks and algorithms
  Tasks and algorithms We use the Mu- JoCo ( Todorov et al., 2012 ) simulator with OpenAI Gym ( Brockman et al., 2016 ) on continuous-control meta-RL benchmark tasks. These tasks have different rewards, randomized system parameters (Walker-2D-Params) and have been used in previous papers such as  Finn et al. (2017) ;  Rothfuss et al. (2018) ;  Rakelly et al. (2019) . We compare against standard base- line algorithms, namely MAML (TRPO ( Schul- man et al., 2015 ) variant) ( Finn et al., 2017 ), RL2 ( Duan et al., 2016 ), ProMP ( Rothfuss et al., 2018 ) and PEARL ( Rakelly et al., 2019 ). We ob- tained the training curves and hyper-parameters for all the three algorithms from the published code by  Rakelly et al. (2019) . We will compare the above algorithms against: (i) vanilla TD3 ( Fujimoto et al., 2018a ) without any adaptation on new tasks, (ii) TD3-context: TD3 with GRU-based context Sec. 3.1.1 with- out any adaptation, and (iii) MQL: TD3 with context and adaptation on new task using the procedure in Sec. 3.2. All the three variants use the multi-task objective for meta-training (15). We use Adam ( Kingma & Ba, 2014 ) for opti- mizing all the loss functions in this paper.

Section Title: Evaluation
  Evaluation Current meta-RL benchmarks lack a systematic evaluation procedure. 2 For each envi- ronment,  Rakelly et al. (2019)  constructed a fixed set of meta-training tasks (D meta ) and a validation set of tasks D new that are disjoint from the meta-training set. To enable direct comparison with pub- lished empirical results, we closely followed the evaluation code of  Rakelly et al. (2019)  to create these tasks. We also use the exact same evaluation protocol as that of these authors, e.g., 200 time- steps of data from the new task, or the number of evaluation episodes. We report the undiscounted return on the validation tasks with statistics computed across 5 random seeds. Our first result, in  Fig. 2 , is to show that vanilla off-policy learning with context, without any adap- tation is competitive with state of the art meta-RL algorithms. We used a standard implementation of TD3 and train on the meta-training tasks using the multi-task objective (15). Hyper-parameters for these tasks are provided in Appendix D. This result is surprising and had gone unnoticed in the current literature. Policies that have access to the context can easily generalize to the validation tasks and achieve performance that is comparable to more sophisticated meta-RL algorithms. We next evaluate MQL against existing meta-RL benchmarks on all environments. The results are shown in  Fig. 3 . We see that for all environments except Walker-2D-Params and Ant-Goal-2D, MQL obtains comparable or better returns on the validation tasks. In most cases, in particular for the challenging Humanoid-Direc-2D environment, MQL converges faster than existing algorithms. MAML and ProMP require about 100M time-steps to converge to returns that are significantly worse 2 For instance, training and validation tasks are not explicitly disjoint in  Finn et al. (2017) ;  Rothfuss et al. (2018)  and these algorithms may benefit during adaptation from having seen the same task before. The OpenAI Gym environments used in  Finn et al. (2017) ;  Rothfuss et al. (2018) ;  Rakelly et al. (2019)  provide different rewards for the same task. The evaluation protocol in existing papers, e.g., length of episode for a new task, amount of data available for adaptation from the new task, is not consistent. This makes reproducing experiments and comparing numerical results extremely difficult. Published as a conference paper at ICLR 2020 than the returns of off-policy algorithms like MQL and PEARL. Compare the training curve for TD3-context for the Ant-Goal-2D environment in  Fig. 2  with that of the same environment in  Fig. 3 : the former shows a prominent dip in performance as meta-training progresses; this dip is absent in  Fig. 3  and can be attributed to the adaptation phase of MQL.

Section Title: . 3 A B L AT I O N E X P E R I M E N T S
  . 3 A B L AT I O N E X P E R I M E N T S We conduct a series of ablation studies to analyze the different components of the MQL algorithm. We use two environments for this purpose, namely Half-Cheetah-Fwd-Back and Ant-Fwd-Back. Fig. 4a shows that the adaptation in MQL in (18) and (19) improves performance. Also observe that MQL has a smaller standard deviation in the returns as compared to TD3-context which does not perform any adaptation; this can be seen as the adaptation phase making up for the lost performance of the meta-trained policy on a difficult task. Next, we evaluate the importance of the additional data from the replay buffer in MQL. Fig. 4b compares the performance of MQL with and without updates in (19). We see that the old data, even if it comes from different tasks, is useful to improve the performance on top of (18). Fig. 4c shows the effectiveness of setting λ = 1 − ESS as compared to a fixed value of λ = 0.5. We see that modulating the quadratic penalty with ESS helps, the effect is minor for Sec. 4.3. The ideal value of λ depends on a given task and using 1 − ESS can help to adjust to different tasks without the need to do hyper-parameter search per task. Finally,  Fig. 5  shows the evolution of λ and β(z) during meta-training. The coefficient λ is about 0.55 and β(z) is 0.8 for a large fraction of the time. The latter indicates that propensity score estimation is successful in sampling transitions from the meta-training replay buffer that are similar to the validation tasks. The value of λ remains relatively unchanged during training. This value indicates the fraction of transitions in the old data that are similar to those from the new tasks; since there are two distinct tasks in Ant-Fwd-Back, the value λ = 0.55 is appropriate.

Section Title: . 4 R E L AT E D W O R K
  . 4 R E L AT E D W O R K Learning to learn: The idea of building an inductive bias for learning a new task by training on a large number of related tasks was established in a series of works ( Utgoff, 1986 ;  Schmidhuber, 1987 ; Baxter, 1995;  Thrun, 1996 ;  Thrun & Pratt, 2012 ). These papers propose building a base learner that fits on each task and a meta-learner that learns properties of the base learners to output a new base learner for a new task. The recent literature instantiates this idea in two forms: (i) the meta-learner directly predicts the base-learner ( Wang et al., 2016 ;  Snell et al., 2017 ) and (ii) the meta-learner learns the updates of the base-learner ( Bengio et al., 1992 ;  Hochreiter et al., 2001 ;  Finn et al., 2017 ). Meta-training versus multi-task training: Meta- training aims to train a policy that can be adapted efficiently on a new task. Conceptually, the improved efficiency of a meta-learner comes from two things: (i) building a better inductive bias to initialize the learning ( Schmidhuber et al., 1997 ; Baxter, 1995;  2000 ;  Mitchell, 1980 ), or (ii) learning a better learning pro- cedure ( Bengio et al., 1997 ;  Lee et al., 2019 ). The two notions of meta-learning above are complementary to each other and in fact, most recent literature using deep neural networks, e.g., MAML ( Finn et al., 2017 ) and Prototypical Networks ( Snell et al., 2017 ) confirms to the first notion of building a better inductive bias. The multi-task training objective in MQL is the simplest possible instantiation of this idea: it maximizes the aver- age reward on all tasks and learns a better prior without explicitly training for improving adaptation. This aspect of MQL coincides with a recent trend in meta-learning for image classification where it has been observed that modifications to episodic meta-training ( Snell et al., 2017 ;  Gidaris & Ko- modakis, 2018 ;  Chen et al., 2018 ), or even foregoing meta-training completely ( Dhillon et al., 2019 ) performs better. We speculate two reasons for this phenomenon: (i) meta-training methods are com- plex to implement and tune, and (ii) powerful function classes such as deep neural networks may have leftover capacity to adapt to a new task even if they are not explicitly trained for adaptation.

Section Title: Context-based approaches
  Context-based approaches Both forms of meta-learning above have been employed relatively successfully for image classification ( Snell et al., 2017 ;  Ravi & Larochelle, 2016 ;  Finn et al., 2017 ). It has however been difficult to replicate that empirical performance in RL: sensitivity to hyper- parameters ( Henderson et al., 2018 ) precludes directly predicting the base-learner while long-range temporal dependencies make it difficult to learn the updates of the base learner ( Nichol et al., 2018 ). Recent methods for meta-RL instead leverage context and learn a policy that depends on just on the current state x t but on the previous history. This may be done in a recurrent fashion ( Heess et al., 2015 ;  Hausknecht & Stone, 2015 ) or by learning a latent representation of the task ( Rakelly et al., 2019 ). Context is a powerful construct: as  Fig. 1  shows, even a simple vanilla RL algorithm (TD3) when combined with context performs comparably to state-of-the-art meta-RL algorithms. However, context is a meta-training technique, it does not suggest a way to adapt a policy to a new task. For instance,  Rakelly et al. (2019)  do not update parameters of the policy on a new task. They rely on the latent representation of the context variable generalizing to new tasks. This is difficult if the new task is different from the training tasks; we discuss this further in Sec. 3.1.1.

Section Title: Policy-gradient-based algorithms versus off-policy methods
  Policy-gradient-based algorithms versus off-policy methods Policy-gradient-based methods have high sample complexity ( Ilyas et al., 2018 ). This is particularly limiting for meta-RL ( Finn et al., 2017 ;  Rothfuss et al., 2018 ;  Houthooft et al., 2018 ) where one (i) trains on a large number of tasks and, (ii) aims to adapt to a new task with few data. Off-policy methods offer substantial gains in sample complexity. This motivates our use of off-policy updates for both meta-training and adaptation. Off-policy updates allow using past data from other policies. MQL exploits this substan- tially, it takes up to 100× more updates using old data than new data during adaptation. Off-policy algorithms are typically very sensitive to hyper-parameters ( Fujimoto et al., 2018a ) but we show that MQL is robust to such sensitivity because it adapts automatically to the distribution shift using the Effective Sample Size (ESS). Propensity score estimation has been extensively studied in both statistics ( Robert & Casella, 2013 ;  Quionero-Candela et al., 2009 ) and RL ( Dudík et al., 2011 ;  Jiang & Li, 2015 ;  Kang et al., 2007 ;  Bang & Robins, 2005 ). It is typically used to reweigh data from the proposal distribution to compute estimators on the target distribution. MQL uses propensity scores in a novel way: we fit a propensity score estimator on a subset of the meta-training replay buffer and use this model to sample transitions from the replay buffer that are similar to the new task. The off-policy updates in MQL are essential to exploiting this data. The coefficient of the proximal term in the adaptation-phase objective (18-19) using the effective sample size (ESS) is inspired from the recent work of  Fakoor et al. (2019) . The algorithm proposed in this paper, namely MQL, builds upon on three simple ideas. First, Q- learning with context is sufficient to be competitive on current meta-RL benchmarks. Second, maxi- mizing the average reward of training tasks is an effective meta-learning technique. The meta-training phase of MQL is significantly simpler than that of existing algorithms and yet it achieves comparable performance to the state of the art. This suggests that we need to re-think meta-learning in the context of rich function approximators such as deep networks. Third, if one is to adapt to new tasks with few data, it is essential to exploit every available avenue. MQL recycles data from the meta-training replay buffer using propensity estimation techniques. This data is essentially free and is completely neglected by other algorithms. This idea can potentially be used in problems outside RL such as few-shot and zero-shot image classification. Finally, this paper sheds light on the nature of benchmark environments in meta-RL. The fact that even vanilla Q-learning with a context variable-without meta-training and without any adaptation- is competitive with state of the art algorithms indicates that (i) training and validation tasks in the current meta-RL benchmarks are quite similar to each other and (ii) current benchmarks may be insufficient to evaluate meta-RL algorithms. Both of these are a call to action and point to the need to invest resources towards creating better benchmark problems for meta-RL that drive the innovation of new algorithms.

```
