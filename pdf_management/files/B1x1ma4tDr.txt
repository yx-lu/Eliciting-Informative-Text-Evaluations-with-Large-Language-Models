Title:
```
Published as a conference paper at ICLR 2020 DDSP: DIFFERENTIABLE DIGITAL SIGNAL PROCESSING
```
Abstract:
```
Most generative models of audio directly generate samples in one of two domains: time or frequency. While sufficient to express any signal, these representations are inefficient, as they do not utilize existing knowledge of how sound is generated and perceived. A third approach (vocoders/synthesizers) successfully incorpo- rates strong domain knowledge of signal processing and perception, but has been less actively researched due to limited expressivity and difficulty integrating with modern auto-differentiation-based machine learning methods. In this paper, we introduce the Differentiable Digital Signal Processing (DDSP) library, which en- ables direct integration of classic signal processing elements with deep learning methods. Focusing on audio synthesis, we achieve high-fidelity generation with- out the need for large autoregressive models or adversarial losses, demonstrating that DDSP enables utilizing strong inductive biases without losing the expressive power of neural networks. Further, we show that combining interpretable modules permits manipulation of each separate model component, with applications such as independent control of pitch and loudness, realistic extrapolation to pitches not seen during training, blind dereverberation of room acoustics, transfer of extracted room acoustics to new environments, and transformation of timbre between dis- parate sources. In short, DDSP enables an interpretable and modular approach to generative modeling, without sacrificing the benefits of deep learning. The library is publicly available 1 and we welcome further contributions from the community and domain experts. 1 Online Resources: Code: https://github.com/magenta/ddsp Audio Examples: https://goo.gl/magenta/ddsp-examples Colab Demo: https://goo.gl/magenta/ddsp-demo
```

Figures/Tables Captions:
```
Figure 1: Challenges of neural audio synthesis. Full description provided in Section 1.1.
Figure 2: Autoencoder architecture. Red components are part of the neural network architecture, green components are the latent representation, and yellow components are deterministic synthesiz- ers and effects. Components with dashed borders are not used in all of our experiments. Namely, z is not used in the model trained on solo violin, and reverb is not used in the models trained on NSynth. See the appendix for more detailed diagrams of the neural network components.
Figure 3: Separate interpolations over loudness, pitch, and timbre. The conditioning features (solid lines) are extracted from two notes and linearly mixed (dark to light coloring). The features of the resynthsized audio (dashed lines) closely follow the conditioning. On the right, the latent vectors, z(t), are interpolated, and the spectral centroid of resulting audio (thin solid lines) smoothly varies between the original samples (dark solid lines).
Figure 4: Timbre transfer from singing voice to violin. F0 and loudness features are extracted from the voice and resynthesized with a DDSP autoencoder trained on solo violin.
Table 1: Resynthesis accuracies. Comparison of DDSP models to SOTA WaveRNN model provided the same conditioning information. The supervised DDSP Autoencoder and WaveRNN models use the fundamental frequency from a pretrained CREPE model, while the unsupervised DDSP autoencoder learns to infer the frequency from the audio during training.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Neural networks are universal function approximators in the asymptotic limit ( Hornik et al., 1989 ), but their practical success is largely due to the use of strong structural priors such as convolution ( Le- Cun et al., 1989 ), recurrence ( Sutskever et al., 2014 ;  Williams & Zipser, 1990 ;  Werbos, 1990 ), and self-attention ( Vaswani et al., 2017 ). These architectural constraints promote generalization and data efficiency to the extent that they align with the data domain. From this perspective, end-to-end learning relies on structural priors to scale, but the practitioner's toolbox is limited to functions that can be expressed differentiably. Here, we increase the size of that toolbox by introducing the Differ- entiable Digital Signal Processing (DDSP) library, which integrates interpretable signal processing elements into modern automatic differentiation software (TensorFlow). While this approach has broad applicability, we highlight its potential in this paper through exploring the example of audio synthesis. Objects have a natural tendency to periodically vibrate. Small shape displacements are usually restored with elastic forces that conserve energy (similar to a canonical mass on a spring), leading to harmonic oscillation between kinetic and potential energy ( Smith, 2010 ). Accordingly, human hearing has evolved to be highly sensitive to phase-coherent oscillation, decomposing audio into spectrotemporal responses through the resonant properties of the basilar membrane and tonotopic Published as a conference paper at ICLR 2020 mappings into the auditory cortex ( Moerel et al., 2012 ;  Chi et al., 2005 ;  Theunissen & Elie, 2014 ). However, neural synthesis models often do not exploit this periodic structure for generation and perception.

Section Title: CHALLENGES OF NEURAL AUDIO SYNTHESIS
  CHALLENGES OF NEURAL AUDIO SYNTHESIS As shown in  Figure 1 , most neural synthesis models generate waveforms directly in the time domain, or from their corresponding Fourier coefficients in the frequency domain. While these representa- tions are general and can represent any waveform, they are not free from bias. This is because they often apply a prior over generating audio with aligned wave packets rather than oscillations. For ex- ample, strided convolution models-such as SING ( Defossez et al., 2018 ), MCNN ( Arik et al., 2019 ), and WaveGAN ( Donahue et al., 2019 )-generate waveforms directly with overlapping frames. Since audio oscillates at many frequencies, all with different periods from the fixed frame hop size, the model must precisely align waveforms between different frames and learn filters to cover all possible phase variations. This challenge is visualized on the left of  Figure 1 . Fourier-based models-such as Tacotron ( Wang et al., 2017 ) and GANSynth ( Engel et al., 2019 )- also suffer from the phase-alignment problem, as the Short-time Fourier Transform (STFT) is a representation over windowed wave packets. Additionally, they must contend with spectral leakage, where sinusoids at multiple neighboring frequencies and phases must be combined to represent a single sinusoid when Fourier basis frequencies do not perfectly match the audio. This effect can be seen in the middle diagram of  Figure 1 . Autoregressive waveform models-such as WaveNet ( Oord et al., 2016 ), SampleRNN ( Mehri et al., 2016 ), and WaveRNN ( Kalchbrenner et al., 2018 )-avoid these issues by generating the waveform a single sample at a time. They are not constrained by the bias over generating wave packets and can express arbitrary waveforms. However, they require larger and more data-hungry networks, as they do not take advantage of a bias over oscillation (size comparisons can be found in Table B.6). Furthermore, the use of teacher-forcing during training leads to exposure bias during generation, where errors with feedback can compound. It also makes them incompatible with perceptual losses such as spectral features ( Defossez et al., 2018 ), pretrained models ( Dosovitskiy & Brox, 2016 ), and discriminators ( Engel et al., 2019 ). This adds further inefficiency to these models, as a waveform's shape does not perfectly correspond to perception. For example, the three waveforms on the right of  Figure 1  sound identical (a relative phase offset of the harmonics) but would present different losses to an autoregressive model.

Section Title: OSCILLATOR MODELS
  OSCILLATOR MODELS Rather than predicting waveforms or Fourier coefficients, a third model class directly generates audio with oscillators. Known as vocoders or synthesizers, these models are physically and percep- tually motivated and have a long history of research and applications ( Beauchamp, 2007 ;  Morise et al., 2016 ). These "analysis/synthesis" models use expert knowledge and hand-tuned heuristics to extract synthesis parameters (analysis) that are interpretable (loudness and frequencies) and can be used by the generative algorithm (synthesis). Neural networks have been used previously to some success in modeling pre-extracted synthesis parameters ( Blaauw & Bonada, 2017 ;  Chandna et al., 2019 ), but these models fall short of end- to-end learning. The analysis parameters must still be tuned by hand and gradients cannot flow through the synthesis procedure. As a result, small errors in parameters can lead to large errors in Published as a conference paper at ICLR 2020 the audio that cannot propagate back to the network. Crucially, the realism of vocoders is limited by the expressivity of a given analysis/synthesis pair.

Section Title: CONTRIBUTIONS
  CONTRIBUTIONS In this paper, we overcome the limitations outlined above by using the DDSP library to implement fully differentiable synthesizers and audio effects. DDSP models combine the strengths of the above approaches, benefiting from the inductive bias of using oscillators, while retaining the expressive power of neural networks and end-to-end training. We demonstrate that models employing DDSP components are capable of generating high-fidelity audio without autoregressive or adversarial losses. Further, we show the interpretability and modu- larity of these models enable: • Independent control over pitch and loudness during synthesis. • Realistic extrapolation to pitches not seen during training. • Blind dereverberation of audio through seperate modelling of room acoustics. • Transfer of extracted room acoustics to new environments. • Timbre transfer between disparate sources, converting a singing voice into a violin. • Smaller network sizes than comparable neural synthesizers. Audio samples for all examples and figures are provided in the online supplement 2 . We highly encourage readers to listen to the samples as part of reading the paper.

Section Title: RELATED WORK
  RELATED WORK Vocoders. Vocoders come in several varieties. Source-filter/subtractive models are inspired by the human vocal tract and dynamically filter a harmonically rich source signal ( Flanagan, 2013 ), while sinusoidal/additive models generate sound as the combination of a set of time-varying sine waves ( McAulay & Quatieri, 1986 ;  Serra & Smith, 1990 ). Additive models are strictly more expres- sive than subtractive models but have more parameters as each sinusoid has its own time-varying loudness and frequency. This work builds a differentiable synthesizer off the Harmonic plus Noise model ( Serra & Smith, 1990 ;  Beauchamp, 2007 ): an additive synthesizer combines sinusoids in harmonic (integer) ratios of a fundamental frequency alongside a time-varying filtered noise signal.

Section Title: Synthesizers
  Synthesizers A separate thread of research has tried to estimate parameters for commercial syn- thesizers using gradient-free methods ( Huang et al., 2014 ;  Hoffman & Cook, 2006 ). Synthesizer outputs modeled with a variational autoencoder were recently used as a "world model" ( Ha & Schmidhuber, 2018 ) to pass approximate gradients to a controller during learning ( Esling et al., 2019 ). DDSP differs from black-box approaches to modeling existing synthesizers; it is a toolkit of differentiable DSP components for end-to-end learning.

Section Title: Neural Source Filter (NSF)
  Neural Source Filter (NSF) Perhaps closest to this work, promising speech synthesis results were recently achieved using a differentiable waveshaping synthesizer ( Wang et al., 2019 ). The NSF can be seen as a specific DDSP model, that uses convolutional waveshaping of a sinusoidal oscillator to create harmonic content, rather than additive synthesis explored in this work. Both works also generate audio in the time domain and impose multi-scale spectrograms losses in the frequency domain. A key contribution of this work is to highlight how these models are part of a common family of techniques and to release a modular library that makes them accessible by leveraging automatic differentiation to easily mix and match components at a high level.

Section Title: DDSP COMPONENTS
  DDSP COMPONENTS Many DSP operations can be expressed as functions in modern automatic differentiation software. We express core components as feedforward functions, allowing efficient implementation on parallel Published as a conference paper at ICLR 2020 hardware such as GPUs and TPUs, and generation of samples during training. These components include oscillators, envelopes, and filters (linear-time-varying finite-impulse-response, LTV-FIR).

Section Title: SPECTRAL MODELING SYNTHESIS
  SPECTRAL MODELING SYNTHESIS Here, as an example DDSP model, we implement a differentiable version of Spectral Modeling Synthesis (SMS)  Serra & Smith (1990) . This model generates sound by combining an additive synthesizer (adding together many sinusoids) with a subtractive synthesizer (filtering white noise). We choose SMS because, despite being parametric, it is a highly expressive model of sound, and has found widespread adoption in tasks as diverse as spectral morphing, time stretching, pitch shifting, source separation, transcription, and even as a general purpose audio codec in MPEG-4 ( Tellman et al., 1995 ;  Klapuri et al., 2000 ;  Purnhagen & Meine, 2000 ). As we only consider monophonic sources in these experiments, we use the Harmonic plus Noise model, that further constrains sinusoids to be integer multiples of a fundamental fre- quency ( Beauchamp, 2007 ). One of the reasons that SMS is more expressive than many other parametric models because it has so many more parameters. For example, in the 4 seconds of 16kHz audio in the datasets considered here, the synthesizer coefficients actually have ∼2.5 times more dimensions than the audio waveform itself ((1 amplitude + 100 harmonics + 65 noise band magnitudes) * 1000 timesteps = 165,000 dimensions, vs. 64,000 audio samples). This makes them amenable to control by a neural network, as it would be difficult to realistically specify all these parameters by hand.

Section Title: HARMONIC OSCILLATOR / ADDITIVE SYNTHESIZER
  HARMONIC OSCILLATOR / ADDITIVE SYNTHESIZER At the heart of the synthesis techniques explored in this paper is the sinusoidal oscillator. A bank of oscillators that outputs a signal x(n) over discrete time steps, n, can be expressed as: x(n) = K k=1 A k (n) sin(φ k (n)), (1) where A k (n) is the time-varying amplitude of the k-th sinusoidal component and φ k (n) is its in- stantaneous phase. The phase φ k (n) is obtained by integrating the instantaneous frequency f k (n): φ k (n) = 2π n m=0 f k (m) + φ 0,k , (2) where φ 0,k is the initial phase that can be randomized, fixed, or learned. For a harmonic oscillator, all the sinusoidal frequencies are harmonic (integer) multiples of a funda- mental frequency, f 0 (n), i.e., f k (n) = kf 0 (n), Thus the output of the harmonic oscillator is entirely parameterized by the time-varying fundamental frequency f 0 (n) and harmonic amplitudes A k (n). To aid interpretablity we further factorize the harmonic amplitudes: A k (n) = A(n)c k (n). (3) into a global amplitude A(n) that controls the loudness and a normalized distribution over harmonics c(n) that determines spectral variations, where K k=0 c k (n) = 1 and c k (n) ≥ 0. We also constrain both amplitudes and harmonic distribution components to be positive through the use of a modified sigmoid nonlinearity as described in the appendix. Figure 6 provides a graphical example of the additive synthesizer. Audio is provided in our online supplement 2 .

Section Title: ENVELOPES
  ENVELOPES The oscillator formulation above requires time-varying amplitudes and frequencies at the audio sam- ple rate, but our neural networks operate at a slower frame rate. For instantaneous frequency upsam- pling, we found bilinear interpolation to be adequate. However, the amplitudes and harmonic distri- butions of the additive synthesizer required smoothing to prevent artifacts. We are able to achieve Published as a conference paper at ICLR 2020 this with a smoothed amplitude envelope by adding overlapping Hamming windows at the center of each frame and scaled by the amplitude. For these experiments we found a 4ms (64 timesteps) hop size and 8 ms frame size (50% overlap) to be responsive to changes while removing artifacts.

Section Title: FILTER DESIGN: FREQUENCY SAMPLING METHOD
  FILTER DESIGN: FREQUENCY SAMPLING METHOD Linear filter design is a cornerstone of many DSP techniques. Standard convolutional layers are equivalent to linear time invariant finite impulse response (LTI-FIR) filters. However, to ensure interpretability and prevent phase distortion, we employ the frequency sampling method to convert network outputs into impulse responses of linear-phase filters. Here, we design a neural network to predict the frequency-domain transfer functions of a FIR filter for every output frame. In particular, the neural network outputs a vector H l (and accordingly h l = IDFT(H l )) for the l-th frame of the output. We interpret H l as the frequency-domain transfer function of the corresponding FIR filter. We therefore implement a time-varying FIR filter. To apply the time-varying FIR filter to the input, we divide the audio into non-overlapping frames x l to match the impulse responses h l . We then perform frame-wise convolution via multiplication of frames in the Fourier domain: Y l = H l X l where X l = DFT(x l ) and Y l = DFT(y l ) is the output. We recover the frame-wise filtered audio, y l = IDFT(Y l ), and then overlap-add the resulting frames with the same hop size and rectangular window used to originally divide the input audio. The hop size is given by dividing the audio into equally spaced frames for each frame of conditioning. For 64000 samples and 250 frames, this corresponds to a hop size of 256. In practice, we do not use the neural network output directly as H l . Instead, we apply a window function W on the network output to compute H l . The shape and size of the window can be decided independently to control the time-frequency resolution trade-off of the filter. In our experiments, we default to a Hann window of size 257. Without a window, the resolution implicitly defaults to a rectangular window which is not ideal for many cases. We take care to shift the IR to zero-phase (symmetric) form before applying the window and revert to causal form before applying the filter.

Section Title: FILTERED NOISE / SUBTRACTIVE SYNTHESIZER
  FILTERED NOISE / SUBTRACTIVE SYNTHESIZER Natural sounds contain both harmonic and stochastic components. The Harmonic plus Noise model captures this by combining the output of an additive synthesizer with a stream of filtered noise ( Serra & Smith, 1990 ;  Beauchamp, 2007 ). We are able to realize a differentiable filtered noise synthesizer by simply applying the LTV-FIR filter from above to a stream of uniform noise Y l = H l N l where N l is the DFT of uniform noise in domain [-1, 1].

Section Title: REVERB: LONG IMPULSE RESPONSES
  REVERB: LONG IMPULSE RESPONSES Room reverbation (reverb) is an essential characteristic of realistic audio, which is usually implicitly modeled by neural synthesis algorithms. In contrast, we gain interpretability by explicitly factoriz- ing the room acoustics into a post-synthesis convolution step. A realistic room impulse response (IR) can be as long as several seconds, corresponding to extremely long convolutional kernel sizes (∼10-100k timesteps). Convolution via matrix multiplication scales as O(n 3 ), which is intractable for such large kernel sizes. Instead, we implement reverb by explicitly performing convolution as multiplication in the frequency domain, which scales as O(n log n) and does not bottleneck training.

Section Title: EXPERIMENTS
  EXPERIMENTS For empirical verification of this approach, we test two DDSP autoencoder variants-supervised and unsupervised-on two different musical datasets: NSynth ( Engel et al., 2017 ) and a collection of solo violin performances. The supervised DDSP autoencoder is conditioned on fundamental frequency (F0) and loudness features extracted from audio, while the unsupervised DDSP autoencoder learns F0 jointly with the rest of the network.

Section Title: DDSP AUTOENCODER
  DDSP AUTOENCODER DDSP components do not put constraints on the choice of generative model (GAN, VAE, Flow, etc.), but we focus here on a deterministic autoencoder to investigate the strength of DDSP components independent of any particular approach to adversarial training, variational inference, or Jacobian design. Just as autoencoders utilizing convolutional layers outperform fully-connected autoencoders on images, we find DDSP components are able to dramatically improve autoencoder performance in the audio domain. Introducing stochastic latents (such as in GAN, VAE, and Flow models) will likely further improve performance, but we leave that to future work as it is orthogonal to the core question of DDSP component performance that we investigate in this paper. In a standard autoencoder, an encoder network f enc (·) maps the input x to a latent representation z = f enc (x) and a decoder network f dec (·) attempts to directly reconstruct the inputx = f dec (z). Our architecture ( Figure 2 ) contrasts with this approach through the use of DDSP components and a decomposed latent representation.

Section Title: Encoders
  Encoders Detailed descriptions of the encoders are given in Section B.1. For the supervised au- toencoder, the loudness l(t) is extracted directly from the audio, a pretrained CREPE model with fixed weights ( Kim et al., 2018 ) is used as an f (t) encoder to extact the fundamental frequency, and optional encoder extracts a time-varying latent encoding z(t) of the residual information. For the z(t) encoder, MFCC coefficients (30 per a frame) are first extracted from the audio, which corre- spond to the smoothed spectral envelope of harmonics ( Beauchamp, 2007 ), and transformed by a single GRU layer into 16 latent variables per a frame. For the unsupervised autoencoder, the pretrained CREPE model is replaced with a Resnet architec- ture ( He et al., 2016 ) that extracts f (t) from a mel-scaled log spectrogram of the audio, and is jointly trained with the rest of the network. Decoder: A detailed description of the decoder network is given in Section B.2. The decoder network maps the tuple (f (t), l(t), z(t)) to control parameters for the additive and filtered noise synthesizers described in Section 3. The synthesizers generate audio based on these parameters, and a reconstruction loss between the synthesized and original audio is minimized. The network archi- tecture is chosen to be fairly generic (fully connected, with a single recurrent layer) to demonstrate that it is the DDSP components, and not other modeling decisions, that enables the quality of the work. Also unique to our approach, the latent f (t) is fed directly to the additive synthesizer as it has structural meaning for the synthesizer outside the context of any given dataset. As shown later in Section 5.2, this disentangled representation enables the model to both interpolate within and ex- Published as a conference paper at ICLR 2020 trapolate outside the data distribution. Indeed, recent work support incorporation of strong inductive biases as a prerequisite for learning disentangled representations ( Locatello et al., 2018 ). Model Size: Table B.6, compares parameter counts for the DDSP models and comparable mod- els including GANSynth ( Engel et al., 2019 ), WaveRNN ( Hantrakul et al., 2019 ), and a WaveNet Autoencoder ( Engel et al., 2017 ). The DDSP models have the fewest parameters (up to 10 times less), despite no effort to minimize the model size in these experiments. Initial experiments with very small models (240k parameters, 300x smaller than a WaveNet Autoencoder) have less realistic outputs than the full models, but still have fairly high quality and are promising for low-latency applications, even on CPU or embedded devices. Audio samples are available in the online supple- ment 2 .

Section Title: DATASETS
  DATASETS NSynth: We focus on a smaller subset of the NSynth dataset ( Engel et al., 2017 ) consistent with other work ( Engel et al., 2019 ;  Hantrakul et al., 2019 ). It totals 70,379 examples comprised mostly of strings, brass, woodwinds and mallets with pitch labels within MIDI pitch range 24-84. We employ a 80/20 train/test split shuffling across instrument families. For the NSynth experiments, we use the autoencoder as described above (with the z(t) encoder). We experiment with both the supervised and unsupervised variants.

Section Title: Solo Violin
  Solo Violin The NSynth dataset does not capture aspects of a real musical performance. Using the MusOpen royalty free music library, we collected 13 minutes of expressive, solo violin perfor- mances 4 . We purposefully selected pieces from a single performer (John Garner), that were mono- phonic and shared a consistent room environment to encourage the model to focus on performance. Like NSynth, audio is converted to mono 16kHz and divided into 4 second training examples (64000 samples total). Code to process the audio files into a dataset is available online. For the solo violin experiments, we use the supervised variant of the autoencoder (without the z(t) encoder), and add a reverb module to the signal processor chain to account for room reverberation. While the room impulse response could be produced as an output of the decoder, given that the solo violin dataset has a single acoustic environment, we use a single fixed variable (4 second reverb corresponding to 64000 dimensions) for the impulse response.

Section Title: MULTI-SCALE SPECTRAL LOSS
  MULTI-SCALE SPECTRAL LOSS The primary objective of the autoencoder is to minimize reconstruction loss. However, for audio waveforms, point-wise loss on the raw waveform is not ideal, as two perceptually identical audio samples may have distinct waveforms, and point-wise similar waveforms may sound very different. Instead, we use a multi-scale spectral loss-similar to the multi-resolution spectral amplitude distance in  Wang et al. (2019) -defined as follows. Given the original and synthesized audio, we compute their (magnitude) spectrogram S i andŜ i , respectively, with a given FFT size i, and define the loss as the 4 Five pieces by John Garner (II. Double, III. Corrente, IV. Double Presto, VI. Double, VIII. Double) from https://musopen.org/music/13574-violin-partita-no-1-bwv-1002/ 5 https://github.com/magenta/ddsp sum of the L1 difference between S i andŜ i as well as the L1 difference between log S i and logŜ i . L i = ||S i −Ŝ i || 1 + α|| log S i − logŜ i || 1 . (4) where α is a weighting term set to 1.0 in our experiments. The total reconstruction loss is then the sum of all the spectral losses, L reconstruction = i L i . In our experiments, we used FFT sizes (2048, 1024, 512, 256, 128, 64), and the neighboring frames in the Short-Time Fourier Transform (STFT) overlap by 75%. Therefore, the L i 's cover differences between the original and synthesized audios at different spatial-temporal resolutions.

Section Title: RESULTS
  RESULTS

Section Title: HIGH-FIDELITY SYNTHESIS
  HIGH-FIDELITY SYNTHESIS As shown in Figure 5, the DDSP autoencoder learns to very accurately resynthesize the solo violin dataset. Again, we highly encourage readers to listen to the samples provided in the online supple- ment 2 . A full decomposition of the components is provided Figure 5. High-quality neural audio synthesis has previously required very large autoregressive models ( Oord et al., 2016 ;  Kalchbrenner et al., 2018 ) or adversarial loss functions ( Engel et al., 2019 ). While amenable to an adversarial loss, the DDSP autoencoder achieves these results with a straightforward L1 spectrogram loss, a small amount of data, and a relatively simple model. This demonstrates that the model is able to efficiently exploit the bias of the DSP components, while not losing the expressive power of neural networks. For the NSynth dataset, we quantitatively compare the quality of DDSP resynthesis with that of a state-of-the-art baseline using WaveRNN ( Hantrakul et al., 2019 ). The models are comparable as they are trained on the same data, provided the same conditioning, and both targeted towards realtime synthesis applications. In  Table 1 , we compute loudness and fundamental frequency (F0) L 1 metrics described in Section C of the appendix. Despite the strong performance of the baseline, the supervised DDSP autoencoder still outperforms it, especially in F0 L 1 . This is not unexpected, as the additive synthesizer directly uses the conditioning frequency to synthesize audio. The unsupervised DDSP autoencoder must learn to infer its own F0 conditioning signal directly from the audio. As described in Section B.4, we improve optimization by also adding a perceptual loss in the form of a pretrained CREPE network ( Kim et al., 2018 ). While not as accurate as the supervised DDSP version, the model does a fair job at learning to generate sounds with the correct frequencies without supervision, outperforming the supervised WaveRNN model.

Section Title: INDEPENDENT CONTROL OF LOUDNESS AND PITCH
  INDEPENDENT CONTROL OF LOUDNESS AND PITCH

Section Title: Interpolation
  Interpolation Interpretable structure allows for independent control over generative factors. Each component of the factorized latent variables (f (t), l(t), z(t)) independently alters samples along a matching perceptual axis. For example,  Figure 3  shows an interpolation between two sound in the loudness conditioning l(t). With other variables held constant, loudness of the synthesized audio closely matches the interpolated input. Similarly, the model reliably matches intermediate pitches between a high pitched f (t) and low pitched f (t). In Table C.2 of the appendix, we quantitatively demonstrate how across interpolations, conditioning independently controls the corresponding char- acteristics of the audio. With loudness and pitch explicitly controlled by (f (t), l(t)), the model should use the residual z(t) to encode timbre. Although architecture and training do not strictly enforce this encoding, we qual- itatively demonstrate how varying z leads to a smooth change in timbre. In  Figure 3 , we use the smooth shift in spectral centroid, or "center of mass" of a spectrum, to illustrate this behavior.

Section Title: Extrapolation
  Extrapolation As described in Section 4.1, f (t) directly controls the additive synthesizer and has structural meaning outside the context of any given dataset. Beyond interpolating between datapoints, the model can extrapolate to new conditions not seen during training. The rightmost plot of Figure 7 demonstrates this by resynthesizing a clip of solo violin after shifting f (t) down an octave and outside the range of the training data. The audio remains coherent and resembles a related instrument such as a cello. f (t) is only modified for the synthesizer, as the decoder is still bounded by the nearby distribution of the training data and produces unrealistic harmonic content if conditioned far outside that distribution.

Section Title: DEREVERBERATION AND ACOUSTIC TRANSFER
  DEREVERBERATION AND ACOUSTIC TRANSFER Removing reverb in a "blind" setting, where only reverberated audio is available, is a standing problem in acoustics ( Naylor & Gaubitch, 2010 ). However, a benefit of our modular approach to generative modeling is that it becomes possible to completely separate the source audio from the effect of the room. For the solo violin dataset, the DDSP autoencoder is trained with an additional reverb module as shown in  Figure 2  and described in Section 3.6. Figure 7 (left) demonstrates that bypassing the reverb module during resynthesis results in completely dereverberated audio, similar to recording in an anechoic chamber. The quality of the approach is limited by the underlying generative model, which is quite high for our autoencoder. Similarly, Figure 7 (center) demonstrates that we can also apply the learned reverb model to new audio, in this case singing, and effectively transfer the acoustic environment of the solo violin recordings.

Section Title: TIMBRE TRANSFER
  TIMBRE TRANSFER   Figure 4  demonstrates timbre transfer, converting the singing voice of an author into a violin. F0 and loudness features are extracted from the singing voice and the DDSP autoencoder trained on solo violin used for resynthesis. To better match the conditioning features, we first shift the fundamental frequency of the singing up by two octaves to fit a violin's typical register. Next, we transfer the room acoustics of the violin recording (as described in Section 5.3) to the voice before extracting loudness, to better match the loudness contours of the violin recordings. The resulting audio captures many subtleties of the singing with the timbre and room acoustics of the violin dataset. Note the interesting "breathing" artifacts in the silence corresponding to unvoiced syllables from the singing.

Section Title: CONCLUSION
  CONCLUSION The DDSP library fuses classical DSP with deep learning, providing the ability to take advantage of strong inductive biases without losing the expressive power of neural networks and end-to-end Published as a conference paper at ICLR 2020 learning. We encourage contributions from domain experts and look forward to expanding the scope of the DDSP library to a wide range of future applications.
  We have implemented further components such as wavetable synthesizers and non-sinusoidal oscillators, but focus here on components used in the experiments and leave the rest as future work.

```
