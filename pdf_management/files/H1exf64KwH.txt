Title:
```
Published as a conference paper at ICLR 2020 EXPLORING MODEL-BASED PLANNING WITH POLICY NETWORKS
```
Abstract:
```
Model-based reinforcement learning (MBRL) with model-predictive control or online planning has shown great potential for locomotion control tasks in both sample efficiency and asymptotic performance. Despite the successes, the existing planning methods search from candidate sequences randomly generated in the action space, which is inefficient in complex high-dimensional environments. In this paper, we propose a novel MBRL algorithm, model-based policy planning (POPLIN), that combines policy networks with online planning. More specifically, we formulate action planning at each time-step as an optimization problem using neural networks. We experiment with both optimization w.r.t. the action sequences initialized from the policy network, and also online optimization directly w.r.t. the parameters of the policy network. We show that in the MuJoCo benchmarking environments, POPLIN is about 3x more sample efficient than the previously state- of-the-art algorithms, such as PETS, TD3 and SAC. To explain the effectiveness of our algorithm, we show that the optimization surface in parameter space is smoother than in action space. Further more, we found the distilled policy network can be effectively applied without the expansive model predictive control during test time for some environments such as Cheetah. Code is released here 1 . 1 https://github.com/WilsonWangTHU/POPLIN.
```

Figures/Tables Captions:
```
Figure 1: We transform each planned candidate action trajectory with PCA into a 2D blue scatter. The top and bottom figures are respectively the visualization of PETS (Chua et al., 2018) and our algorithm. The red area has higher reward. From left to right, we show how candidate trajectories are updated, across different planning iterations within one time-step. As we can see, while both reward surface is not smooth with respect to action trajectory. POPLIN, using policy networks, has much better search efficiency, while PETS is stuck around its initialization. The details are in section 5.3.
Figure 2: Performance curves on different bench-marking environments. 4 random seeds are run for each environment. The full figures of all 12 MuJoCo environments are summarized in appendix 8.
Figure 3: The MPC control and policy control performance of the proposed POPLIN-A, and POPLIN- P with its three training schemes, which are namely behavior cloning (BC), generative adversarial network training (GAN) and setting parameter average (Avg).
Figure 4: The performance of PETS, POPLIN-A, POPLIN-P using different population size of candidates on Cheetah. The variance of the candidates trajectory σ in POPLIN-P is set to 0.1.
Figure 5: The reward optimization surface in the solution space. The expected reward is higher from color blue to color red. We visualize candidates using different colors as defined in the legend. The full results can be seen in appendix A.7.
Figure 7: The ablation study of of POPLIN-A, POPLIN-P-BC, POPLIN-P-Avg, POPLIN-P-GAN.
Figure 6: Projected action distribution.
Table 1: The training time-step varies from 50,000 to 200,000 depending on the difficulty of the tasks. The performance is averaged across four random seeds with the last 3 episodes.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION A model-based reinforcement learning (MBRL) agent learns its internal model of the world, i.e. the dynamics, from repeated interactions with the environment. With the learnt dynamics, a MBRL agent can for example perform online planning, interact with imaginary data, or optimize the controller through dynamics, which provides significantly better sample efficiency ( Deisenroth & Rasmussen, 2011 ;  Sutton, 1990 ;  Levine & Abbeel, 2014 ;  Levine & Koltun, 2013 ). However, MBRL algorithms generally do not scale well with the increasing complexity of the reinforcement learning (RL) tasks in practice. And modelling errors in dynamics that accumulate with time-steps greatly limit the applications of MBRL algorithms. As a result, many latest progresses in RL has been made with model-free reinforcement learning (MFRL) algorithms that are capable of solving complex tasks at the cost of large number of samples ( Schulman et al., 2017 ;  Heess et al., 2017 ;  Schulman et al., 2015 ;  Mnih et al., 2013 ; Lillicrap et al., 2015;  Haarnoja et al., 2018 ). With the success of deep learning, a few recent works have proposed to learn neural network-based dynamics models for MBRL. Among them, random shooting algorithms (RS), which uses model- predictive control (MPC), is shown to have good robustness and scalability ( Richards, 2005 ). In shooting algorithms, the agent randomly generates action sequences, use the dynamics to predict the future states, and choose the first action from the sequence with the best expected reward. However, RS usually has worse asymptotic performance than model-free controllers ( Nagabandi et al., 2017 ), and the authors of the the PETS algorithm ( Chua et al., 2018 ) suggest that the performance of RS is directly affected by the quality of the learnt dynamics. They propose a probabilistic ensemble to capture model uncertainty, which enables PETS algorithm to achieve both better sample efficiency and better asymptotic performance than state-of-the-art model-free controllers in environments such as Cheetah. However, PETS is not as effective on environments with higher dimensionality. In this paper, we explore MBRL algorithms from a different perspective, where we treat the planning at each time-step as an optimization problem. Random search in action space, as what is being done in state-of-the-art MBRL algorithms such as PETS, is insufficient for more complex environments. On the one hand, we are inspired by the success of AlphaGo ( Silver et al., 2016 ; 2017), where a policy network is used to generate proposals for the Monte-Carlo tree search. On the other hand, we are inspired by the recent research into understanding deep neural networks ( Nguyen & Hein, 2017 ;  Li et al., 2018 ;  Soudry & Hoffer, 2017 ). Deep neural networks, frequently observed in practices, is much less likely to get stuck in sub-optimal points. In  Figure 1 , we apply principal component analysis (PCA) on the action sequences generated in each planning iteration within one time-step. The reward surface of the action space is not smooth and prone to local-minimas. We argue that optimization in the policy network's parameter space will be more efficient. Furthermore, we note that the state-of-the-art MBRL algorithm with MPC cannot be applied real-time. We therefore experiment with different policy network distillation schemes for fast control without MPC. To sum up, the contribution of this paper is three-fold: • We apply policy networks to generate proposals for MPC in high dimensional locomotion control problems with unknown dynamics. • We formulate planning as optimization with neural networks, and propose policy planning in parameter space, which obtain state-of-the-art performance on current bench-marking environ- ments, being about 3x more sample efficient than the previous state-of-the-art algorithm, such as PETS ( Chua et al., 2018 ), TD3 ( Fujimoto et al., 2018 ) and SAC ( Haarnoja et al., 2018 ). • We also explore policy network distillation from the planned trajectories. We found the distilled pol- icy network alone achieves high performance on environments like Cheetah without the expansive online planning.

Section Title: RELATED WORK
  RELATED WORK Model-based reinforcement learning (MBRL) has been long studied. Dyna ( Sutton, 1990 ; 1991) algorithm alternately performs sampling in the real environments and optimize the controllers on the learned model of the environments. Other pioneering work includes PILCO ( Deisenroth & Rasmussen, 2011 ), where the authors model the dynamics using Gaussian Process and directly optimize the surrogate expected reward. Effective as it is to solve simple environments, PILCO Published as a conference paper at ICLR 2020 heavily suffers the curse of dimensionality. In ( Levine & Abbeel, 2014 ;  Levine & Koltun, 2013 ;  Levine et al., 2016 ;  Chebotar et al., 2017 ;  Zhang et al., 2018 ), the authors propose guided policy search (GPS). GPS uses iLQG ( Li & Todorov, 2004 ;  Todorov & Li, 2005 ;  Tassa et al., 2012 ) as the local controller, and distill the knowledge into a policy neural network. In SVG ( Heess et al., 2015 ), the authors uses stochastic value gradient so that the stochastic policy network can be optimized by back-propagation with off-policy data. Recently with the progress of model-free algorithms such as TRPO and PPO ( Schulman et al., 2015 ; 2017),  Kurutach et al. (2018) ;  Luo et al. (2019)  propose modern variants of Dyna, where TRPO ( Schulman et al., 2015 ) is used to optimize the policy network using data generated by the learnt dynamics. Concurrent to this work,  Janner et al. (2019)  further use SAC ( Haarnoja et al., 2018 ) to train the policy network, and gets state-of-the-art performance on many tasks. At the same time, random shooting methods proposed by  Nagabandi et al. (2017) ;  Chua et al. (2018)  have shown its robustness and effectiveness on benchmarking environments. PETS algorithm ( Chua et al., 2018 ) is considered by many to be the state-of-the-art shooting algorithm, which we discuss in detail in section 3. Dynamics is also used to obtain better value estimation to speed up training ( Gu et al., 2016 ;  Feinberg et al., 2018 ;  Buckman et al., 2018 ). Latent dynamics models using VAE ( Kingma & Welling, 2013 ) are commonly used to solve problems with image input ( Ha & Schmidhuber, 2018a ;b; Hafner et al., 2018;  Kaiser et al., 2019 ).

Section Title: BACKGROUND
  BACKGROUND

Section Title: REINFORCEMENT LEARNING
  REINFORCEMENT LEARNING In reinforcement learning, the problem of solving the given task is formulated as a infinite-horizon discounted Markov decision process. For the agent, we denote the action space and state space respectively as A and S. We also denote the reward function and transition function as r(s t , a t ) and f (s t+1 |s t , a t ), where s t ∈ S and a t ∈ A are the state and action at time-step t. The reward function is assumed known to the agent in this work. The agent maximizes its expected total reward J(π) = E π [ ∞ t=0 r(s t , a t )] with respect to the agent's controller π.

Section Title: RANDOM SHOOTING ALGORITHM AND PETS
  RANDOM SHOOTING ALGORITHM AND PETS Our proposed algorithm is based on the random shooting algorithm ( Richards, 2005 ). In random shooting algorithms ( Nagabandi et al., 2017 ;  Chua et al., 2018 ), a data-set of D = {(s t , a t , s t+1 )} is collected from previously generated real trajectories. The agent learns an ensemble of neural networks denoted as f φ (s t+1 |s t , a t ), with the parameters of the neural networks denoted as φ. In planning, the agent randomly generates a population of K candidate action sequences. Each action sequence, denoted as a = {a 0 , ..., a τ }, contains the control signals at every time-steps within the planning horizon τ . The action sequence with the best expected reward given the current dynamics network f φ (s t+1 |s t , a t ) is chosen. RS, as a model-predictive control algorithm, only executes the first action signal and re-plan at time-step. In PETS ( Chua et al., 2018 ), the authors further use cross entropy method (CEM) ( De Boer et al., 2005 ;  Botev et al., 2013 ) to re-samples sequences near the best sequences from the last CEM iteration.

Section Title: MODEL-BASED POLICY PLANNING Algorithm 1 General POPLIN Framework
  MODEL-BASED POLICY PLANNING Algorithm 1 General POPLIN Framework 1: while Training iterations not Finished do 2: for i th time-step of the agent do 3: CEM planning as in section 4.1, 4.2 4: Execute the first action from CEM. In this section, we describe two variants of POPLIN: model-based policy planning in action space (POPLIN-A) and model-based policy plan- ning in parameter space (POPLIN-P). Following the notations in section 3.2, we define the expected planning reward function at time-step i as follows: The action sequence a i = {a i , a i+1 , ..., a i+τ } is generated by the policy search module, as later described in Section 4.1 and 4.2. The expectation of predicted trajectories {s i , s i+1 , ..., s i+τ } is Published as a conference paper at ICLR 2020 estimated by creating P particles from the current state. The dynamics model f k,t φ (s t+1 |s t , a t ) used by k th particle at time-step t is sampled from deterministic or probabilistic ensemble models. To better illustrate, throughout the paper we denote this dynamics as a fixed deterministic model, i.e. f k,t φ ≡ f φ . In practice the dynamics uses probabilistic ensemble models, which requires some trivial modifications to the math and we refer readers to PETS  Chua et al. (2018)  for details.

Section Title: MODEL-BASED POLICY PLANNING IN ACTION SPACE
  MODEL-BASED POLICY PLANNING IN ACTION SPACE In model-based policy planning in action space (POPLIN-A), we use a policy network to generate good initial action distribution. We denote the policy network as π(s t ). Once the policy network proposes sequences of actions on the expected trajectories, we add Gaussian noise to the candidate actions and use CEM to fine-tune the mean and standard deviation of the noise distribution. Similar to defining a i = {a i , a i+1 , ..., a i+τ }, we denote the noise sequence at time-step t with horizon τ as δ i = {δ i , δ i+1 , ..., δ i+τ }. We initialize the noise distribution as a Gaussian distribution with mean µ 0 = 0 and covariance Σ 0 = σ 2 0 I, where σ 2 0 is the initial noise variance. In each CEM iteration, we first sort out the sequences with the top ξ + 1 expected planning reward, whose noise sequences are denoted as {δ 0 i , δ 1 i , ..., δ ξ i }. Then we estimate the noise distribution of the elite candidates, i. e., The elite distribution (µ , Σ ) in CEM algorithm is used to update the candidate noise distribution as µ = (1 − α)µ + αµ , Σ = (1 − α)Σ + αΣ . For every time-step, several CEM iterations are performed by candidate re-sampling and noise distribution updating. We provide detailed algorithm boxes in appendix A.1. We consider the following two schemes to add action noise.

Section Title: POPLIN-A-Init
  POPLIN-A-Init In this planning schemes, we use the policy network only to propose the initial- ization of the action sequences. When planning at time-step i with observed state s i , we first obtain the initial reference action sequences, denoted asâ i = {â i ,â i+1 , ...,â i+τ }, by running the initial forward pass with policy network. At each planning time-step t, where i ≤ t ≤ i + τ , we havê a t = π(ŝ t ), whereŝ t = f φ (ŝ t−1 , a t−1 ),ŝ i = s i The expected reward given search noise δ i will be: POPLIN-A-Replan: POPLIN-A-Replan is a more aggressive planning schemes, which always re-plans the controller according the changed trajectory given the current noise distribution. If we had the perfect dynamics network and the policy network, then we expect re-planning to achieve faster convergence the optimal action distribution. But it increases the risk of divergent behaviors. In this case, the expected reward for each trajectory is

Section Title: MODEL-BASED POLICY PLANNING IN PARAMETER SPACE
  MODEL-BASED POLICY PLANNING IN PARAMETER SPACE While planning in the action space is a natural extension of the original PETS algorithm, we found it provides little performance improvement in complex environments. One potential reason is that POPLIN-A still performs CEM searching in action sequence space, where the conditions of convergence for CEM is usually not met. Let's assume that a robot arm needs to either go left or right to get past the obstacle in the middle. In CEM planning in the action space, the theoretic distribution mean is always going straight, which fails to model the bi-modal action distribution. Indeed, planning in action space is a non-convex optimization whose surface has lots of holes and peaks. Recently, much research progress has been made in understanding why deep neural networks are much less likely to get stuck in sub-optimal points  Nguyen & Hein (2017) ;  Li et al. (2018) ;  Soudry & Hoffer (2017) . And we believe that planning in parameter space is essentially using deeper neural networks. Therefore, we propose model-based policy planning in parameter space (POPLIN-P).

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 Instead of adding noise in the action space, POPLIN-P adds noise in the parameter space of the policy network. We denote the parameter vector of policy network as θ, and the parameter noise sequence starting from time-step i as ω i = {ω i , ω i+1 , ..., ω i+τ }. The expected reward function is now Similarly, we update the CEM distribution towards the following elite distribution: We can force the policy network noise within the sequence to be consistent, i.e. ω i = ω i+1 = ... = ω i+τ , which we name as POPLIN-P-Uni. This reduces the size of the flattened noise vector from (τ + 1)|θ| to |θ|, and is more consistent in policy behaviors. The noise can also be separate for each time-step, which we name as POPLIN-P-Sep. We benchmark both schemes in section 5.4.

Section Title: Equivalence to re-parameterized stochastic policy
  Equivalence to re-parameterized stochastic policy Stochastic policy network encourages explo- ration, and increases the robustness against the impact of compounded model errors. POPLIN-P, which inserts exogenous noise into the parameter space, can be regarded as a re-parameterized stochastic policy network, which natural combines stochastic policy network with planning.

Section Title: MODEL-PREDICTIVE CONTROL AND POLICY CONTROL
  MODEL-PREDICTIVE CONTROL AND POLICY CONTROL MBRL with online re-planning or model-predictive control (MPC) is effective, but at the same time time-consuming. Many previous attempts have tried to distill the planned trajectories into a policy network  Levine & Abbeel (2014) ;  Levine & Koltun (2013) ;  Chebotar et al. (2017) ;  Zhang et al. (2018) , and control only with policy network. In this paper, we define two settings of using POPLIN: MPC Control and Policy Control. In MPC control, the agent uses policy network during the online planning and only execute the first action. In policy control, the agent directly executes the signal produced by the policy network given current observation, just like how policy network is used in MFRL algorithms. We show both performance of POPLIN in this paper.

Section Title: POLICY DISTILLATION SCHEMES
  POLICY DISTILLATION SCHEMES The agents iterate between interacting with the environments, and distilling the knowledge from planning trajectory into a policy network. We consider several policy distillation schemes here, and discuss their effectiveness in the later experimental section. Behavior cloning (BC): BC can be applied to POPLIN-A and POPLIN-P, by minimizing the squared L2 loss as Equation 7. D is the collection of observation and planned action from real environment. When applying BC to POPLIN-P, we fix parameter noise of the network to be zeros. Generative adversarial network training (GAN)  Goodfellow et al. (2014) : GAN can be applied to POPLIN-P. We consider the following fact. During MPC control, the agent only needs to cover the best action sequence in its action sequence distribution. Therefore, instead of point-to-point supervised training such as BC, we can train the policy network using GAN: where a discriminator D parameterized by ψ is used, and we sample the random noise z from the initial CEM distribution N (0, σ 0 I).

Section Title: Setting parameter average (AVG)
  Setting parameter average (AVG) AVG is also applicable to POPLIN-P. During interaction with real environment, we also record the optimized parameter noise in to the data-set, i. e. D = {(s, ω)}. And we sacrifice the effectiveness of the policy control and only use policy network as a good search initialization. The new parameter is updated as θ = θ + 1/|D| ω∈D ω.

Section Title: EXPERIMENTS
  EXPERIMENTS In section 5.1, we compare POPLIN with existing algorithms. We also show the policy control performance of POPLIN with different training methods in section 5.2. In section 5.3, we provide explanations and analysis for the effectiveness of our proposed algorithms by exploring and visualizing the planner's reward optimization surface. In section 5.4, we study the sensitivity of our algorithms with respect to hyper-parameters, and show the performance of different algorithm variants.

Section Title: MUJOCO BENCHMARKING PERFORMANCE
  MUJOCO BENCHMARKING PERFORMANCE In this section, we compare POPLIN with existing reinforcement learning algorithms including PETS ( Chua et al., 2018 ), GPS ( Levine et al., 2016 ), RS ( Richards, 2005 ), MBMF ( Nagabandi et al., 2017 ), TD3 ( Fujimoto et al., 2018 ) METRPO ( Kurutach et al., 2018 ), PPO ( Schulman et al., 2017 ;  Heess et al., 2017 ), TRPO ( Schulman et al., 2015 ) and SAC ( Haarnoja et al., 2018 ), which includes the most recent progress of both model-free and model-based algorithms. We examine the algorithms with 12 environments, which is a wide collection of environments from OpenAI Gym ( Brockman et al., 2016 ) and the environments proposed in PETS ( Chua et al., 2018 ), which are summarized in appendix A.2. Due to the page limit and to better visualize the results, we put the complete figures and tables in appendix A.3. And in  Figure 2  and  Table 1 , we show the performance of our algorithms and the best performing baselines. The hyper-parameter search is summarized in appendix A.3.1. As shown in  Table 1 , POPLIN achieves state-of-the-art performance in almost all environments, solving most of the them with 200,000 or 50,000 time-steps, instead of 1 million time-steps commonly used in MFRL algorithms. POPLIN-A (POPLIN-A-BC-Replan) has the best performance in simpler environments such as Pendulum, Cart-pole, Swimmer. But on complex environments such as Ant, Cheetah or Hopper, POPLIN-A does not have obvious performance gain compared with PETS. POPLIN-P (POPLIN-P-Sep-AVG) on the other hand, has consistent and stable performance among different environments. POPLIN-P is significantly better than all other algorithms in complex environments such as Ant and Cheetah. However, like other model-based algorithms, POPLIN cannot solve environments such as Walker and Humanoid. the performance of POPLIN plateaus Published as a conference paper at ICLR 2020 0 10000 20000 30000 40000 50000 timesteps −500 0 500 1000 1500 2000 reward (aquickly. Gradually model-free algorithms will have better asymptotic performance. We view this as a bottleneck of our algorithms and leave it to future research.

Section Title: POLICY CONTROL PERFORMANCE
  POLICY CONTROL PERFORMANCE In this section, we show the performance of POPLIN without MPC. To be more specific, we show the performance with the Cheetah, Pendulum, Pusher and Reacher3D, as shown in  Figure 3 , and we refer readers to appendix A.4 for the full results. We note that policy control is not always successful, and in environments such as Ant and Walker2D, the performance is almost random. In simple environments such as Pusher and Reacher3D, POPLIN-A has the best MPC performance, but has worse policy control performance compared with POPLIN-P- BC and POPLIN-P-GAN. At the same time, both POPLIN-P-BC and POPLIN-P-GAN are able to efficiently distill the knowledge from planned trajectory. Which one of POPLIN-P-BC and POPLIN-P- GAN is better depends on the environment tested, and they can be used interchangeably. This indicates that POPLIN-A, which uses a deterministic policy network, is more prone to distillation collapse than POPLIN-P, which can be interpreted as using a stochastic policy network with reparameterization trick. POPLIN-P-Avg, which only use policy network as optimization initialization has good MPC performance, but sacrifices the policy control performance. In general, the performance of policy control lags behind MPC control.

Section Title: SEARCH EFFECTIVENESS AND REWARD SURFACE
  SEARCH EFFECTIVENESS AND REWARD SURFACE In this section, we explore the reasons for the effectiveness of POPLIN. In  Figure 4 , we show the performance of PETS, POPLIN-A and POPLIN-P with different population sizes. As we can see, PETS and POPLIN-A, which are the two algorithms that add search noise in the action space, cannot increase their performance by having bigger population size. However, POPLIN-P is able to efficiently increase performance with bigger population size. We then visualize the candidates in their reward or optimization surface in  Figure 1 . We use PCA (principal component analysis) to transform the action sequences into 2D features. As we can see, the reward surface is not smooth, with lots of local-minima and local-maxima islands. The CEM distribution of PETS algorithm is almost fixed across iterations on this surface, even if there are potentially higher reward regions. POPLIN is able Published as a conference paper at ICLR 2020 to efficiently search through the jagged reward surface, from the low-reward center to the high reward left-down corner. To further understand why POPLIN is much better at searching through the reward surface, we then plot the figures in the solution space in  Figure 5 . More specifically, we now perform PCA on the policy parameters for POPLIN-P. As we can see in  Figure 5 (c) , the reward surface in parameter space is much smoother than the reward surface in action space, which are shown in  Figure 5 (a), (b) . POPLIN-P can efficiently search through the smoother reward surface in parameter space. In  Figure 6 , we also visualize the actions distribution in one episode taken by PETS, POPLIN-A and POPLIN- P using policy networks of different number of hidden layers. We again use PCA to project the actions into 2D feature space. As we can see, POPLIN-P shows a clear pattern of being more multi-modal with the use of deeper the network.

Section Title: ABLATION STUDY
  ABLATION STUDY In this section, we study how sensitive our algorithms are with respect to some of the crucial hyper- parameters, for example, the initial variance of the CEM noise distribution. We also show the performance of different algorithm variants. The full ablation study and performance against different random seeds are included in appendix A.5. In  Figure 7 (a) , we show the performance of POPLIN-A using different training schemes. We try both training with only the real data samples, which we denote as "Real", and training also with imaginary data the agent plans into the future, which we denote as "Hallucination". In practice, POPLIN-A-Init performs better than POPLIN-A-Replan, which suggests that there can be divergent or overconfident update in POPLIN-A-Replan. And training with or without imaginary does not have big impact on the performance. In Figure7 (b) and (c), we also compare the performance of POPLIN-P-Uni with POPLIN-P-Sep, where we show that POPLIN-P-Sep has much better performance than POPLIN-P-Uni, indicating the search is not efficient enough in the constrained parameter space. For POPLIN-P-Avg, with bigger initial variance of the noise distribution, the agent gets better at planning. However, increasing initial noise variance does not increase the performance of PETS algorithm, as shown in 7 (b), (d). It is worth mentioning that POPLIN-P-GAN is highly sensitive to the entropy penalty we add to the discriminator, with the 3 curves in Figure7 (c) using entropy penalty of 0.003, 0.001 and 0.0001 respectively,

Section Title: CONCLUSIONS
  CONCLUSIONS In this paper, we explore efficient ways to combine policy networks with model-based planning. We propose POPLIN, which obtains state-of-the-art performance on the MuJoCo benchmarking environments. We study different distillation schemes to provide fast controllers during testing. More importantly, we formulate online planning as optimization using deep neural networks. We believe POPLIN will scale to more complex environments in the future.

```
