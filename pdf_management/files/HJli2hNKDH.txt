Title:
```
Published as a conference paper at ICLR 2020 OBSERVATIONAL OVERFITTING IN REINFORCEMENT LEARNING
```
Abstract:
```
A major component of overfitting in model-free reinforcement learning (RL) in- volves the case where the agent may mistakenly correlate reward with certain spurious features from the observations generated by the Markov Decision Process (MDP). We provide a general framework for analyzing this scenario, which we use to design multiple synthetic benchmarks from only modifying the observation space of an MDP. When an agent overfits to different observation spaces even if the underlying MDP dynamics is fixed, we term this observational overfitting. Our experiments expose intriguing properties especially with regards to implicit regu- larization, and also corroborate results from previous works in RL generalization and supervised learning (SL).
```

Figures/Tables Captions:
```
Figure 1: Example of observational overfitting in Sonic from Gym Retro (Nichol et al., 2018). Saliency maps (Greydanus et al., 2018) highlight (in red) the top-left timer and background objects such as clouds and textures because they are correlated with progress, as they move backwards while agent is moving forwards. The agent could memorize optimal actions for training levels even if its observation was only from the timer, and "blacking-out" the timer consistently improved generalization performance (see Appendix A.2.3).
Figure 2: (a) Visual Analogy of the Observation Function. (b) Our combinations for 1-D (top) and 2-D (bottom) images for synthetic tasks.
Figure 3: (Left) We show that the generalization gap vs noise dimension is tight as the noise dimension increases, showing that this bound is accurate. (Middle and Right) LQR Generalization Gap vs Number of Intermediate Layers. We plotted different Φ = j i=0 A * A terms without exponents, as powers of those terms are monotonic transforms since A * A ≥ 1 ∀A and A * = A F , A 1 . We see that the naive spectral bound diverges at 2 layers, and the weight-counting sums are too loose.
Figure 4: Each Mujoco task is given 10 training levels (randomly sampling g θ parameters). We used a 2-layer ReLU policy, with 128 hidden units each. Dimensions of outputs of (f, g) were (30, 100) respectively.
Figure 5: Effects of Depth.
Figure 6: Effects of Width.
Figure 7: Performance of architectures in the synthetic Gym-Deconv dataset. To cleanly depict test performance, training curves are replaced with horizontal (max env. reward) and vertical black lines (avg. timestep when all networks reach max reward).
Figure 8: We only show the observation from g θ (s), which tests memorization capacity on Swimmer-v2.
Figure 9: Overparametrization improves generalization for CoinRun. While we also extend the case of large-parameter convolutional networks using ImageNet networks in Appendix A.2.1, an important question is how to predict the generalization gap only from the training phase. A particular set of metrics, popular in the SL community are margin distributions (Jiang et al., 2018; Bartlett et al., 2017), as they deal with the case for softmax outputs which do not explicitly penalize the weight norm of a network, by normalizing the "confidence" margin of the logit outputs. While using margins on state-action pairs (from an on-policy replay buffer) is not technically rigorous, one may be curious to see if they have predictive power, especially as MLPs are relatively simple to norm-bound. We plotted these margin distributions in Appendix A.2.2, but found that the weight norm bounds used in SL are simply too dominant for this RL case. This, with the bound results found earlier for the LQR case, suggests that current norm bounds are simply too loose for the RL case even though we have shown overparametrization helps generalization in RL, and hopefully this motivates more of the study of such theory.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Generalization for RL has recently grown to be an important topic for agents to perform well in unseen environments. Complication arises when the dynamics of the environments entangle with the observation, which is often a high-dimensional projection of the true latent state. One particular framework, which we denote by zero-shot supervised framework (Zhang et al., 2018a;c; Nichol et al., 2018; Justesen et al., 2018) and is used to study RL generalization, is to treat it analogous to a classical supervised learning (SL) problem - i.e. assume there exists a distribution of MDP's, train jointly on a finite "training set" sampled from this distribution, and check expected performance on the entire distribution, with the fixed trained policy. In this framework, there is a spectrum of analysis, ranging from almost purely theoretical analysis (Wang et al., 2019; Asadi et al., 2018) to full empirical results on diverse environments (Zhang et al., 2018c; Packer et al., 2018). However, there is a lack of analysis in the middle of this spectrum. On the theoretical side, previous work do not provide analysis for the case when the underlying MDP is relatively complex and requires the policy to be a non-linear function approximator such as a neural network. On the empirical side, there is no common ground between recently proposed empirical benchmarks. This is partially caused by multiple confounding factors for RL generalization that can be hard to identify and separate. For instance, an agent can overfit to the MDP dynamics of the training set, such as for control in Mujoco (Pinto et al., 2017; Rajeswaran et al., 2017). In other cases, an RNN-based policy can overfit to maze-like tasks in exploration (Zhang et al., 2018c), or even exploit determinism and avoid using observations (Bellemare et al., 2012; Machado et al., 2018). Furthermore, various hyperparameters such as the batch-size in SGD (Smith et al., 2018), choice of optimizer (Kingma & Ba, 2014), discount factor γ (Jiang et al., 2015) and regularizations such as entropy (Ahmed et al., 2018) and weight norms (Cobbe et al., 2018) can also affect generalization.

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 Due to these confounding factors, it can be unclear what parts of the MDP or policy are actually contributing to overfitting or generalization in a principled manner, especially in empirical studies with newly proposed benchmarks. In order to isolate these factors, we study one broad factor affecting generalization that is most correlated with themes in SL, specifically observational overfitting, where an agent overfits due to properties of the observation which are irrelevant to the latent dynamics of the MDP family. To study this factor, we fix a single underlying MDP's dynamics and generate a distribution of MDP's by only modifying the observational outputs. Our contributions in this paper are the following: 1. We discuss realistic instances where observational overfitting may occur and its difference from other confounding factors, and design a parametric theoretical framework to induce observational overfitting that can be applied to any underlying MDP. 2. We study observational overfitting with linear quadratic regulators (LQR) in a synthetic environment and neural networks such as multi-layer perceptrons (MLPs) and convolutions in classic Gym environments. A primary novel result we demonstrate for all cases is that implicit regularization occurs in this setting in RL. We further test the implicit regularization hypothesis on the benchmark CoinRun from using MLPs, even when the underlying MDP dynamics are changing per level. 3. In the Appendix, we expand upon previous experiments by including full training curve and hyperparamters. We also provide an extensive analysis of the convex one-step LQR case under the observational overfitting regime, showing that under Gaussian initialization of the policy and using gradient descent on the training cost, a generalization gap must necessarily exist. The structure of this paper is outlined as follows: Section 2 discusses the motivation behind this work and the synthetic construction to abstract certain observation effects. Section 3 demonstrates numerous experiments using this synthetic construction that suggest implicit regularization is at work. Finally, Section 3.4 tests the implicit regularization hypothesis on CoinRun, as well as ablates various ImageNet architectures and margin metrics in the Appendix.

Section Title: MOTIVATION AND RELATED WORK
  MOTIVATION AND RELATED WORK We start by showing an example of observational overfitting in  Figure 1 . This example highlights the issues surrounding MDP's with rich, textured observations - specifically, the agent can use any features that are correlated with progress, even those which may not generalize across levels. This is an important issue for vision-based policies, as many times it is not obvious what part of the observation causes an agent to act or generalize. Currently most architectures used in model-free RL are simple (with fewer than one million parame- ters) compared to the much larger and more complex ImageNet architectures used for classification.

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 This is due to the fact that most RL environments studied either have relatively simple and highly structured images (e.g. Atari) compared to real world images, or conveniently do not directly force the agent to observe highly detailed images. For instance in large scale RL such as DOTA2 (OpenAI, 2018) or Starcraft 2 (Vinyals et al., 2017), the agent observations are internal minimaps pertaining to object xy-locations, rather than human-rendered observations.

Section Title: WHAT HAPPENS IN OBSERVATION SPACE?
  WHAT HAPPENS IN OBSERVATION SPACE? Several artificial benchmarks (Zhang et al., 2018b; Gamrian & Goldberg, 2019) have been proposed before to portray this notion of overfitting, where an agent must deal with a changing background - however, a key difference in our work is that we explicitly require the "background" to be correlated with the progress rather than loosely correlated (e.g. through determinism between the background and the game avatar) or not at all. This makes a more explicit connection to causal inference (Arjovsky et al., 2019; Heinze-Deml & Meinshausen, 2019; Heinze-Deml et al., 2019) where spurious correlations between ungeneralizable features and progress may make training easy, but are detrimental to test performance because they induce false attributions. Previously, many works interpret the decision-making of an agent through saliency and other network visualizations (Greydanus et al., 2018; Such et al., 2018) on common benchmarks such as Atari. Other recent works such as (Igl et al., 2019) analyze the interactions between noise-injecting explicit regularizations and the information bottleneck. However, our work is motivated by learning theoretic frameworks to capture this phenomena, as there is vast literature on understanding the generalization properties of SL classifiers (Vapnik & Chervonenkis, 1971; McAllester, 1999; Bartlett & Mendelson, 2002) and in particular neural networks (Neyshabur et al., 2015b; Dziugaite & Roy, 2017; Neyshabur et al., 2017; Bartlett et al., 2017; Arora et al., 2018c). For an RL policy with high-dimensional observations, we hypothesize its overfitting can come from more theoretically principled reasons, as opposed to purely good inductive biases on game images. As an example of what may happen in high dimensional observation space, consider linear least squares regression task where given the set X ∈ R m×d and Y ∈ R m , we want to find w ∈ R d that minimizes X,Y (w) = Y − Xw 2 where m is the number of samples and d is the input dimension. We know that if X X is full rank (hence d ≤ m), X,Y (.) has a unique global minimum w * = (X X) −1 X Y . On the other hand if X X is not full rank (eg. when m < d), then there are many global minima w * such that Y = Xw * 1 . Luckily, if we use any gradient based optimization to minimize the loss and initialize with w = 0, the solution will only span column spaces of X and converges to minimum 2 norm solution among all global minima due to implicit regularization (Gunasekar et al., 2017). Thus a high dimensional observation space with a low dimensional state space can induce multiple solutions, some of which are not generalizable to other functions or MDP's but one could hope that implicit regularization would help avoiding this issue. We analyze this case in further detail for the convex one-step LQR case in Section 3.1 and Appendix A.4.3.

Section Title: NOTATION
  NOTATION In the zero-shot framework for RL generalization, we assume there exists a distribution D over MDP's M for which there exists a fixed policy π opt that can achieve maximal return on expectation over MDP's generated from the distribution. An appropriate finite training set M train = {M 1 , . . . , M n } can then be created by repeatedly randomly sampling M ∼ D. Thus for a MDP M and any policy π, expected episodic reward is defined as R M (π). In many empirical cases, the support of the distribution D is made by parametrized MDP's where some process, given a parameter θ, creates a mapping θ → M θ (e.g. through procedural generation), and thus we may simplify notation and instead define a distribution Θ that induces D, which implies a set of samples Θ train = {θ 1 , . . . , θ n } also induces a M train = {M 1 , . . . , M n }, and we may redefine reward as R M θ (π) = R θ (π). As a simplified model of the observational problem from Sonic, we can construct a mapping θ → M θ by first fixing a base MDP M = (S, A, r, T ), which corresponds to state space, action space, reward, and transition. The only effect of θ is to introduce an additional observation function φ θ : S → O, where the agent receives input from the high dimensional observation space O rather than from the state space S. Thus, for our setting, θ actually parameterizes a POMDP family which can be thought of as simply a combination of a base MDP M and an observational function φ θ , hence M θ = (M, φ θ ). Let Θ train = {θ 1 , . . . , θ n } be a set of n i.i.d. samples from Θ, and suppose we train π to optimize reward against {M θ : θ ∼ Θ train }. The objective J Θ (π) = 1 | Θtrain| θi∈ Θtrain R θi (π) is the average reward over this empirical sample. We want to generalize to the distribution Θ, which can be expressed as the average episode reward R over the full distribution, i.e. J Θ (π) = E θ∼Θ [R θ (π)]. Thus we define the generalization gap as J Θ (π) − J Θ (π).

Section Title: SETUP
  SETUP We can model the effects of  Figure 1  more generally, not specific to sidescroller games. We assume that there is an underlying state s (e.g. xy-locations of objects in a game), whose features may be very well structured, but that this state has been projected to a high dimensional observation space by φ θ . To abstract the notion of generalizable and non-generalizable features, we construct a simple and natural candidate class of functions, where In this setup, f (·) is a function invariant for the entire MDP population Θ, while g θ (·) is a function dependent on the sampled parameter θ. h is a "combination" function which combines the two outputs of f and g to produce a final observation. While f projects this latent data into salient and important, invariant features such as the avatar, monsters, and items, g θ projects the latent data to unimportant features that do not contribute to extra generalizable information, and can cause overfitting, such as the changing background or textures. A visual representation is shown in  Figure 2 . This is a simplified but still insightful model relevant in more realistic settings. For instance, in settings where g θ does matter, learning this separation and task-identification (Yu et al., 2017; Peng et al., 2018) could potentially help fast adaptation in meta-learning (Finn et al., 2017). From now on, we denote this setup as the (f, g)-scheme. This setting also leads to more interpretable generalization bounds - Lemma 2 of (Wang et al., 2019) provides a high probability (1 − δ) bound for the "intrinsic" generalization gap when m levels are sampled: gap ≤ Rad m (R Π ) + O log(1/δ) m , where Published as a conference paper at ICLR 2020 is the Rademacher Complexity under the MDP, where θ i are the ζ i parameters used in the original work, and the transition T and initialization I are fixed, therefore omitted, to accommodate our setting. The Rademacher Complexity term captures how invariant policies in the set Π with respect to θ. For most RL benchmarks, this is not interpretable due to multiple confounding factors such as the varying level dynamics. For instance, it is difficult to imagine what behaviors or network weights a policy would possess in order to produce the same total rewards, regardless of changing dynamics. However, in our case, because the environment parameters θ are only from g θ , the Rademacher Complexity is directly based on how much the policy "looks at" g θ . More formally, let Π * be the set of policies π * which are not be affected by changes in g θ ; i.e. ∇ θ π * (φ θ (s)) = 0 ∀s and thus R θ (π * ) = R const ∀θ, which implies that the environment parameter θ has no effect on the reward; hence

Section Title: ARCHITECTURE AND IMPLICIT REGULARIZATION
  ARCHITECTURE AND IMPLICIT REGULARIZATION Normally in a MDP such as a game, the concatenation operation may be dependent on time (e.g. textures move around in the frame). In the scope of this work, we simplify the concatenation effect and assume h(·) is a static concatenation, but still are able to demonstrate insightful properties. We note that this inductive bias on h allows explicit regularization to trivially solve this problem, by penalizing a policy's first layer that is used to "view" g θ (s) (Appendix A.1.1), hence we only focus on implicit regularizations. This setting is naturally attractive to analyzing architectural differences, as it is more closely related in spirit to image classifiers and SL. One particular line of work to explain the effects of certain architectural modifications in SL such as overparametrization and residual connections is implicit regularization (Neyshabur et al., 2015a; Gunasekar et al., 2017; Neyshabur, 2017), as overparametriza- tion through more layer depth and wider layers has proven to have no p -regularization equivalent (Arora et al., 2019), but rather precondition the dynamics during training. Thus, in order to fairly experimentally measure this effect, we always use fixed hyperparameters and only vary based on architecture. In this work, we only refer to architectural implicit regularization techniques, which do not have a explicit regularization equivalent. Some techniques e.g. coordinate descent (Bradley et al., 2011) are equivalent to explicit 1 -regularization.

Section Title: EXPERIMENTS
  EXPERIMENTS

Section Title: OVERPARAMTERIZED LQR
  OVERPARAMTERIZED LQR We first analyze the case of the LQR as a surrogate for what may occur in deep RL, which has been done before for various topics such as sample complexity (Dean et al., 2019) and model-based RL (Tu & Recht, 2019). This is analogous to analyzing linear/logistic regression (Kakade et al., 2008; McAllester, 2003) as a surrogate to understanding extensions to deep SL techniques (Neyshabur et al., 2018a; Bartlett et al., 2017). In particular, this has numerous benefits - the cost (negative of reward) function is deterministic, and allows exact gradient descent (i.e. the policy can differentiate through the cost function) as opposed to necessarily using stochastic gradients in normal RL, and thus can cleanly provide evidence of implicit regularization. Furthermore, in terms of gradient dynamics and optimization, LQR readily possesses nontrivial qualities compared to linear regression, as the LQR cost is a non-convex function but all of its minima are global minima (Fazel et al., 2018). To show that overparametrization alone is an important implicit regularizer in RL, LQR allows the use of linear policies (and consequently also allows stacking linear layers) without requiring a stochastic output such as discrete Gumbel-softmax or for the continuous case, a parametrized Gaussian. This is setting able to show that overparametrization alone can affect gradient dynamics, and is not a consequence of extra representation power due to additional non-linearities in the policy. There have been multiple recent works on this linear-layer stacking in SL and other theoretical problems such as matrix factorization and matrix completion (Arora et al., 2018b;a; Gunasekar et al., 2017), but to our knowledge, we are the first to analyze this case in the context of RL generalization.

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 We explicitly describe setup as follows: for a given θ, we let f (s) = W c · s, while g θ (s) = W θ · s where W c , W θ are semi-orthogonal matrices, to prevent information loss relevant to outputting the optimal action, as the state is transformed into the observation. Hence, if s t is the underlying state at time t, then the observation is o t = W c W θ s t and thus the action is a t = Ko t , where K is the policy matrix. While W c remains a constant matrix, we sample W θ randomly, using the "level ID" integer θ as the seed for random generation. In terms of dimensions, if s is of shape d state , then f also projects to a shape of d state , while g θ projects to a much larger shape d noise , implying that the observation to the agent is of dimension d signal + d noise . In our experiments, we set as default (d signal , d noise ) = (100, 1000). If P is the unique minimizer of the original cost function, then the unique minimizer of the population cost is K = W c P T 0 T . However, if we have a single level, then there exist multiple solutions, for instance αW c P T (1 − α)W θ P T T ∀α. This extra bottom component W θ P T causes overfitting. In Appendix A.4.3, we show that in the 1-step LQR case (which can be extended to convex losses whose gradients are linear in the input), gradient descent cannot remove this component, and thus overfitting necessarily occurs. Furthermore, we find that increasing d noise increases the generalization gap in the LQR setting. This is empirically verified in  Figure 3  using an actual non-convex LQR loss, and the results suggest that the gap scales by O( √ d noise ). In terms of overparametrization, we experimentally added more (100 × 100) linear layers K = K 0 K 1 , ..., K j and increased widths for a 2-layer case ( Figure 3 ), and observe that both settings reduce the generalization gap, and also reduce the norms (spectral, nuclear, Frobenius) of the final end-to-end policy K, without changing its expressiveness. This suggests that gradient descent under overparametrization implicitly biases the policy towards a "simpler" model in the LQR case. As a surrogate model for deep RL, one may ask if the generalization gap of the final end-to-end policy K can be predicted by functions of the layers K 0 , ..., K j . This is an important question as it is a required base case for predicting generalization when using stochastic policy gradient with nonlinear activations such as ReLU or Tanh. From examining the distribution of singular values on K (Appendix A.1.1), we find that more layers does not bias the policy towards a low rank solution in the nonconvex LQR case, unlike (Arora et al., 2018b) which shows this does occur for matrix completion, and in general, convex losses. Ultimately, we answer in the negative: intriguingly, SL bounds have very little predictive power in the RL domain case.

Section Title: Published as a conference paper at ICLR 2020
  Published as a conference paper at ICLR 2020 To understand why SL bounds may be candidates for the LQR case, we note that as a basic smoothness bound C(K) − C(K ) ≤ O( K − K ) (Appendix A.4) can lead to very similar reasoning with SL bounds. Since our setup is similar to SL in that "LQR levels" which may be interpreted as a dataset, we use bounds of the form ∆·Φ, where ∆ is a "macro" product term ∆ = j i=0 K i ≥ j i=0 K i derivable from the fact that AB ≤ A B in the linear case, and Φ is a weight-counting term which deals with the overparametrized case, such as Φ = j i=0 Ki 2 F Ki 2 (Neyshabur et al., 2018a) or Φ = j i=0 Ki 1 Ki 2/3 3 (Bartlett et al., 2017). However, the Φ terms increase too rapidly as shown in  Figure 3 . Terms such as Frobenius product (Golowich et al., 2018) and Fischer-Rao (Liang et al., 2019) are effective for the SL depth case, but are both ineffective in the LQR depth case. For width, the only product which is effective is the nuclear norm product.

Section Title: PROJECTED GYM ENVIRONMENTS
  PROJECTED GYM ENVIRONMENTS In Section 3.1, we find that observational overfitting exists and overparametrization potentially helps in the linear setting. In order to analyze the case when the underlying dynamics are nonlinear, we let M be a classic Gym environment and we generate a M θ = (M, w θ ) by performing the exact same (f, g)-scheme as the LQR case, i.e. sampling θ to produce an observation function w θ (s) = W c W θ s. We again can produce training/test sets of MDPs by repeatedly sampling θ, and for policy optimization, we use Proximal Policy Gradient (Schulman et al., 2017). Although bounds on the smoothness term R θ (π) − R θ (π ) affects upper bounds on Rademacher Complexity (and thus generalization bounds), we have no such theoretical guarantees in the Mujoco case as it is difficult to analyze the smoothness term for complicated transitions such as Mujoco's physics simulator. However, in  Figure 4 , we can observe empirically that the underlying state dynamics has a significant effect on generalization performance as the policy nontrivially increased test performance such as in CartPole-v1 and Swimmer-v2, while it could not for others. This suggests that the Rademacher complexity and smoothness on the reward function vary highly for different environments. Even though it is common practice to use basic (2-layer) MLPs in these classic benchmarks, there are highly nontrivial generalization effects from modifying on this class of architectures. Our results in  Figures 5  and 6 show that increasing width and depth for basic MLPs can increase generalization and is significantly dependent on the choice of activation, and other implicit regularizations such as using residual layers can also improve generalization. Specifically, switching between ReLU and Tanh activations produces different results during overparametrization. For instance, increasing Tanh layers improves generalization on CartPole-v1, and width increase with ReLU helps on Swimmer-v2. Tanh is noted to consistently improve generalization performance. However, stacking Tanh layers comes at a cost of also producing vanishing gradients which can produce subpar training performance, for e.g. HalfCheetah. To allow larger depths, we use ReLU residual layers, which also improves generalization and stabilizes training. Previous work (Zhang et al., 2018c) did not find such an architectural pattern for GridWorld environ- ments, suggesting that this effect may exist primarily for observational overfitting cases. While there have been numerous works which avoid overparametrization on simplifying policies (Rajeswaran et al., 2017; Mania et al., 2018) or compactifying networks (Choromanski et al., 2018; Gaier & Ha, 2019), we instead find that there are generalization benefits to overparametrization even in the nonlinear control case.

Section Title: DECONVOLUTIONAL PROJECTIONS
  DECONVOLUTIONAL PROJECTIONS From the above results with MLPs, one may wonder if similar results may carry to convolutional networks, as they are widely used for vision-based RL tasks. As a ground truth reference for our experiment, we the canonical networks proven to generalize well in the dataset CoinRun, which are from worst to best, NatureCNN Mnih et al. (2013), IMPALA Espeholt et al. (2018), and IMPALA- LARGE (IMPALA with more residual blocks and higher convolution depths), which have respective parameter numbers (600K, 622K, 823K). We setup a similar (f, g)-scheme appropriate for the inductive bias of convolutions, by passing the vanilla Gym 1D state corresponding to joint locations and velocities, through multiple deconvolutions. We do so rather than using the RGB image from env.render() to enforce that the actual state is indeed low dimensional and minimize complications in experimentation, as e.g. inference of velocity information would require frame-stacking. Specifically in our setup, we project the actual state to a fixed length, reshaping it into a square, and replacing f and g θ both with the same orthogonally-initialized deconvolution architecture to each produce a 84 × 84 image (but g θ 's network weights are still generated by θ 1 , ..., θ m similar to before). We combine the two outputs by using one half of the "image" from f , and one half from g θ , as shown back in  Figure 2 .  Figure 7  shows that the same ranking between the three architectures exists as well on the Gym- Deconv dataset. We show that generalization ranking among NatureCNN/IMPALA/IMPALA- LARGE remains the same regardless of whether we use our synthetic constructions or CoinRun. This suggests that the RL generalization quality of a convolutional architecture is not limited to real world data, as our test purely uses numeric observations, which are not based on a human-prior. From these findings, one may conjecture that these RL generalization performances are highly correlated and may be due to common factors. One of these factors we suggest is due to implicit regularization. In order to support this claim, we perform a memorization test by only showing g θ 's output to the policy. This makes the dataset impossible to generalize to, as the policy network cannot invert every single observation function {g θ1 (·), g θ2 (·), ..., g θn (·)} simultaneously. Zhang et al. (2018c) also constructs a memorization test for mazes and grid-worlds, and showed that more parameters increased the memorization ability of the policy. While it is intuitive that more parameters would incur more memorization, we show in  Figure 8  that this is perhaps not a complete picture when implicit regularization is involved. Using the underlying MDP as a Swimmer-v2 environment, we see that NatureCNN, IMPALA, IMPALA-LARGE have reduced memorization performances. IMPALA-LARGE, which has more depth parameters and more residual layers (and thus technically has more capacity), memorizes less than IMPALA due its inherent inductive bias. While memorization performance is dampened in 8, we perform another deconvolution memorization test using an LQR as the underlying MDP in Appendix A.1.1 that shows that there can exist specific hard limits to memorization, which also follows the same ranking above.

Section Title: OVERPARAMETRIZATION IN COINRUN
  OVERPARAMETRIZATION IN COINRUN We further test our overparametrization hypothesis from Sections 3.1, 3.2 to the CoinRun benchmark, using unlimited levels for training. For MLP networks, we downsized CoinRun from native 64 × 64 to 32 × 32, and flattened the 32 × 32 × 3 image for input to an MLP. Two significant differences from the synthetic cases are that 1. Inherent dynamics are changing per level in CoinRun, and 2. The relevant and irrelevant CoinRun features change locations across the 1-D input vector. Regardless, in  Figure 9 , we show that overparametrization can still improve generalization in this more realistic RL benchmark, much akin to (Neyshabur et al., 2018b) which showed that overparametrization for MLP's improved generalization on 32 × 32 × 3 CIFAR-10.

Section Title: CONCLUSION
  CONCLUSION We have identified and isolated a key component of overfitting in RL as the particular case of "obser- vational overfitting", which is particularly attractive for studying architectural implicit regularizations. We have analyzed this setting extensively, by examining 3 main components: 1. The analytical case of LQR and linear policies under exact gradient descent, which lays the foundation for understanding theoretical properties of networks in RL generalization. 2. The empirical but principled Projected-Gym case for both MLP and convolutional networks which demonstrates the effects of neural network policies under nonlinear environments. 3. The large scale case for CoinRun, which can be interpreted as a case where relevant features are moving across the input, where empirically, MLP overparametrization also improves generalization. We noted that current network policy bounds using ideas from SL are unable to explain over- parametrization effects in RL, which is an important further direction. In some sense, this area of RL generalization is an extension of static SL classification from adding extra RL components. For instance, adding a nontrivial "combination function" between f and g θ that is dependent on time (to simulate how object pixels move in a real game) is both an RL generalization issue and potentially video classification issue, and extending results to the memory-based RNN case will also be highly beneficial. Furthermore, it is unclear whether such overparametrization effects would occur in off-policy methods such as Q-learning and also ES-based methods. In terms of architectural design, recent works (Jacot et al., 2018; Garriga-Alonso et al., 2019; Lee et al., 2019) have shed light on the properties of asymptotically overparametrized neural networks in the infinite width and depth cases and their performance in SL. Potentially such architectures (and a corresponding training algorithm) may be used in the RL setting which can possibly provide benefits, one of which is generalization as shown in this paper. We believe that this work provides an important initial step towards solving these future problems.

```
