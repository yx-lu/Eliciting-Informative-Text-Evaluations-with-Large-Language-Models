Title:
```
Under review as a conference paper at ICLR 2020 STOCHASTIC LATENT ACTOR-CRITIC: DEEP REINFORCEMENT LEARNING WITH A LATENT VARIABLE MODEL
```
Abstract:
```
Deep reinforcement learning (RL) algorithms can use high-capacity deep networks to learn directly from image observations. However, these kinds of observation spaces present a number of challenges in practice, since the policy must now solve two problems: a representation learning problem, and a task learning problem. In this paper, we aim to explicitly learn representations that can accelerate re- inforcement learning from images. We propose the stochastic latent actor-critic (SLAC) algorithm: a sample-efficient and high-performing RL algorithm for learn- ing policies for complex continuous control tasks directly from high-dimensional image inputs. SLAC learns a compact latent representation space using a stochas- tic sequential latent variable model, and then learns a critic model within this latent space. By learning a critic within a compact state space, SLAC can learn much more efficiently than standard RL methods. The proposed model improves performance substantially over alternative representations as well, such as vari- ational autoencoders. In fact, our experimental evaluation demonstrates that the sample efficiency of our resulting method is comparable to that of model-based RL methods that directly use a similar type of model for control. Furthermore, our method outperforms both model-free and model-based alternatives in terms of final performance and sample efficiency, on a range of difficult image-based control tasks. Our code and videos of our results are available at our website. 1 1 https://rl-slac.github.io/slac/
```

Figures/Tables Captions:
```
Figure 1: Graphical model of POMDP with optimality variables for t ≥ τ + 1.
Figure 2: Diagram of our full model. Solid arrows show the generative model, dashed arrows show the inference model. Rewards are not shown for clarity.
Figure 3: Example image observations for our continuous control benchmark tasks: DeepMind Control's cheetah run, walker walk, ball-in-cup catch, and finger spin, and OpenAI Gym's half cheetah, walker, hopper, and ant (left to right). Images are rendered at a resolution of 64 × 64 pixels.
Figure 4: Experiments on the DeepMind Control Suite from images (unless otherwise labeled as "state"). SLAC (ours) converges to similar or better final performance than the other methods, while almost always achieving reward as high as the upper bound SAC baseline that learns from true state. Note that for these experiments, 1000 environments steps corresponds to 1 episode.
Figure 5: Experiments on the OpenAI Gym benchmark tasks from images. SLAC (ours) converges to higher performance than both PlaNet and SAC on all four of these tasks. The number of environments steps in each episode is variable, depending on the termination.
Figure 6: Comparison of differ- ent design choices for the latent variable model.
Figure 7: Example image sequence seen for the cheetah task (first row), corresponding posterior sample (reconstruction) from our model (second row), and generated prediction from the generative model (last two rows). The second to last row is conditioned on the first frame (i.e., the posterior model is used for the first time step while the prior model is used for all subsequent steps), whereas the last row is not conditioned on any ground truth images. Note that all of these sampled sequences are conditioned on the same action sequence, and that our model produces highly realistic samples, even when predicting via the generative model.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Deep reinforcement learning (RL) algorithms can automatically learn to solve certain tasks from raw, low-level observations such as images. However, these kinds of observation spaces present a number of challenges in practice: on one hand, it is difficult to directly learn from these high-dimensional inputs, but on the other hand, it is also difficult to tease out a compact representation of the underlying task-relevant information from which to learn instead. For these reasons, deep RL directly from low-level observations such as images remains a challenging problem. Particularly in continuous domains governed by complex dynamics, such as robotic control (Tassa et al., 2018; Brockman et al., 2016), standard approaches still require separate sensor setups to monitor details of interest in the environment, such as the joint positions of a robot or specific pose information of objects of interest. To instead be able to learn directly from the more general and rich modality of vision would greatly advance the current state of our learning systems, so we aim to study precisely this. Standard model-free deep RL aims to use direct end-to-end training to explicitly unify these tasks of representation learning and task learning. However, solving both problems together is difficult, since an effective policy requires an effective representation, but in order for an effective representation to emerge, the policy or value function must provide meaningful gradient information using only the model-free supervision signal (i.e., the reward function). In practice, learning directly from images with standard RL algorithms can be slow, sensitive to hyperparameters, and inefficient. In contrast to end-to-end learning with RL, predictive learning can benefit from a rich and informative supervision signal before the agent has even made progress on the task or received any rewards. This leads us to ask: can we explicitly learn a latent representation from raw low-level observations that makes deep RL easier, through learning a predictive latent variable model?

Section Title: Under review as a conference paper at ICLR 2020
  Under review as a conference paper at ICLR 2020 Predictive models are commonly used in model-based RL for the purpose of planning (Deisenroth & Rasmussen, 2011; Finn & Levine, 2017; Nagabandi et al., 2018; Chua et al., 2018; Zhang et al., 2019) or generating cheap synthetic experience for RL to reduce the required amount of interaction with the real environment (Sutton, 1991; Gu et al., 2016). However, in this work, we are primarily concerned with their potential to alleviate the representation learning challenge in RL. We devise a stochastic predictive model by modeling the high-dimensional observations as the consequence of a latent process, with a Gaussian prior and latent dynamics, as illustrated in  Figure 1 . A model with an entirely stochastic latent state has the appealing interpretation of being able to properly represent uncertainty about any of the state variables, given its past observations. We demonstrate in our work that fully stochastic state space models can in fact be learned effectively: With a well-designed stochastic network, such models outperform fully deterministic models, and contrary to the observations in prior work (Hafner et al., 2019; Buesing et al., 2018), are actually comparable to partially stochastic models. Finally, we note that this explicit representation learning, even on low-reward data, allows an agent with such a model to make progress on representation learning even before it makes progress on task learning. Equipped with this model, we can then perform RL in the learned latent space of the predictive model. We posit-and confirm experimentally-that our latent variable model provides a useful representation for RL. Our model represents a partially observed Markov decision process (POMDP), and solving such a POMDP exactly would be computationally intractable (Astrom, 1965; Kaelbling et al., 1998; Igl et al., 2018). We instead propose a simple approximation that trains a Markovian critic on the (stochastic) latent state and trains an actor on a history of observations and actions. The resulting stochastic latent actor-critic (SLAC) algorithm loses some of the benefits of full POMDP solvers, but it is easy and stable to train. It also produces good results, in practice, on a range of challenging problems, making it an appealing alternative to more complex POMDP solution methods. The main contributions of our SLAC algorithm are useful representations learned from our stochastic sequential latent variable model, as well as effective RL in this learned latent space. We show experimentally that our approach substantially improves on both model-free and model-based RL algorithms on a range of image-based continuous control benchmark tasks, attaining better final performance and learning more quickly than algorithms based on (a) end-to-end deep RL from images, (b) learning in a latent space produced by various alternative latent variable models, such as a variational autoencoder (VAE) (Kingma & Welling, 2014), and (c) model-based RL based on latent state-space models with partially stochastic variables (Hafner et al., 2019).

Section Title: RELATED WORK
  RELATED WORK Representation learning in RL. End-to-end deep RL can in principle learn representations directly as part of the RL process (Mnih et al., 2013). However, prior work has observed that RL has a "representation learning bottleneck": a considerable portion of the learning period must be spent acquiring good representations of the observation space (Shelhamer et al., 2016). This motivates the use of a distinct representation learning procedure to acquire these representations before the agent has even learned to solve the task. The use of auxiliary supervision in RL to learn such representations has been explored in a number of prior works (Lange & Riedmiller, 2010; Finn et al., 2016; Jaderberg et al., 2017; Higgins et al., 2017; Ha & Schmidhuber, 2018; Nair et al., 2018; Oord et al., 2018; Gelada et al., 2019; Dadashi et al., 2019). In contrast to this class of representation learning algorithms, we explicitly learn a latent variable model of the POMDP, in which the latent representation and latent-space dynamics are jointly learned. By modeling covariances between consecutive latent states, we make it feasible for our proposed algorithm to perform Bellman backups directly in the latent space of the learned model.

Section Title: Partial observability in RL
  Partial observability in RL Our work is also related to prior research on RL under partial observ- ability. Prior work has studied exact and approximate solutions to POMDPs, but they require explicit models of the POMDP and are only practical for simpler domains (Kaelbling et al., 1998). Recent work has proposed end-to-end RL methods that use recurrent neural networks to process histories of observations and (sometimes) actions, but without constructing a model of the POMDP (Hausknecht & Stone, 2015; Foerster et al., 2016; Zhu et al., 2018). Other works, however, learn latent-space dynamical system models and then use them to solve the POMDP with model-based RL (Watter et al., 2015; Wahlström et al., 2015; Karl et al., 2017; Zhang et al., 2019; Hafner et al., 2019).

Section Title: Under review as a conference paper at ICLR 2020
  Under review as a conference paper at ICLR 2020 Although some of these works learn latent variable models that are similar to ours, these model-based methods are often limited by compounding model errors and finite horizon optimization. In contrast to these works, our approach does not use the model for prediction and performs infinite horizon policy optimization. Our approach benefits from the good asymptotic performance of model-free RL, while at the same time leveraging the improved latent space representation for sample efficiency. Other works have also trained latent variable models and used their representations as the inputs to model-free RL algorithms. They use representations encoded from latent states sampled from the forward model (Buesing et al., 2018), belief representations obtained from particle filtering (Igl et al., 2018), or belief representations obtained directly from a learned belief-space forward model (Gregor et al., 2019). Our approach is closely related to these prior methods, in that we also use model-free RL with a latent state representation that is learned via prediction. However, instead of using belief representations, our method learns a critic directly on latent states samples.

Section Title: Sequential latent variable models
  Sequential latent variable models Several previous works have explored various modeling choices to learn stochastic sequential models (Krishnan et al., 2015; Archer et al., 2015; Karl et al., 2016; Fraccaro et al., 2016; 2017; Doerr et al., 2018a). In the context of using sequential models for RL, previous works have typically observed that partially stochastic state space models are more effective than fully stochastic ones (Buesing et al., 2018; Igl et al., 2018; Hafner et al., 2019). In these models, the state of the underlying MDP is modeled with the deterministic state of a recurrent network (e.g., LSTM (Hochreiter & Schmidhuber, 1997) or GRU (Cho et al., 2014)), and optionally with some stochastic random variables. As mentioned earlier, a model with a latent state that is entirely stochastic has the appealing interpretation of learning a representation that can properly represent uncertainty about any of the state variables, given past observations. We demonstrate in our work that fully stochastic state space models can in fact be learned effectively and, with a well-designed stochastic network, such models perform on par to partially stochastic models and outperform fully deterministic models.

Section Title: REINFORCEMENT LEARNING AND MODELING
  REINFORCEMENT LEARNING AND MODELING This work addresses the problem of learning maximum entropy policies from high-dimensional observations in POMDPs, by simultaneously learning a latent representation of the underlying MDP state using variational inference and learning the policy in a maximum entropy RL framework. In this section, we describe maximum entropy RL (Ziebart, 2010; Haarnoja et al., 2018a; Levine, 2018) in fully observable MDPs, as well as variational methods for training latent state space models for POMDPs.

Section Title: MAXIMUM ENTROPY RL IN FULLY OBSERVABLE MDPS
  MAXIMUM ENTROPY RL IN FULLY OBSERVABLE MDPS In a Markov decision process (MDP), an agent at time t takes an action a t ∈ A from state s t ∈ S and reaches the next state s t+1 ∈ S according to some stochastic transition dynamics p(s t+1 |s t , a t ). The initial state s 1 comes from a distribution p(s 1 ), and the agent receives a reward r t on each of the transitions. Standard RL aims to learn the parameters φ of some policy π φ (a t |s t ) such that the expected sum of rewards is maximized under the induced trajectory distribution ρ π . This objective can be modified to incorporate an entropy term, such that the policy also aims to maximize the expected entropy H(π φ (·|s t )) under the induced trajectory distribution ρ π . This formulation has a close connection to variational inference (Ziebart, 2010; Haarnoja et al., 2018a; Levine, 2018), and we build on this in our work. The resulting maximum entropy objective is φ * = arg max φ T t=1 E (st,at)∼ρπ [r(s t , a t ) + αH(π φ (·|s t ))], (1) where r is the reward function, and α is a temperature parameter that controls the trade-off between optimizing for the reward and for the entropy (i.e., stochasticity) of the policy. Soft actor-critic (SAC) (Haarnoja et al., 2018a) uses this maximum entropy RL framework to derive soft policy iteration, which alternates between policy evaluation and policy improvement within the described maximum entropy framework. SAC then extends this soft policy iteration to handle continuous action spaces by using parameterized function approximators to represent both the Q-function Q θ (critic) and the policy π φ (actor). The soft Q-function parameters θ are optimized to minimize the Under review as a conference paper at ICLR 2020 soft Bellman residual, where D is the replay buffer, γ is the discount factor, andθ are delayed parameters. The policy parameters φ are optimized to update the policy towards the exponential of the soft Q-function, Results of this stochastic, entropy maximizing RL framework demonstrate improved robustness and stability. SAC also shows the sample efficiency benefits of an off-policy learning algorithm, in conjunction with the high performance benefits of a long-horizon planning algorithm. Precisely for these reasons, we choose to extend the SAC algorithm in this work to formulate our SLAC algorithm.

Section Title: SEQUENTIAL LATENT VARIABLE MODELS AND AMORTIZED VARIATIONAL INFERENCE IN POMDPS
  SEQUENTIAL LATENT VARIABLE MODELS AND AMORTIZED VARIATIONAL INFERENCE IN POMDPS To learn representations for RL, we use latent variable models trained with amortized variational inference. The learned model must be able to process a large number of pixels that are present in the entangled image x, and it must tease out the relevant information into a compact and disentangled representation z. To learn such a model, we can consider maximizing the probability of each observed datapoint x from some training set D under the entire generative process p(x) = p(x|z)p(z) dz. This objective is intractable to compute in general due to the marginalization of the latent variables z. In amortized variational inference, we utilize the following bound on the log-likelihood (Kingma & Welling, 2014), We can maximize the probability of the observed datapoints (i.e., the left hand side of Equation (5)) by learning an encoder q(z|x) and a decoder p(x|z), and then directly performing gradient ascent on the right hand side of the equation. In this setup, the distributions of interest are the prior p(z), the observation model p(x|z), and the posterior q(z|x). Although such generative models have been shown to successfully model various types of complex distributions (Kingma & Welling, 2014) by embedding knowledge of the distribution into an informa- tive latent space, they do not have a built-in mechanism for the use of temporal information when performing inference. In the case of partially observable environments, as we discuss below, the representative latent state z t corresponding to a given non-Markovian observation x t needs to be informed by past observations. Consider a partially observable MDP (POMDP), where an action a t ∈ A from latent state z t ∈ Z results in latent state z t+1 ∈ Z and emits a corresponding observation x t+1 ∈ X . We make an explicit distinction between an observation x t and the underlying latent state z t , to emphasize that the latter is unobserved and the distribution is not known a priori. Analogous to the fully observable MDP, the initial state distribution is p(z 1 ), the transition probability distribution is p(z t+1 |z t , a t ), and the reward is r t . In addition, the observation model is given by p(x t |z t ). As in the case for VAEs, a generative model of these observations x t can be learned by maximizing the log-likelihood. In the POMDP setting, however, we note that x t alone does not provide all necessary information to infer z t , and thus, prior temporal information must be taken into account. This brings us to the discussion of sequential latent variable models. The distributions of interest are the priors p(z 1 ) and p(z t+1 |z t , a t ), the observation model p(x t |z t ), and the approximate posteriors q(z 1 |x 1 ) and q(z t+1 |x t+1 , z t , a t ). The log-likehood of the observations can then be bounded, similarly to the VAE bound in Equation (5), as Under review as a conference paper at ICLR 2020 Prior work (Hafner et al., 2019; Buesing et al., 2018; Doerr et al., 2018b) has explored modeling such non-Markovian observation sequences, using methods such as recurrent neural networks with deterministic hidden state, as well as probabilistic state-space models. In this work, we enable the effective training of a fully stochastic sequential latent variable model, and bring it together with a maximum entropy actor-critic RL algorithm to create SLAC: a sample-efficient and high- performing RL algorithm for learning policies for complex continuous control tasks directly from high-dimensional image inputs.

Section Title: JOINT MODELING AND CONTROL AS INFERENCE
  JOINT MODELING AND CONTROL AS INFERENCE Our method aims to learn maximum entropy policies from high-dimensional, non-Markovian observations in a POMDP, while also learning a model of that POMDP. The model alleviates the representation learning problem, which in turn helps with the policy learning problem. We formulate the control problem as inference in a proba- bilistic graphical model with latent variables, as shown in  Figure 1 . For a fully observable MDP, the control problem can be embedded into a graphical model by introducing a bi- nary random variable O t , which indicates if time step t is optimal. When its distribution is chosen to be p(O t = 1|s t , a t ) = exp(r(s t , a t )), then maximization of p(O 1:T ) via approximate inference in that model yields the optimal policy for the maximum entropy objective (Levine, 2018). In a POMDP setting, the distribution can analogously be given by p(O t = 1|z t , a t ) = exp(r(z t , a t )). Instead of maximizing the likelihood of the optimality variables alone, we jointly model the observa- tions (including the observed rewards of the past time steps) and learn maximum entropy policies by maximizing the marginal likelihood p(x 1:τ +1 , O τ +1:T |a 1:τ ). This objective represents both the likelihood of the observed data from the past τ steps, as well as the optimality of the agent's actions for future steps. We factorize our variational distribution into a product of recognition terms q(z 1 |x 1 ) and q(z t+1 |x t+1 , z t , a t ), dynamics terms p(z t+1 |z t , a t ), and policy terms π(a t |z t ): The variational distribution uses the dynamics for future time steps to prevent the agent from controlling the transitions and from choosing optimistic actions (Levine, 2018). The posterior over the actions represents the agent's policy π. Although this derivation uses a policy that is conditioned on the latent state, our algorithm, which will be described in the next section, learns a parametric policy that is directly conditioned on observations and actions. This approximation allows us to directly execute the policy without having to perform inference on the latent state at run time. We use the posterior from Equation (7) to obtain the evidence lower bound (ELBO) of the marginal likelihood, where p(a t ) is the action prior. The full derivation of the ELBO is given in Appendix A. This derivation assumes that the reward function, which determines p(O t |z t , a t ), is known. However, in many RL problems, this is not the case. In that situation, we can simply append the reward to the Under review as a conference paper at ICLR 2020 observation, and learn the reward along with p(x t |z t ). This requires no modification to our method other than changing the observation space, and we use this approach in all of our experiments. We do this to learn latent representations that are more relevant to the task, but we do not use predictions from it. Instead, the RL objective uses rewards from the agent's experience, as in model-free RL.

Section Title: STOCHASTIC LATENT ACTOR CRITIC
  STOCHASTIC LATENT ACTOR CRITIC We now describe our stochastic latent actor critic (SLAC) algorithm, which approximately maximizes the ELBO using function approximators to model the prior and posterior distributions. The ELBO objective in Equation (8) can be split into a model objective and a maximum entropy RL objective. The model objective can directly be optimized, while the maximum entropy RL objective can be solved via message passing. We can learn Q-functions for the messages, and then we can rewrite the RL objective to express it in terms of these messages. Additional details of the derivation of the SLAC objectives are given in Appendix A.

Section Title: Latent Variable Model
  Latent Variable Model The first part of the ELBO corresponds to training the latent variable model to maximize the likelihood of the observations, analogous to the ELBO in Equation (6) for the sequential latent variable model. The distributions of the latent variable model are diagonal Gaussian distributions, where the means and variances are outputs of neural networks. The distribution parameters ψ of this model are optimized to maximize the first part of the ELBO. The model loss is We use the reparameterization trick to sample from the filtering distribution q ψ (z 1:τ +1 |x 1:τ +1 , a 1:τ ).

Section Title: Critic and Actor
  Critic and Actor The second part of the ELBO corresponds to the maximum entropy RL objective. As in the fully observable case from Section 3.1 and as described by Levine (2018), this optimization can be solved via message passing of soft Q-values, except that we use the latent states z rather than the true states s. For continuous state and action spaces, this message passing is approximated by minimizing the soft Bellman residual, which we use to train our soft Q-function parameters θ, whereθ are delayed parameters, obtained as exponential moving averages of θ. Notice that the latents z τ and z τ +1 , which are used in the Bellman backup, are sampled from the same joint, i.e. z τ +1 ∼ q ψ (z τ +1 |x τ +1 , z τ , a τ ). The RL objective, which corresponds to the second part of the ELBO, can be rewritten in terms of the soft Q-function. The policy parameters φ are optimized to maximize this objective, analogously to soft actor-critic (Haarnoja et al., 2018a). The policy loss is then We assume a uniform action prior, so p(a t ) is a constant term that we omit from the policy loss. We use the reparameterization trick to sample from the policy, and the policy loss only uses the last sample z τ +1 of the sequence for the critic. Although the policy used in our derivation is conditioned in the latent state, our learned parametric policy is conditioned directly on the past observations and actions, so that the learned policy can be executed at run time without requiring inference of the latent state. Finally, we note that for the expectation over latent states in the Bellman residual in Equation (10), rather than sampling latent states z ∼ Z, we sample latent states from the filtering distribution q ψ (z 1:τ +1 |x 1:τ +1 , a 1:τ ). This design choice allows us to minimize the critic loss for samples that are most relevant for Q, while also allowing the critic loss to use the Q-function in the same way as implied by the policy loss in Equation (11). Under review as a conference paper at ICLR 2020 SLAC is outlined in Algorithm 1. The actor-critic component follows prior work, with automatic tuning of the temperature α and two Q-functions to mitigate underestimation (Fujimoto et al., 2018; Haarnoja et al., 2018a;b). SLAC can be viewed as a variant of SAC (Haarnoja et al., 2018a) where the critic is trained on the stochastic latent state of our sequential latent variable model. The backup for the critic is performed on a tuple (z τ , a τ , r τ , z τ +1 ), sampled from the posterior q(z τ +1 , z τ |x 1:τ +1 , a 1:τ ). The critic can, in principle, take advantage of the perfect knowledge of the state z t , which makes learning easier. However, the parametric policy does not have access to z t , and must make decisions based on a history of observations and actions. SLAC is not a model-based algorithm, in that in does not use the model for prediction, but we see in our experiments that SLAC can achieve similar sample efficiency as a model-based algorithm. Store the transition in the replay buffer for each gradient step do Update target critic network weights

Section Title: LATENT VARIABLE MODEL
  LATENT VARIABLE MODEL We briefly summarize our full model architecture here, with full details in Appendix B. Motivated by the recent success of autoregressive latent variables in VAEs (Razavi et al., 2019; Maaloe et al., 2019), we factorize the latent variable z t into two stochastic layers, z 1 t and z 2 t , as shown in  Figure 2 . This factorization results in latent distributions that are more expressive, and it allows for some parts of the prior and posterior distributions to be shared. We found this design to produce high quality reconstructions and samples, and utilize it in all of our experiments. The generative model p and the inference model q are given by Note that we choose the variational distribution q over z 2 t to be the same as the model p. Thus, the KL divergence in J M simplifies to the divergence be- tween q and p over z 1 t . We use a multivariate standard normal distribution for p(z 1 1 ), since it is not condi- tioned on any variables, i.e. z 1 1 ∼ N (0, I). The conditional distributions of our model are diagonal Gaussian, with means and variances given by neural networks. Unlike models from prior work (Hafner et al., 2019; Buesing et al., 2018; Doerr et al., 2018b), which have deterministic and stochastic paths and use recurrent neural networks, ours is fully stochastic, i.e. our latent state is a Markovian latent random variable formed by the concatenation of z 1 t and z 2 t . Further details are discussed in Appendix B.

Section Title: EXPERIMENTAL EVALUATION
  EXPERIMENTAL EVALUATION We evaluate SLAC on numerous image-based continuous control tasks from both the DeepMind Control Suite (Tassa et al., 2018) and OpenAI Gym (Brockman et al., 2016), as illustrated in  Figure 3 . Full details of SLAC's network architecture are described in Appendix B. Aside from the value of action repeats (i.e. control frequency) for the tasks, we kept all of SLAC's hyperparameters constant across all tasks in all domains. Training and evaluation details are given in Appendix C, and image samples from our model for all tasks are shown in Appendix D. Additionally, visualizations of our results and code are available on the project website.

Section Title: COMPARATIVE EVALUATION ON CONTINUOUS CONTROL BENCHMARK TASKS
  COMPARATIVE EVALUATION ON CONTINUOUS CONTROL BENCHMARK TASKS To provide a comparative evaluation against prior methods, we evaluate SLAC on four tasks (cheetah run, walker walk, ball-in-cup catch, finger spin) from the DeepMind Control Suite (Tassa et al., 2018), and four tasks (cheetah, walker, ant, hopper) from OpenAI Gym (Brockman et al., 2016). Note that the Gym tasks are typically used with low-dimensional state observations, while we evaluate on them with raw image observations. We compare our method to the following state-of-the-art model-based and model-free algorithms: SAC (Haarnoja et al., 2018a): This is an off-policy actor-critic algorithm, which represents a comparison to state-of-the-art model-free learning. We include experiments showing the performance of SAC based on true state (as an upper bound on performance) as well as directly from raw images. MPO (Abdolmaleki et al., 2018b;a): This is an off-policy actor-critic algorithm that performs an expectation maximization form of policy iteration, learning directly from raw images. D4PG (Barth-Maron et al., 2018): This is also an off-policy actor-critic algorithm, learning directly from raw images. The results reported in the plots below are the performance after 10 8 training steps, as stated in the benchmarks from (Tassa et al., 2018). PlaNet (Hafner et al., 2019): This is a model-based RL method for learning from images, which uses a partially stochastic sequential latent variable model, but without explicit policy learning. Instead, the model is used for planning with model predictive control (MPC), where each plan is optimized with the cross entropy method (CEM). DVRL (Igl et al., 2018): This is an on-policy model-free RL algorithm that also trains a partially stochastic latent-variable POMDP model. DVRL uses the full belief over the latent state as input into both the actor and critic, as opposed to our method, which trains the critic with the latent state and the actor with a history of actions and observations. Our experiments on the DeepMind Control Suite in  Figure 4  show that the sample efficiency of SLAC is comparable or better than both model-based and model-free alternatives. This indicates that overcoming the representation learning bottleneck, coupled with efficient off-policy RL, provides for fast learning similar to model-based methods, while attaining final performance comparable to fully model-free techniques that learn from state. SLAC also substantially outperforms DVRL. This difference can be explained in part by the use of an efficient off-policy RL algorithm, which can better take advantage of the learned representation. We also evaluate SLAC on continuous control benchmark tasks from OpenAI Gym in  Figure 5 . We notice that these tasks are much more challenging than the DeepMind Control Suite tasks, because the rewards are not as shaped and not bounded between 0 and 1, the dynamics are different, and the episodes terminate on failure (e.g., when the hopper or walker falls over). PlaNet is unable to solve the last three tasks, while for the cheetah task, it learns a suboptimal policy that involves flipping the cheetah over and pushing forward while on its back. To better understand the performance of fixed-horizon MPC on these tasks, we also evaluated with the ground truth dynamics (i.e., the true simulator), and found that even in this case, MPC did not achieve good final performance, suggesting that infinite horizon policy optimization, of the sort performed by SLAC and model-free algorithms, is important to attain good results on these tasks. Our experiments show that SLAC successfully learns complex continuous control benchmark tasks from raw image inputs. On the DeepMind Control Suite, SLAC exceeds the performance of PlaNet on three of the tasks, and matches its performance on the walker task. However, on the harder image-based OpenAI Gym tasks, SLAC outperforms PlaNet by a large margin. In both domains, SLAC substantially outperforms all prior model-free methods. We note that the prior methods that we tested generally performed poorly on the image-based OpenAI Gym tasks, despite considerable hyperparameter tuning. We next study the tradeoffs between different design choices for the latent variable model. We compare our fully stochastic model, as described in Section 6, to a standard non-sequential VAE model (Kingma & Welling, 2014), which has been used in multi- ple prior works for representation learning in RL (Higgins et al., 2017; Ha & Schmidhuber, 2018; Nair et al., 2018), the partially stochastic model used by PlaNet (Hafner et al., 2019), as well as three variants of our model: a simple filtering model that does not factorize the latent variable into two layers of stochastic units, a fully deterministic model that removes all stochasticity from the hidden state dynamics, and a partially stochastic model that has both deterministic and stochastic transitions, similar to the PlaNet model, but with our architecture. Both the fully deterministic and partially stochastic models use the same architecture as our fully stochastic model, including the same two-level factorization of the latent variable. In all cases, we use the RL framework of SLAC and only vary the choice of model for representation learning. As shown in the comparison in  Figure 6 , our fully stochastic model outperforms prior models as well as the deterministic and simple variants Under review as a conference paper at ICLR 2020 Cheetah run Ground Truth Posterior Sample Conditional Prior Sample Prior Sample of our own model. The partially stochastic variant of our model matches the performance of our fully stochastic model but, contrary to the conclusions in prior work (Hafner et al., 2019; Buesing et al., 2018), the fully stochastic model performs on par, while retaining the appealing interpretation of a stochastic state space model. We hypothesize that these prior works benefit from the deterministic paths (realized as an LSTM or GRU) because they use multi-step samples from the prior. In contrast, our method uses samples from the posterior, which are conditioned on same-step observations, and thus these latent samples are less sensitive to the propagation of the latent states through time.

Section Title: QUALITATIVE PREDICTIONS FROM THE LATENT VARIABLE MODEL
  QUALITATIVE PREDICTIONS FROM THE LATENT VARIABLE MODEL We show example image samples from our learned sequential latent variable model for the cheetah task in  Figure 7 , and we include the other tasks in Appendix D. Samples from the posterior show the images x t as constructed by the decoder p ψ (x t |z t ), using a sequence of latents z t that are encoded and sampled from the posteriors, q ψ (z 1 |x 1 ) and q ψ (z t+1 |x t+1 , z t , a t ). Samples from the prior, on the other hand, use a sequence of latents where z 1 is sampled from p(z 1 ) and all remaining latents z t are from the propagation of the previous latent state through the latent dynamics p ψ (z t+1 |z t , a t ). Note that these prior samples do not use any image frames as inputs, and thus they do not correspond to any ground truth sequence. We also show samples from the conditional prior, which is conditioned on the first image from the true sequence: for this, the sampling procedure is the same as the prior, except that z 1 is encoded and sampled from the posterior q ψ (z 1 |x 1 ), rather than being sampled from p(z 1 ). We notice that the generated images samples can be sharper and more realistic by using a smaller variance for p ψ (x t |z t ) when training the model, but at the expense of a representation that leads to lower returns. Finally, note that we do not actually use the samples from the prior for training.

Section Title: DISCUSSION
  DISCUSSION We presented SLAC, an efficient RL algorithm for learning from high-dimensional image inputs that combines efficient off-policy model-free RL with representation learning via a sequential stochastic state space model. Through representation learning in conjunction with effective task learning in the learned latent space, our method achieves improved sample efficiency and final task performance as compared to both prior model-based and model-free RL methods. While our current SLAC algorithm is fully model-free, in that predictions from the model are not utilized to speed up training, a natural extension of our approach would be to use the model predictions themselves to generate synthetic samples. Incorporating this additional synthetic model- based data into a mixed model-based/model-free method could further improve sample efficiency and performance. More broadly, the use of explicit representation learning with RL has the potential to not only accelerate training time and increase the complexity of achievable tasks, but also enable reuse and transfer of our learned representation across tasks.

```
