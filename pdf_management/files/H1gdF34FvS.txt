Title:
```
Under review as a conference paper at ICLR 2020 ADVANTAGE-WEIGHTED REGRESSION: SIMPLE AND SCALABLE OFF-POLICY REINFORCEMENT LEARNING
```
Abstract:
```
In this paper, we aim to develop a simple and scalable reinforcement learning al- gorithm that uses standard supervised learning methods as subroutines. Our goal is an algorithm that utilizes only simple and convergent maximum likelihood loss functions, while also being able to leverage off-policy data. Our proposed ap- proach, which we refer to as advantage-weighted regression (AWR), consists of two standard supervised learning steps: one to regress onto target values for a value function, and another to regress onto weighted target actions for the policy. The method is simple and general, can accommodate continuous and discrete ac- tions, and can be implemented in just a few lines of code on top of standard super- vised learning methods. We provide a theoretical motivation for AWR and analyze its properties when incorporating off-policy data from experience replay. We eval- uate AWR on a suite of standard OpenAI Gym benchmark tasks, and show that it achieves competitive performance compared to a number of well-established state-of-the-art RL algorithms. AWR is also able to acquire more effective poli- cies than most off-policy algorithms when learning from purely static datasets with no additional environmental interactions. Furthermore, we demonstrate our algorithm on challenging continuous control tasks with highly complex simulated characters. (Video 1 )
```

Figures/Tables Captions:
```
Figure 1: Complex simulated character trained using advantage-weighted regression. Left: Hu- manoid performing a spinkick. Right: Dog performing a canter.
Figure 2: Snapshots of AWR policies trained on OpenAI Gym tasks. Our simple algorithm learns effective policies for a diverse set of discrete and continuous control tasks.
Figure 3: Learning curves of the various algorithms when applied to OpenAI Gym tasks. Results are averaged across 5 random seeds. AWR is generally competitive with the best current methods.
Figure 4: Left: Learning curves comparing AWR with various components removed. Each com- ponent appears to contribute to improvements in performance, with the best performance achieved when all components are combined. Right: Learning curves comparing AWR with different ca- pacity replay buffers. AWR remains stable with large replay buffers containing primarily off-policy data from previous iterations of the algorithm.
Figure 5: Snapshots of 34 DoF humanoid and 64 DoF dog trained with AWR to imitate reference motion recorded from real world subjects. AWR is able to learn sophisticated skills with characters with large numbers of degrees of freedom.
Figure 6: Learning curves on motion imitation tasks. On these challenging tasks, AWR generally learns faster than PPO and RWR.
Figure 7: Performance of various algorithms on off-policy learning tasks with static datasets. AWR is able to learn policies that are comparable or better than the original demo policies.
Table 1: Final returns for different algorithms on the OpenAI Gym tasks, with ± corresponding to one standard deviation of the average return across 5 random seeds. In terms of final performance, AWR generally performs comparably or better than prior methods.
Table 2: Performance statistics of algorithms on the motion imitation tasks. Returns are normal- ized between the minimum and maximum possi- ble returns per episode.
```

Main Content:
```

Section Title: INTRODUCTION
  INTRODUCTION Model-free reinforcement learning can be a general and effective methodology for training agents to acquire sophisticated behaviors with minimal assumptions on the underlying task (Mnih et al., 2015; Heess et al., 2017; Pathak et al., 2017). However, reinforcement learning algorithms can be substantially more complex to implement and tune than standard supervised learning methods. Arguably the simplest reinforcement learning methods are policy gradient algorithms (Sutton et al., 2000), which directly differentiate the expected return and perform gradient ascent. Unfortunately, these methods can be notoriously unstable and are typically on-policy (or nearly on-policy), often requiring a substantial number of samples to learn effective behaviors. Our goal is to develop a reinforcement learning algorithm that is simple, easy to implement, and can readily incorporate off-policy experience data. In this work, we propose advantage-weighted regression (AWR), a simple off-policy algorithm for model-free RL. Each iteration of the AWR algorithm simply consists of two supervised regression steps: one for training a value function baseline via regression onto cumulative rewards, and another for training the policy via weighted regression. The complete algorithm is shown in Algorithm 1. Under review as a conference paper at ICLR 2020 AWR can accommodate continuous and discrete actions, and can be implemented in just a few lines of code on top of standard supervised learning methods. Despite its simplicity, we find that AWR achieves competitive results when compared to commonly used on-policy and off-policy RL algo- rithms, and can effectively incorporate fully off-policy data, which has been a challenge for other RL algorithms. Our derivation presents an interpretation of AWR as a constrained policy optimization procedure, and provides a theoretical analysis of the use of off-policy data with experience replay. We first revisit the original formulation of reward-weighted regression, an on-policy RL method that utilizes supervised learning to perform policy updates, and then propose a number of new de- sign decisions that significantly improve performance on a suite of standard continuous control benchmark tasks. We then provide a theoretical analysis of AWR, including the capability to in- corporate off-policy data with experience replay. Although the design of AWR involves only a few simple design decisions, we show experimentally that these additions provide for a large improve- ment over previous methods for regression-based policy search, such as reward-weighted regression (RWR) (Peters & Schaal, 2007), while also being substantially simpler than more modern methods, such as MPO (Abdolmaleki et al., 2018). We show that AWR achieves competitive performance when compared to several well-established state-of-the-art on-policy and off-policy algorithms. We further demonstrate our algorithm on challenging control tasks with complex simulated characters.

Section Title: PRELIMINARIES
  PRELIMINARIES In reinforcement learning, the objective is to learn a control policy that enables an agent to maxi- mize its expected return for a given task. At each time step t, the agent observes the state of the environment s t ∈ S, and samples an action a t ∈ A from a policy a t ∼ π(a t |s t ). The agent then applies that action, which results in a new state s t+1 and a scalar reward r t = r(s t , a t ). The goal is to learn an optimal policy that maximizes the agent's expected discounted return J(π), J(π) = E τ ∼pπ(τ ) ∞ t=0 γ t r t = E s∼dπ(s) E a∼π(a|s) [r(s, a)] , (1) where p π (τ ) represents the likelihood of a trajectory τ = {(s 0 , a 0 , r 0 ) , (s 1 , a 1 , r 1 ) , ...} under a pol- icy π, and γ ∈ [0, 1) is the discount factor. d π (s) = ∞ t=0 γ t p(s t = s|π) represents the unnormal- ized discounted state distribution induced by the policy π (Sutton & Barto, 1998), and p(s t = s|π) is the likelihood of the agent being in state s after following π for t timesteps. A popular class of algorithms for solving this problem is policy gradient (PG) methods, which directly estimates the gradient of the expected return with respect to the policy parameters ∇ π J(π), and then updates the policy with gradient ascent. Basic PG algorithms are generally on-policy methods, which require the data to be sampled from the same policy that is being optimized. This can result in poor sample efficiency, but PG algorithms can be modified to utilize off-policy data. An alternative class of RL methods is expectation-maximization algorithms. Instead of estimating the gradient of the expected return, EM algorithms first construct an estimate of the optimal policy using a dataset of experiences (E-step), and then projects this estimate onto the space of param- eterized policies (M-step). An early example of an EM-based RL algorithm is reward-weighted regression (RWR) (Peters et al., 2010). At each iteration, the E-step constructs an estimate of the optimal policy according to π * (a|s) ∝ π k (a|s)exp (R s,a /β), where π k represents the policy at the kth iteration of the algorithm, R s,a = ∞ t=0 γ t r t is the return, and β > 0 is a temperature param- eter. Then the M-step projects π * onto the space of parameterized policies by solving a supervised regression problem: The RWR update can be interpreted as fitting a new policy π k+1 to samples collected under the cur- rent policy π k , where the likelihood of each action is weighted by the exponentiated return received for that action. Since EM algorithms do not directly estimate the gradient of the expected return with respect to the current policy, they can be more amenable to learning from off-policy data.

Section Title: ADVANTAGE-WEIGHTED REGRESSION
  ADVANTAGE-WEIGHTED REGRESSION In this work, we present advantage-weighted regression (AWR), a simple off-policy RL algorithm based on reward-weighted regression. We first provide an overview of the complete advantage- weighted regression algorithm, and then describe its theoretical motivation and analyze its proper- ties. The complete AWR algorithm is summarized in Algorithm 1. Each iteration k of AWR consists of the following simple steps. First, the current policy π k (a|s) is used to sample a batch of trajecto- ries {τ i } that are then stored in the replay buffer D, which is structured as a first-in first-out (FIFO) queue, as is common for off-policy reinforcement learning algorithms (Mnih et al., 2015; Lillicrap et al., 2016). Then, the entire buffer D is used to fit a value function V D k (s) to the trajectories in the replay buffer, which can be done with simple Monte Carlo return estimates R D s,a = T t=0 γ t r t . Finally, the same buffer is used to fit a new policy using advantage-weighted regression, where each state-action pair in the buffer is weighted according to the exponentiated advantage exp( 1 β A D (s, a)), with the advantage given by A D (s, a) = R D s,a − V D (s) and β is a hyperparameter. AWR uses only supervised regression as learning subroutines, making the algorithm very simple to implement. In the following subsections, we first motivate the algorithm as an approximation to a constrained pol- icy search problem, and then extend our analysis to incorporate experience replay.

Section Title: DERIVATION
  DERIVATION In this section, we derive the AWR algorithm as an approximate optimization of a constrained policy search problem. Our goal is to find a policy that maximizes the expected improvement η(π) = J(π) − J(µ) over a sampling policy µ(a|s). We first derive AWR for the setting where the sampling policy is a single Markovian policy. Then, in the next section, we extend our result to the setting where the data is collected from multiple policies, as in the case of experience replay that we use in practice. The expected improvement η(π) can be expressed in terms of the advan- tage A µ (s, a) = R µ s,a − V µ (s) with respect to the sampling policy µ (Kakade & Langford, 2002; Schulman et al., 2015): η(π) = E s∼dπ(s) E a∼π(a|s) [A µ (s, a)] = E s∼dπ(s) E a∼π(a|s) R µ s,a − V µ (s) , (3) where R µ s,a denotes the return obtained by performing action a in state s and following µ for the following timesteps, and V µ (s) = a µ(a|s)R a s da corresponds to the value function of µ. This objective differs from the ones used in the derivations of related algorithms, such as RWR and REPS (Peters & Schaal, 2007; Peters et al., 2010; Abdolmaleki et al., 2018), which maximize the expected return J(π) instead of the expected improvement. The expected improvement directly gives rise to an objective that involves the advantage. We will see later that this yields weights for the policy update that differ in a subtle but important way from standard reward-weighted regression. As we show in our experiments, this difference results in a large empirical improvement. The objective in Equation 3 can be difficult to optimize due to the dependency between d π (s) and π, as well as the need to collect samples from π. Following Schulman et al. (2015), we can instead optimize an approximationη(π) of η(π) using the state distribution of µ: Here,η(π) matches η(π) to first order (Kakade & Langford, 2002), and provides a good estimate of η if π and µ are close in terms of the KL-divergence (Schulman et al., 2015). Using this objective, Under review as a conference paper at ICLR 2020 we can formulate the following constrained policy search problem: The constraint in Equation 6 ensures that the new policy π is close to the data distribution of µ, and therefore the surrogate objectiveη(π) remains a reasonable approximation to η(π). We refer the reader to Schulman et al. (2015) for a detailed derivation and an error bound. We can derive AWR as an approximate solution to this constrained optimization. This derivation follows a similar procedure as Peters et al. (2010), and begins by forming the Langrangian of the constrained optimization problem presented above, L(π, β) = s d µ (s) a π(a|s) R µ s,a − V µ (s) da ds + β − s d µ (s)D KL (π(·|s)||µ(·|s)) ds , (7) where β is a Lagrange multiplier. Differentiating L(π, β) with respect to π(a|s) and solving for the optimal policy π * results in the following expression for the optimal policy π * (a|s) = 1 Z(s) µ(a|s) exp 1 β R µ s,a − V µ (s) , (8) with Z(s) being the partition function. A detailed derivation is available in Appendix A. If π is represented by a function approximator (e.g., a neural network), a new policy can be obtained by projecting π * onto the manifold of parameterized policies, While this derivation for AWR largely follows the derivations used in prior work (Peters et al., 2010; Abdolmaleki et al., 2018), our expected improvement objective introduces a baseline V µ (s) to the policy update, which as we show in our experiments, is a crucial component for an effective algorithm. A similar advantage-weighting scheme has been previously used for fitted Q-iteration (Neumann & Peters, 2009), where the policy is given by In this definition, the likelihood of an action does not depend on its likelihood under the sampling distribution, and therefore does not enforce a trust region with respect to the sampling distribution. Next, we extend AWR to incorporate experience replay for off-policy training, where the sampling policy is no longer a single policy, but rather a mixture of policies from past iterations.

Section Title: EXPERIENCE REPLAY AND OFF-POLICY LEARNING
  EXPERIENCE REPLAY AND OFF-POLICY LEARNING A crucial design decision of AWR is the choice of sampling policy µ(a|s). Standard implementa- tions of RWR typically follow an on-policy approach, where the sampling policy is selected to be the current policy µ(a|s) = π k (a|s) at iteration k. This can be sample inefficient, as data collected at each iteration of the algorithms are discarded after a single update iteration. Importance sam- pling can be incorporated into RWR to reuse data from previous iterations, but at the cost of larger variance from the importance sampling estimator (Kober & Peters, 2009). Instead, we can improve sample efficiency of AWR by incorporating experience replay and explicitly accounting for training data from a mixture of multiple prior policies. As described in Algorithm 1, at each iteration, AWR collects a batch of data using the latest policy π k , and then stores this data in a replay buffer D, which also contains data collected from previous policies {π 1 , · · · , π k }. The value function and policy are then updated using samples drawn from D. This replay strategy is analogous to modeling the sampling policy as a mixture of policies from previous iterations µ k (τ ) = k i=1 w i π i (τ ), where π i (τ ) = p(τ |π i ) represents the likelihood of a trajectory τ under a policy π i from the ith iteration, and the weights i w i = 1 specify the probabilities of selecting each policy π i . We now extend the derivation from the previous section to the off-policy setting with experience re- play, and show that Algorithm 1 indeed optimizes the expected improvement over a sampling policy Under review as a conference paper at ICLR 2020 modeled by the replay buffer. Given a replay buffer consisting of trajectories from past policies, the joint state-action distribution of µ is given by µ(s, a) = k i=1 w i d πi (s)π i (a|s), and similarly for the marginal state distribution d µ (s) = k i=1 w i d πi (s). The expected improvement can now be ex- pressed with respect to the set of sampling policies in the replay buffer: η(π) = J(π)− i w i J(π i ). Similar to Equation 3, η(π) can be expressed in terms of the advantage A πi (s, a) = R πi s,a − V πi (s) of each sampling policies, As before, we can optimize an approximationη(π) of η(π) using the state distribution of µ, In Appendix B, we show that the update procedure in Algorithm 1 optimizes the following objective: arg max π k i=1 w i E s∼dπ i (s) E a∼π(a|s) [A πi (s, a)] (13) s.t. E s∼dµ(s) [D KL (π(·|s)||µ(·|s))] ≤ , (14) where µ(a|s) = µ(s,a) dµ(s) = i widπ i (s)πi(a|s) j wj dπ j (s) represents the conditional action distribution defined by the replay buffer. This objective can be solved via the Lagrangian to yield the following update: arg max π k i=1 w i E s∼dπ i (s) E a∼πi(a|s) log π(a|s) exp 1 β R πi s,a − j w j d πj (s)V πj (s) j w j d πj (s) , (15) where the expectations can be approximated by simply sampling from D following Line 6 of Algo- rithm 1. A detailed derivation is available in Appendix B. Note, the baseline in the exponent now consists of an average of the value functions of the different policies. One approach for estimating this quantity would be to fit separate value functions V πi for each policy. However, if only a small amount of data is available from each policy, then V πi could be highly inaccurate (Fu et al., 2019). Therefore, instead of learning separate value functions, we fit a single mean value functionV (s) that directly estimates the weighted average of V πi 's, V = arg min V i w i E s,∼dπ i (s) E a∼πi This loss can also be approximated by simply sampling from the replay buffer following Line 5 of Algorithm 1. The optimal solutionV (s) = i widπ i (s)V π i (s) j wj dπ j (s) is exactly the baseline in Equation 15.

Section Title: IMPLEMENTATION DETAILS
  IMPLEMENTATION DETAILS Finally, we discuss several design decisions that are important for a practical implementation of AWR. An overview of AWR is provided in Algorithm 1. The policy update in Equation 10 requires sampling states from the discounted state distribution d µ (s). However, we found that simply sam- pling states uniformly from D was also effective, and simpler to implement. This is a common strategy used in standard implementations of RL algorithms (Dhariwal et al., 2017). When updat- ing the value function and policy, Monte Carlo estimates can be used to approximate the expected return R D s,a of samples in D, but this can result in a high-variance estimate. Instead, we opt to approximate R D s,a using TD(λ) to obtain a lower-variance estimate (Sutton & Barto, 1998). TD(λ) is applied by bootstrapping with the value function V D k−1 (s) from the previous iteration. A simple Monte Carlo return estimator can also be used though, as shown in our experiments, but this pro- duces somewhat worse results. To further simplify the algorithm, instead of adaptively updating the Lagrange multiplier β, as is done in previous methods (Peters & Schaal, 2007; Peters et al., 2010; Abdolmaleki et al., 2018), we find that simply using a fixed constant for β is also effective. The weights ω D s,a = exp 1 β R D s,a − V D (s) used to update the policy can occasionally assume ex- cessively large values, which can cause gradients to explode. We therefore apply weight clippinĝ ω D s,a = min ω D s,a , ω max with a threshold ω max to mitigate issues due to exploding weights.

Section Title: RELATED WORK
  RELATED WORK Existing RL methods can be broadly categorized into on-policy and off-policy algorithms (Sutton & Barto, 1998). On-policy algorithms generally update the policy using data collected from the same policy. A popular class of on-policy algorithms is policy gradient methods (Williams, 1992; Sutton et al., 2000), which have been shown to be effective for a diverse array of complex tasks (Heess et al., 2017; Pathak et al., 2017; Peng et al., 2018; Rajeswaran et al., 2018). However, on-policy algorithms are typically data inefficient, requiring a large number of interactions with the environment. Off- policy algorithms improve sample efficiency by enabling a policy to be trained using data from other sources, such as data collected from different agents or data from previous iterations of the algorithm. Importance sampling is a simple strategy for incorporating off-policy data (Sutton & Barto, 1998; Meuleau et al., 2000; Hachiya et al., 2009), but can introduce optimization instabilities due to the potentially large variance of the importance sampling estimator. Dynamic programming methods based on Q-function learning can also leverage off-policy data (Precup et al., 2001; Mnih et al., 2015; Lillicrap et al., 2016; Gu et al., 2016; Haarnoja et al., 2018b). But these methods can be notoriously unstable, and in practice, require a variety of stabilization techniques to ensure more consistent performance (Hasselt et al., 2016; Wang et al., 2016; Munos et al., 2016; Hessel et al., 2017; Fujimoto et al., 2018; Nachum et al., 2018; Fu et al., 2019). Furthermore, it can be difficult to apply these methods to learn from fully off-policy data, where an agent is unable to collect additional environmental interactions (Fujimoto et al., 2019; Kumar et al., 2019). Alternatively, policy search can also be formulated under an expectation-maximization framework. This approach has lead to a variety of EM-based RL algorithms (Peters et al., 2010; Neumann, 2011; Abdolmaleki et al., 2018), an early example of which is reward-weighted regression (RWR) (Peters & Schaal, 2007). RWR presents a simple on-policy RL algorithm that casts policy search as a supervised regression problem. A similar algorithm, relative entropy policy search (REPS) (Peters et al., 2010), can also be derived from the dual formulation of a constrained policy search problem. RWR has a number appealing properties: it has a very simple update rule, and since each iteration corresponds to supervised learning, it can be more stable and easier to implement than many of the previously mentioned RL methods. Despite these advantages, RWR has not been shown to be an effective RL algorithm when combined with neural network function approximators, as demonstrated in prior work and our own experiments (Schulman et al., 2015; Duan et al., 2016). In this work, we propose a number of modifications to the formulation of RWR to produce an effective off-policy deep RL algorithm, while still retaining much of the simplicity of previous methods. Policy updates using supervised regression have been used in a number of prior work. The opti- mization problem being solved in REPS is similar to AWR (Peters et al., 2010), but REPS optimizes the expected return instead of the expected improvement. The weights in REPS also contains a Bellman error term that superficially resembles advantages, but are computed using a linear value function derived from a feature matching constraint. Learning the REPS value function requires minimization of a dual function, which is a complex function of the Bellman error, while the value function in AWR can be learned with simple supervised regression. More recently, Abdolmaleki et al. (2018) proposed MPO, a deep RL variant of REPS, which applies a partial EM algorithm for policy optimization. The method first fits a Q-function of the current policy via bootstrapping, and then performs a policy improvement step with respect to this Q-function under a trust region constraint that penalizes large policy changes. MPO uses off-policy data for training a Q-function critic via bootstrapping and employs Retrace(λ) for off-policy correction (Munos et al., 2016). In contrast, AWR is substantially simpler, as it can simply fit a value function to the observed returns in a replay buffer, and performs weighted supervised regression on the actions to fit the policy. Oh et al. (2018) proposed self-imitation learning (SIL), which augments policy gradient algorithms with an auxiliary behaviour cloning loss to reuse samples from past experiences. In contrast to SIL, AWR is a standalone algorithm, and does not need to be combined with an auxiliary RL algorithm. Neumann & Peters (2009) proposed LAWER, a kernel-based fitted Q-iteration algorithm where the Bellman error is weighted by the normalized advantage of each state-action pair. This was then followed by a soft-policy improvement step. Similar to Neumann & Peters (2009), our method also uses exponentiated advantages during policy updates, but their definition of the policy is different from the one in AWR and does not enforce a trust region constraint. Furthermore, AWR does not perform fitted Q-iteration, and instead utilizes off-policy data in a simple constrained policy search procedure. Wang et al. (2018) applied a similar advantage-weighting scheme for imitation learning, but the method was not demonstrated for the RL setting. In this work, we propose several design Under review as a conference paper at ICLR 2020 decisions that are vital for an effective RL algorithm. We also provide a theoretical analysis of AWR when combined with experience replay, and show that the algorithm indeed optimizes the expected improvement with respect to a trajectory-level mixture of past policies modeled by a replay buffer.

Section Title: EXPERIMENTS
  EXPERIMENTS Our experiments aim to comparatively evaluate the performance of AWR to commonly used on- policy and off-policy deep RL algorithms. We evaluate our method on the OpenAI Gym bench- marks (Brockman et al., 2016), consisting of discrete and continuous control tasks. We also evaluate our method on complex motion imitation tasks with high-dimensional simulated characters, includ- ing a 34 DoF humanoid and 64 DoF dog (Peng et al., 2018). We then demonstrate the effectiveness of AWR on fully off-policy learning, by training on static datasets of demonstrations collected from demo policies. Behaviors learned by the policies are best seen in the supplementary video 1 . Code for our implementation of AWR is available at sites.google.com/view/awr-supp/. At each iteration, the agent collects a batch of approximately 2000 samples, which are stored in the replay buffer D along with samples from previous iterations. The replay buffer stores 50k of the most recent sam- ples. Updates to the value function and policy are performed by uniformly sampling minibatches of 256 samples from D. The value function is updated with 200 gradient steps per iteration, and the policy is updated with 1000 steps. Detailed hyperparameter settings are provided in Appendix C.

Section Title: BENCHMARKS
  BENCHMARKS We compare AWR to a number of state-of-the-art RL algorithms, including on-policy algorithms, such as TRPO (Schulman et al., 2015) and PPO (Schulman et al., 2017), off-policy algorithms, such as DDPG (Lillicrap et al., 2016), TD3 (Fujimoto et al., 2018), and SAC (Haarnoja et al., 2018a), as well as RWR (Peters & Schaal, 2007), which we include for comparison due to its similarity to AWR. 2 TRPO and PPO use the implementations from OpenAI baselines (Dhariwal et al., 2017). DDPG, TD3, and SAC uses the implementations from RLkit (Pong, 2019). RWR is a custom im- plementation following the algorithm described by Peters & Schaal (2007). Snapshots of the AWR policies are shown in  Figure 2 . Learning curves comparing the different algo- rithms on the OpenAI Gym benchmarks are shown in  Figure 3 , and  Table 1  summarizes the average returns of the final policies across 5 training runs initialized with different random seeds. Overall, AWR shows competitive performance with the state-of-the-art deep RL algorithms. It significantly outperforms on-policy methods such as PPO and TRPO in both sample efficiency and asymptotic performance. While it is not yet as sample efficient as current state-of-the-art off-policy methods, such SAC and TD3, it is generally able to achieve a similar asymptotic performance, despite us- ing only simple supervised regression for both policy and value function updates. The complex Humanoid-V2 task proved to be the most challenging case for AWR, and its performance still lags well behind SAC. Note that RWR generally does not perform well on any of these tasks. This sug- Under review as a conference paper at ICLR 2020 gests that, although AWR is simple and easy to implement, the particular modifications it makes compared to standard RWR are critical for effective performance. To illustrate AWR's generality on tasks with discrete actions, we compare AWR to TRPO, PPO, and RWR on LunarLander-v2. DDPG, TD3, and SAC are not easily applicable to discrete action spaces due to their need to back- propagate from the Q-function to the policy. On this discrete control task, AWR also shows strong performance compared to the other algorithms.

Section Title: ABLATION EXPERIMENTS
  ABLATION EXPERIMENTS To determine the effects of various design decisions, we evaluate the performance of AWR when key components of the algorithm have been removed. The experiments include an on-policy version of AWR (On-Policy), where only data collected from the latest policy is used to perform updates. We also compare with a version of AWR without the baseline V (s) (No Baseline), which corresponds to using the standard RWR weights ω s,a = exp( 1 β R s,a ), and another version that uses Monte Carlo return estimates instead of TD(λ) (No TD(λ)). The effects of these components are illustrated in  Figure 4 . Overall, these design decisions appear to be vital for an effective algorithm, with the most crucial components being the use of experience replay and a baseline. Updates using only on-policy data can lead to instabilities and result in noticeable degradation in performance, which may be due to overfitting on a smaller dataset. This issue might be mitigated by collecting a larger batch of on-policy data per iteration, but this can also negatively impact sample efficiency. Removing the baseline also noticeably hampers performance. Using simple Monte Carlo return estimates instead of TD(λ) seems to be a viable alternative, and the algorithm still achieves competitive performance on some tasks. When combined, these different components yield substantial performance gains over standard RWR. To better evaluate the effect of experience replay on AWR, we compare the performance of policies trained with different capacities for the replay buffer.  Figure 4  illustrates the learning curves for buffers of size 5k, 20k, 50k, 100k, and 500k, with 50k being the default buffer size in our exper- iments. The size of the replay buffer appears to have a significant impact on overall performance. Smaller buffer sizes can result in instabilities during training, which again may be an effect of over- fitting to a smaller dataset. As the buffer size increases, AWR remains stable even when the dataset is dominated by off-policy data from previous iterations. In fact, performance over the course of training appears more stable with larger replay buffers, but progress can also become slower. Since the sampling policy µ(a|s) is modeled by the replay buffer, a larger buffer can limit the rate at which µ changes by maintaining older data for more iterations. Due to the trust region penalty in Equa- tion 7, a slower changing µ also prevents the policy π from changing quickly. The replay buffer therefore provides a simple mechanism to trade-off between stability and learning speed.

Section Title: MOTION IMITATION
  MOTION IMITATION The Gym benchmarks present relatively low-dimensional tasks. In this section, we study how AWR can solve higher-dimensional tasks with complex simulated characters, including a 34 DoF hu- manoid and 64 DoF dog. The objective of the tasks is to imitate reference motion clips recorded using motion capture from real world subjects. The experimental setup follows the motion imita- tion framework proposed by Peng et al. (2018). Motion clips are collected from publicly available datasets (CMU; SFU; Zhang et al., 2018). The skills include highly dynamics motions, such as spinkicks and canters (i.e. running), and motions that requires more coordinated movements of the character's body, such as a cartwheel. Snapshots of the behaviors learned by the AWR policies are available in  Figure 5 .  Table 2  compares the performance of AWR to RWR and the highly-tuned PPO implementation from Peng et al. (2018). Learning curves for the different algorithms are shown in  Figure 6 . AWR performs well across the set of challenging skills, consistently achieving compa- rable or better performance than PPO. RWR struggles with controlling the humanoid, but exhibits stronger performance on the dog. This performance difference may be due to the more dynamic and acrobatic skills of the humanoid, compared to the more standard locomotion skills of the dog.

Section Title: OFF-POLICY LEARNING WITH STATIC DATASETS
  OFF-POLICY LEARNING WITH STATIC DATASETS Since AWR is an off-policy RL algorithm, it has the advantage of being able to leverage data from other sources. This not only accelerates the learning process on standard tasks, as dis- cussed above, but also allows us to apply AWR in a fully off-policy setting, where the algorithm is provided with a static dataset of transitions, and then tasked with learning the best possible pol- icy. To evaluate our method in this setting, we use the off-policy tasks proposed by Kumar et al. (2019). The objective of these tasks is to learn policies solely from static datasets, without collect- ing any additional data from the policy that is being trained. The dataset consists of trajectories τ = {(s 0 , a 0 , r 0 ) , (s 1 , a 1 , r 1 ) , ...} from rollouts of a demo policy. Unlike standard imitation learn- ing tasks, which only observes the states and actions from the demo policy, the dataset also provides the reward received by the demo policy at each step. The demo policies are trained using SAC on various OpenAI Gym tasks. A dataset of 1 million timesteps is collected for each task. For AWR, we simply treat the dataset as the replay buffer D and directly apply the algorithm with- out additional modifications.  Figure 7  compares AWR with other algorithms when applied to the datasets. We include comparisons to the performance of the original demo policy used to gener- ate the dataset (Demo) and a behavioral cloning policy (BC). The comparisons also include recent off-policy methods: batch-constrained Q-learning (BCQ) (Fujimoto et al., 2019) and bootstrapping error accumulation reduction (BEAR) (Kumar et al., 2019), which have shown strong performance on off-policy learning with static datasets. Note that both of these prior methods are modifications to existing off-policy RL methods, such as TD3 and SAC, which are already quite complex. In contrast, AWR is simple and requires no modifications for the fully off-policy setting. Despite not collecting any additional data, AWR is able to learn effective policies from these fully off-policy datasets, achieving comparable or better performance than the original demo policies. On-policy methods, such as PPO performs poorly in this off-policy setting. Q-function based methods, such as TD3 and SAC, can in principle handle off-policy data but, as discussed in prior work, tend to strug- gle in this setting in practice (Fujimoto et al., 2019; Kumar et al., 2019). Indeed, standard behavioral cloning (BC) often outperforms these standard RL methods. In this fully off-policy setting, AWR can be interpreted as an advantage-weighted form of behavioral cloning, which assigns higher like- lihoods to demonstration actions that receive higher advantages. Unlike Q-function based methods, AWR is less susceptible to issues from out-of-distribution actions as the policy is always trained on observed actions from the behaviour data (Kumar et al., 2019). AWR also shows comparable perfor- mance to BEAR and BCQ, which are specifically designed for this off-policy setting and introduce considerable algorithmic overhead.

Section Title: DISCUSSION AND FUTURE WORK
  DISCUSSION AND FUTURE WORK We presented advantage-weighted regression, a simple off-policy reinforcement learning algorithm, where policy updates are performed using standard supervised learning methods. Despite its sim- plicity, our algorithm is able to solve challenging control tasks with complex simulated agents, and achieve competitive performance on standard benchmarks compared to a number of well-established RL algorithms. Our derivation introduces several new design decisions, and our experiments ver- ify the importance of these components. AWR is also able to learn from fully off-policy datasets, demonstrating comparable performance to state-of-the-art off-policy methods. While AWR is effec- tive for a diverse suite of tasks, it is not yet as sample efficient as the most efficient off-policy algo- rithms. We believe that exploring techniques for improving sample efficiency and performance on fully off-policy learning can open opportunities to deploy these methods in real world domains. We are also interested in exploring applications that are particularly suitable for these regression-based RL algorithms, as compared to other classes of RL techniques. A better theoretical understanding of the convergence properties of these algorithms, especially when combined with experience replay, could also be valuable for the development of future algorithms.
  While we attempted to compare to MPO (Abdolmaleki et al., 2018), we were unable to find source code for an implementation that reproduces results comparable to those reported by Abdolmaleki et al. (2018), and could not implement the algorithm such that it achieves similar performance to those reported by the authors.

```
